<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Freja-svn] r82 - in branch/2.0.1: .	examples/contacts/models/php_inc lib src src/auxiliary tests
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/freja-svn/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:freja-svn%40lists.berlios.de?Subject=Re%3A%20%5BFreja-svn%5D%20r82%20-%20in%20branch/2.0.1%3A%20.%0A%09examples/contacts/models/php_inc%20lib%20src%20src/auxiliary%20tests&In-Reply-To=%3C200703192208.l2JM8Ckp024641%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000079.html">
   <LINK REL="Next"  HREF="000081.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Freja-svn] r82 - in branch/2.0.1: .	examples/contacts/models/php_inc lib src src/auxiliary tests</H1>
    <B>cedsav at mail.berlios.de</B> 
    <A HREF="mailto:freja-svn%40lists.berlios.de?Subject=Re%3A%20%5BFreja-svn%5D%20r82%20-%20in%20branch/2.0.1%3A%20.%0A%09examples/contacts/models/php_inc%20lib%20src%20src/auxiliary%20tests&In-Reply-To=%3C200703192208.l2JM8Ckp024641%40sheep.berlios.de%3E"
       TITLE="[Freja-svn] r82 - in branch/2.0.1: .	examples/contacts/models/php_inc lib src src/auxiliary tests">cedsav at mail.berlios.de
       </A><BR>
    <I>Mon Mar 19 23:08:12 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000079.html">[Freja-svn] r81 - branch/2.0.1/src
</A></li>
        <LI>Next message: <A HREF="000081.html">[Freja-svn] r83 - in branch/2.0.1/examples/basecamp_api: . css views
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#80">[ date ]</a>
              <a href="thread.html#80">[ thread ]</a>
              <a href="subject.html#80">[ subject ]</a>
              <a href="author.html#80">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: cedsav
Date: 2007-03-19 23:07:30 +0100 (Mon, 19 Mar 2007)
New Revision: 82

Added:
   branch/2.0.1/custom_rhino.jar
   branch/2.0.1/lib/Freja_pack.js
   branch/2.0.1/lib/Sarissa_pack.js
   branch/2.0.1/pack.bat
Modified:
   branch/2.0.1/build.wsf
   branch/2.0.1/examples/contacts/models/php_inc/inc.resource.php
   branch/2.0.1/lib/Freja.js
   branch/2.0.1/lib/MochiKit.js
   branch/2.0.1/lib/Sarissa.js
   branch/2.0.1/src/AssetManager.js
   branch/2.0.1/src/Model.js
   branch/2.0.1/src/View.js
   branch/2.0.1/src/auxiliary/minimal.js
   branch/2.0.1/src/auxiliary/mochi+sarissa.js
   branch/2.0.1/tests/test_Freja-Model.html
   branch/2.0.1/tests/test_View.js
Log:


Modified: branch/2.0.1/build.wsf
===================================================================
--- branch/2.0.1/build.wsf	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/build.wsf	2007-03-19 22:07:30 UTC (rev 82)
@@ -50,7 +50,7 @@
 			&quot;\n    THIS FILE IS AUTOMATICALLY GENERATED.  If creating patches, please&quot; +
 			&quot;\n    diff against the source tree, not this file.&quot; +
 			&quot;\n&quot; +
-			&quot;\n    Copyright (c) 2006 C&#233;dric Savarese &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">pro at 4213miles.com</A>&gt;, Troels Knak-Nielsen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">troelskn at gmail.com</A>&gt;&quot; +
+			&quot;\n    Copyright (c) 2006-2007 Cedric Savarese &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cedric at veerwest.com</A>&gt;, Troels Knak-Nielsen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">troelskn at gmail.com</A>&gt;&quot; +
 			&quot;\n    This software is licensed under the CC-GNU LGPL &lt;<A HREF="http://creativecommons.org/licenses/LGPL/2.1/">http://creativecommons.org/licenses/LGPL/2.1/</A>&gt;&quot; +
 			&quot;\n&quot; +
 			&quot;\n***&quot; + &quot;/&quot; +
@@ -70,6 +70,9 @@
 		var out = FileSystem.openTextFile(outfile, 2, -2);
 		out.write(header + source);
 		out.close();
+		
+		Shell.CurrentDirectory = cwd;
+		Shell.run(&quot;pack.bat&quot;);
 	}
 	]]&gt;
 	&lt;/script&gt;

Added: branch/2.0.1/custom_rhino.jar
===================================================================
(Binary files differ)


Property changes on: branch/2.0.1/custom_rhino.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: branch/2.0.1/examples/contacts/models/php_inc/inc.resource.php
===================================================================
--- branch/2.0.1/examples/contacts/models/php_inc/inc.resource.php	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/examples/contacts/models/php_inc/inc.resource.php	2007-03-19 22:07:30 UTC (rev 82)
@@ -1,9 +1,12 @@
 &lt;?php
 $request_headers = apache_request_headers();
 if (isset($request_headers['Http-Method-Equivalent'])) {
-	$REQUEST_METHOD = $request_headers['Http-Method-Equivalent'];
+   $REQUEST_METHOD = $request_headers['Http-Method-Equivalent'];
+} elseif (isset($request_headers['http-method-equivalent'])) {
+// IE sends the Http-Method-Equivalent header in lowercase!
+    $REQUEST_METHOD = $request_headers['http-method-equivalent'];
 } else {
-	$REQUEST_METHOD = $_SERVER['REQUEST_METHOD'];
+   $REQUEST_METHOD = $_SERVER['REQUEST_METHOD'];
 }
 
 if ($REQUEST_METHOD == &quot;PUT&quot; || $REQUEST_METHOD == &quot;POST&quot;) {

Modified: branch/2.0.1/lib/Freja.js
===================================================================
--- branch/2.0.1/lib/Freja.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/lib/Freja.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -2,9 +2,9 @@
 
     Freja 2.0.1
 
-    Build $Mon, 12 Mar 2007 20:41:24 UTC$
+    Build $Mon, 19 Mar 2007 22:06:59 UTC$
 
-    Target: mochi+sarissa
+    Target: minimal
 
     THIS FILE IS AUTOMATICALLY GENERATED.  If creating patches, please
     diff against the source tree, not this file.
@@ -47,152 +47,662 @@
 	subClass.prototype.superconstructor = superconstructor;
 	subClass.prototype.supertype = superconstructor.prototype;
 };
+
 /**
-  * Freja._aux
-  * wrapper for external dependencies (frameworks).
-  *
-  * This is the default auxiliary adapter. It bridges Freja to MochiKit + Sarissa
-  *
-  * You shouldn't rely on this functionality - it's merely a hook for Freja towards
-  * external dependencies. This is the only part of the application you'll need to
-  * adjust, to make Freja play ball with your favourite framework.
-  */
-if (typeof(dojo) != &quot;undefined&quot;) {
-	dojo.require(&quot;MochiKit.Base&quot;);
-	dojo.require(&quot;MochiKit.Signal&quot;);
-	dojo.require(&quot;MochiKit.Async&quot;);
-	dojo.require(&quot;Sarissa&quot;);
-}
-if (typeof(JSAN) != &quot;undefined&quot;) {
-	JSAN.use(&quot;MochiKit.Base&quot;, []);
-	JSAN.use(&quot;MochiKit.Signal&quot;, []);
-	JSAN.use(&quot;MochiKit.Async&quot;, []);
-	JSAN.use(&quot;Sarissa&quot;, []);
-}
-try {
-	if (typeof(MochiKit.Base) == &quot;undefined&quot;) {
-		throw &quot;&quot;;
-	}
-	if (typeof(MochiKit.Signal) == &quot;undefined&quot;) {
-		throw &quot;&quot;;
-	}
-	if (typeof(MochiKit.Async) == &quot;undefined&quot;) {
-		throw &quot;&quot;;
-	}
-	if (typeof(Sarissa) == &quot;undefined&quot;) {
-		throw &quot;&quot;;
-	}
-} catch (e) {
-	throw new Error(&quot;Freja depends on MochiKit.Base, MochiKit.Signal, MochiKit.Async and Sarissa!&quot;);
-}
-if (typeof(Freja) == &quot;undefined&quot;) {
-	Freja = {};
-}
-Freja._aux = {};
-/** bind(func, self) : function */
-Freja._aux.bind = MochiKit.Base.bind;
-/** formContents(elem) : Array */
-Freja._aux.formContents = MochiKit.DOM.formContents;
-/** getElement(id) : HTMLElement */
-Freja._aux.getElement = MochiKit.DOM.getElement;
+ * ====================================================================
+ * About
+ * ====================================================================
+ * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
+ * The library supports Gecko based browsers like Mozilla and Firefox,
+ * Internet Explorer (5.5+ with MSXML3.0+), Konqueror, Safari and a little of Opera
+ * @version 0.9.7.6
+ * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
+ * ====================================================================
+ * Licence
+ * ====================================================================
+ * Sarissa is free software distributed under the GNU GPL version 2 (see &lt;a href=&quot;gpl.txt&quot;&gt;gpl.txt&lt;/a&gt;) or higher, 
+ * GNU LGPL version 2.1 (see &lt;a href=&quot;lgpl.txt&quot;&gt;lgpl.txt&lt;/a&gt;) or higher and Apache Software License 2.0 or higher 
+ * (see &lt;a href=&quot;asl.txt&quot;&gt;asl.txt&lt;/a&gt;). This means you can choose one of the three and use that if you like. If 
+ * you make modifications under the ASL, i would appreciate it if you submitted those.
+ * In case your copy of Sarissa does not include the license texts, you may find
+ * them online in various formats at &lt;a href=&quot;<A HREF="http://www.gnu.org">http://www.gnu.org</A>&quot;&gt;<A HREF="http://www.gnu.org&lt;/a">http://www.gnu.org&lt;/a</A>&gt; and 
+ * &lt;a href=&quot;<A HREF="http://www.apache.org">http://www.apache.org</A>&quot;&gt;<A HREF="http://www.apache.org&lt;/a">http://www.apache.org&lt;/a</A>&gt;.
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY 
+ * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
+ * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
+ * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+/**
+ * &lt;p&gt;Sarissa is a utility class. Provides &quot;static&quot; methods for DOMDocument, 
+ * DOM Node serialization to XML strings and other utility goodies.&lt;/p&gt;
+ * @constructor
+ */
+function Sarissa(){};
+Sarissa.PARSED_OK = &quot;Document contains no parsing errors&quot;;
+Sarissa.PARSED_EMPTY = &quot;Document is empty&quot;;
+Sarissa.PARSED_UNKNOWN_ERROR = &quot;Not well-formed or other error&quot;;
+var _sarissa_iNsCounter = 0;
+var _SARISSA_IEPREFIX4XSLPARAM = &quot;&quot;;
+var _SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation &amp;&amp; true;
+var _SARISSA_HAS_DOM_CREATE_DOCUMENT = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.createDocument;
+var _SARISSA_HAS_DOM_FEATURE = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.hasFeature;
+var _SARISSA_IS_MOZ = _SARISSA_HAS_DOM_CREATE_DOCUMENT &amp;&amp; _SARISSA_HAS_DOM_FEATURE;
+var _SARISSA_IS_SAFARI = (navigator.userAgent &amp;&amp; navigator.vendor &amp;&amp; (navigator.userAgent.toLowerCase().indexOf(&quot;applewebkit&quot;) != -1 || navigator.vendor.indexOf(&quot;Apple&quot;) != -1));
+var _SARISSA_IS_IE = document.all &amp;&amp; window.ActiveXObject &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;) &gt; -1  &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;opera&quot;) == -1;
+if(!window.Node || !Node.ELEMENT_NODE){
+    Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
+};
 
-/** connect(src, signal, fnc) : void */
-Freja._aux.connect = MochiKit.Signal.connect;
-/** signal(src, signal, arg) : void */
-Freja._aux.signal = MochiKit.Signal.signal;
-/** createDeferred() : Deferred */
-Freja._aux.createDeferred = function() {
-	return new MochiKit.Async.Deferred();
+if(typeof XMLDocument == &quot;undefined&quot; &amp;&amp; typeof Document !=&quot;undefined&quot;){ XMLDocument = Document; } 
+
+// IE initialization
+if(_SARISSA_IS_IE){
+    // for XSLT parameter names, prefix needed by IE
+    _SARISSA_IEPREFIX4XSLPARAM = &quot;xsl:&quot;;
+    // used to store the most recent ProgID available out of the above
+    var _SARISSA_DOM_PROGID = &quot;&quot;;
+    var _SARISSA_XMLHTTP_PROGID = &quot;&quot;;
+    var _SARISSA_DOM_XMLWRITER = &quot;&quot;;
+    /**
+     * Called when the Sarissa_xx.js file is parsed, to pick most recent
+     * ProgIDs for IE, then gets destroyed.
+     * @private
+     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
+     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
+     */
+    Sarissa.pickRecentProgID = function (idList){
+        // found progID flag
+        var bFound = false;
+        for(var i=0; i &lt; idList.length &amp;&amp; !bFound; i++){
+            try{
+                var oDoc = new ActiveXObject(idList[i]);
+                o2Store = idList[i];
+                bFound = true;
+            }catch (objException){
+                // trap; try next progID
+            };
+        };
+        if (!bFound) {
+            throw &quot;Could not retreive a valid progID of Class: &quot; + idList[idList.length-1]+&quot;. (original exception: &quot;+e+&quot;)&quot;;
+        };
+        idList = null;
+        return o2Store;
+    };
+    // pick best available MSXML progIDs
+    _SARISSA_DOM_PROGID = null;
+    _SARISSA_THREADEDDOM_PROGID = null;
+    _SARISSA_XSLTEMPLATE_PROGID = null;
+    _SARISSA_XMLHTTP_PROGID = null;
+    if(!window.XMLHttpRequest){
+        /**
+         * Emulate XMLHttpRequest
+         * @constructor
+         */
+        XMLHttpRequest = function() {
+            if(!_SARISSA_XMLHTTP_PROGID){
+                _SARISSA_XMLHTTP_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XMLHTTP.6.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]);
+            };
+            return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
+        };
+    };
+    // we dont need this anymore
+    //============================================
+    // Factory methods (IE)
+    //============================================
+    // see non-IE version
+    Sarissa.getDomDocument = function(sUri, sName){
+        if(!_SARISSA_DOM_PROGID){
+            _SARISSA_DOM_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.DOMDocument.6.0&quot;, &quot;Msxml2.DOMDocument.3.0&quot;, &quot;MSXML2.DOMDocument&quot;, &quot;MSXML.DOMDocument&quot;, &quot;Microsoft.XMLDOM&quot;]);
+        };
+        var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+        // if a root tag name was provided, we need to load it in the DOM object
+        if (sName){
+            // create an artifical namespace prefix 
+            // or reuse existing prefix if applicable
+            var prefix = &quot;&quot;;
+            if(sUri){
+                if(sName.indexOf(&quot;:&quot;) &gt; 1){
+                    prefix = sName.substring(0, sName.indexOf(&quot;:&quot;));
+                    sName = sName.substring(sName.indexOf(&quot;:&quot;)+1); 
+                }else{
+                    prefix = &quot;a&quot; + (_sarissa_iNsCounter++);
+                };
+            };
+            // use namespaces if a namespace URI exists
+            if(sUri){
+                oDoc.loadXML('&lt;' + prefix+':'+sName + &quot; xmlns:&quot; + prefix + &quot;=\&quot;&quot; + sUri + &quot;\&quot;&quot; + &quot; /&gt;&quot;);
+            } else {
+                oDoc.loadXML('&lt;' + sName + &quot; /&gt;&quot;);
+            };
+        };
+        return oDoc;
+    };
+    // see non-IE version   
+    Sarissa.getParseErrorText = function (oDoc) {
+        var parseErrorText = Sarissa.PARSED_OK;
+        if(oDoc.parseError.errorCode != 0){
+            parseErrorText = &quot;XML Parsing Error: &quot; + oDoc.parseError.reason + 
+                &quot;\nLocation: &quot; + oDoc.parseError.url + 
+                &quot;\nLine Number &quot; + oDoc.parseError.line + &quot;, Column &quot; + 
+                oDoc.parseError.linepos + 
+                &quot;:\n&quot; + oDoc.parseError.srcText +
+                &quot;\n&quot;;
+            for(var i = 0;  i &lt; oDoc.parseError.linepos;i++){
+                parseErrorText += &quot;-&quot;;
+            };
+            parseErrorText +=  &quot;^\n&quot;;
+        }
+        else if(oDoc.documentElement == null){
+            parseErrorText = Sarissa.PARSED_EMPTY;
+        };
+        return parseErrorText;
+    };
+    // see non-IE version
+    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
+        oDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
+        oDoc.setProperty(&quot;SelectionNamespaces&quot;, sNsSet);
+    };   
+    /**
+     * Basic implementation of Mozilla's XSLTProcessor for IE. 
+     * Reuses the same XSLT stylesheet for multiple transforms
+     * @constructor
+     */
+    XSLTProcessor = function(){
+        if(!_SARISSA_XSLTEMPLATE_PROGID){
+            _SARISSA_XSLTEMPLATE_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XSLTemplate.6.0&quot;, &quot;MSXML2.XSLTemplate.3.0&quot;]);
+        };
+        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
+        this.processor = null;
+    };
+    /**
+     * Imports the given XSLT DOM and compiles it to a reusable transform
+     * &lt;b&gt;Note:&lt;/b&gt; If the stylesheet was loaded from a URL and contains xsl:import or xsl:include elements,it will be reloaded to resolve those
+     * @argument xslDoc The XSLT DOMDocument to import
+     */
+    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
+        if(!_SARISSA_THREADEDDOM_PROGID){
+            _SARISSA_THREADEDDOM_PROGID = Sarissa.pickRecentProgID([&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;, &quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
+        };
+        xslDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
+        xslDoc.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+        // convert stylesheet to free threaded
+        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
+        // make included/imported stylesheets work if exist and xsl was originally loaded from url
+        if(xslDoc.url &amp;&amp; xslDoc.selectSingleNode(&quot;//xsl:*[local-name() = 'import' or local-name() = 'include']&quot;) != null){
+            converted.async = false;
+            if (_SARISSA_THREADEDDOM_PROGID == &quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;) { 
+                converted.setProperty(&quot;AllowDocumentFunction&quot;, true); 
+                converted.resolveExternals = true; 
+            }
+            converted.load(xslDoc.url);
+        } else {
+            converted.loadXML(xslDoc.xml);
+        };
+        converted.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+        var output = converted.selectSingleNode(&quot;//xsl:output&quot;);
+        this.outputMethod = output ? output.getAttribute(&quot;method&quot;) : &quot;html&quot;;
+        this.template.stylesheet = converted;
+        this.processor = this.template.createProcessor();
+        // for getParameter and clearParameters
+        this.paramsSet = new Array();
+    };
+
+    /**
+     * Transform the given XML DOM and return the transformation result as a new DOM document
+     * @argument sourceDoc The XML DOMDocument to transform
+     * @return The transformation result as a DOM Document
+     */
+    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
+        // fix for bug 1549749
+        if(_SARISSA_THREADEDDOM_PROGID){
+            this.processor.input=sourceDoc;
+            var outDoc=new ActiveXObject(_SARISSA_DOM_PROGID);
+            this.processor.output=outDoc;
+            this.processor.transform();
+            return outDoc;
+        }
+        else{
+            if(!_SARISSA_DOM_XMLWRITER){
+                _SARISSA_DOM_XMLWRITER = Sarissa.pickRecentProgID([&quot;Msxml2.MXXMLWriter.6.0&quot;, &quot;Msxml2.MXXMLWriter.3.0&quot;, &quot;MSXML2.MXXMLWriter&quot;, &quot;MSXML.MXXMLWriter&quot;, &quot;Microsoft.XMLDOM&quot;]);
+            };
+            this.processor.input = sourceDoc;
+            var outDoc = new ActiveXObject(_SARISSA_DOM_XMLWRITER);
+            this.processor.output = outDoc; 
+            this.processor.transform();
+            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+            oDoc.loadXML(outDoc.output+&quot;&quot;);
+            return oDoc;
+        };
+    };
+    
+    /**
+     * Transform the given XML DOM and return the transformation result as a new DOM fragment.
+     * &lt;b&gt;Note&lt;/b&gt;: The xsl:output method must match the nature of the owner document (XML/HTML).
+     * @argument sourceDoc The XML DOMDocument to transform
+     * @argument ownerDoc The owner of the result fragment
+     * @return The transformation result as a DOM Document
+     */
+    XSLTProcessor.prototype.transformToFragment = function (sourceDoc, ownerDoc) {
+        this.processor.input = sourceDoc;
+        this.processor.transform();
+        var s = this.processor.output;
+        var f = ownerDoc.createDocumentFragment();
+        if (this.outputMethod == 'text') {
+            f.appendChild(ownerDoc.createTextNode(s));
+        } else if (ownerDoc.body &amp;&amp; ownerDoc.body.innerHTML) {
+            var container = ownerDoc.createElement('div');
+            container.innerHTML = s;
+            while (container.hasChildNodes()) {
+                f.appendChild(container.firstChild);
+            }
+        }
+        else {
+            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+            if (s.substring(0, 5) == '&lt;?xml') {
+                s = s.substring(s.indexOf('?&gt;') + 2);
+            }
+            var xml = ''.concat('&lt;my&gt;', s, '&lt;/my&gt;');
+            oDoc.loadXML(xml);
+            var container = oDoc.documentElement;
+            while (container.hasChildNodes()) {
+                f.appendChild(container.firstChild);
+            }
+        }
+        return f;
+    };
+    
+    /**
+     * Set global XSLT parameter of the imported stylesheet
+     * @argument nsURI The parameter namespace URI
+     * @argument name The parameter base name
+     * @argument value The new parameter value
+     */
+    XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
+        // nsURI is optional but cannot be null 
+        if(nsURI){
+            this.processor.addParameter(name, value, nsURI);
+        }else{
+            this.processor.addParameter(name, value);
+        };
+        // update updated params for getParameter 
+        if(!this.paramsSet[&quot;&quot;+nsURI]){
+            this.paramsSet[&quot;&quot;+nsURI] = new Array();
+        };
+        this.paramsSet[&quot;&quot;+nsURI][name] = value;
+    };
+    /**
+     * Gets a parameter if previously set by setParameter. Returns null
+     * otherwise
+     * @argument name The parameter base name
+     * @argument value The new parameter value
+     * @return The parameter value if reviously set by setParameter, null otherwise
+     */
+    XSLTProcessor.prototype.getParameter = function(nsURI, name){
+        nsURI = nsURI || &quot;&quot;;
+        if(this.paramsSet[nsURI] &amp;&amp; this.paramsSet[nsURI][name]){
+            return this.paramsSet[nsURI][name];
+        }else{
+            return null;
+        };
+    };
+    /**
+     * Clear parameters (set them to default values as defined in the stylesheet itself)
+     */
+    XSLTProcessor.prototype.clearParameters = function(){
+        for(var nsURI in this.paramsSet){
+            for(var name in this.paramsSet[nsURI]){
+                if(nsURI){
+                    this.processor.addParameter(name, null, nsURI);
+                }else{
+                    this.processor.addParameter(name, null);
+                };
+            };
+        };
+        this.paramsSet = new Array();
+    };
+}else{ /* end IE initialization, try to deal with real browsers now ;-) */
+    if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
+        /**
+         * &lt;p&gt;Ensures the document was loaded correctly, otherwise sets the
+         * parseError to -1 to indicate something went wrong. Internal use&lt;/p&gt;
+         * @private
+         */
+        Sarissa.__handleLoad__ = function(oDoc){
+            Sarissa.__setReadyState__(oDoc, 4);
+        };
+        /**
+        * &lt;p&gt;Attached by an event handler to the load event. Internal use.&lt;/p&gt;
+        * @private
+        */
+        _sarissa_XMLDocument_onload = function(){
+            Sarissa.__handleLoad__(this);
+        };
+        /**
+         * &lt;p&gt;Sets the readyState property of the given DOM Document object.
+         * Internal use.&lt;/p&gt;
+         * @private
+         * @argument oDoc the DOM Document object to fire the
+         *          readystatechange event
+         * @argument iReadyState the number to change the readystate property to
+         */
+        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
+            oDoc.readyState = iReadyState;
+            oDoc.readystate = iReadyState;
+            if (oDoc.onreadystatechange != null &amp;&amp; typeof oDoc.onreadystatechange == &quot;function&quot;)
+                oDoc.onreadystatechange();
+        };
+        Sarissa.getDomDocument = function(sUri, sName){
+            var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+            if(!oDoc.onreadystatechange){
+            
+                /**
+                * &lt;p&gt;Emulate IE's onreadystatechange attribute&lt;/p&gt;
+                */
+                oDoc.onreadystatechange = null;
+            };
+            if(!oDoc.readyState){
+                /**
+                * &lt;p&gt;Emulates IE's readyState property, which always gives an integer from 0 to 4:&lt;/p&gt;
+                * &lt;ul&gt;&lt;li&gt;1 == LOADING,&lt;/li&gt;
+                * &lt;li&gt;2 == LOADED,&lt;/li&gt;
+                * &lt;li&gt;3 == INTERACTIVE,&lt;/li&gt;
+                * &lt;li&gt;4 == COMPLETED&lt;/li&gt;&lt;/ul&gt;
+                */
+                oDoc.readyState = 0;
+            };
+            oDoc.addEventListener(&quot;load&quot;, _sarissa_XMLDocument_onload, false);
+            return oDoc;
+        };
+        if(window.XMLDocument){
+            // do nothing
+        }// TODO: check if the new document has content before trying to copynodes, check  for error handling in DOM 3 LS
+        else if(_SARISSA_HAS_DOM_FEATURE &amp;&amp; window.Document &amp;&amp; !Document.prototype.load &amp;&amp; document.implementation.hasFeature('LS', '3.0')){
+            //Opera 9 may get the XPath branch which gives creates XMLDocument, therefore it doesn't reach here which is good
+            /**
+            * &lt;p&gt;Factory method to obtain a new DOM Document object&lt;/p&gt;
+            * @argument sUri the namespace of the root node (if any)
+            * @argument sUri the local name of the root node (if any)
+            * @returns a new DOM Document
+            */
+            Sarissa.getDomDocument = function(sUri, sName){
+                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+                return oDoc;
+            };
+        }
+        else {
+            Sarissa.getDomDocument = function(sUri, sName){
+                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+                // looks like safari does not create the root element for some unknown reason
+                if(oDoc &amp;&amp; (sUri || sName) &amp;&amp; !oDoc.documentElement){
+                    oDoc.appendChild(oDoc.createElementNS(sUri, sName));
+                };
+                return oDoc;
+            };
+        };
+    };//if(_SARISSA_HAS_DOM_CREATE_DOCUMENT)
 };
-/** openXMLHttpRequest(method, url, async, user, pass) : XMLHttpRequest */
-Freja._aux.openXMLHttpRequest = function(method, url, async, user, pass) {
-	var req = new XMLHttpRequest();
-	if (user &amp;&amp; pass) {
-		req.open(method, url, async, user, pass);
-	} else {
-		req.open(method, url, async);
-	}
-	if (method == &quot;POST&quot; || method == &quot;PUT&quot;) {
-		req.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
-	}
-	// RoR/cakePHP Ajax request detection compatibility:
-	req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');	
-	return req;
+//==========================================
+// Common stuff
+//==========================================
+if(!window.DOMParser){
+    if(_SARISSA_IS_SAFARI){
+        /*
+         * DOMParser is a utility class, used to construct DOMDocuments from XML strings
+         * @constructor
+         */
+        DOMParser = function() { };
+        /** 
+        * Construct a new DOM Document from the given XMLstring
+        * @param sXml the given XML string
+        * @param contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml). 
+        * @return a new DOM Document from the given XML string
+        */
+        DOMParser.prototype.parseFromString = function(sXml, contentType){
+            var xmlhttp = new XMLHttpRequest();
+            xmlhttp.open(&quot;GET&quot;, &quot;data:text/xml;charset=utf-8,&quot; + encodeURIComponent(sXml), false);
+            xmlhttp.send(null);
+            return xmlhttp.responseXML;
+        };
+    }else if(Sarissa.getDomDocument &amp;&amp; Sarissa.getDomDocument() &amp;&amp; Sarissa.getDomDocument(null, &quot;bar&quot;).xml){
+        DOMParser = function() { };
+        DOMParser.prototype.parseFromString = function(sXml, contentType){
+            var doc = Sarissa.getDomDocument();
+            doc.loadXML(sXml);
+            return doc;
+        };
+    };
 };
-/** sendXMLHttpRequest(req, sendContent) : Deferred */
-Freja._aux.sendXMLHttpRequest = MochiKit.Async.sendXMLHttpRequest;
-/** xmlize(anyObject, objectName) : string */
-Freja._aux.xmlize = Sarissa.xmlize;
-/** serializeXML(node) : string */
-Freja._aux.serializeXML = function(node) {
-	if (node.xml) return node.xml;
-	return (new XMLSerializer()).serializeToString(node);
+
+if((typeof(document.importNode) == &quot;undefined&quot;) &amp;&amp; _SARISSA_IS_IE){
+    try{
+        /**
+        * Implementation of importNode for the context window document in IE
+        * @param oNode the Node to import
+        * @param bChildren whether to include the children of oNode
+        * @returns the imported node for further use
+        */
+        document.importNode = function(oNode, bChildren){
+            var tmp;
+            if(oNode.nodeName == &quot;tbody&quot; || oNode.nodeName == &quot;tr&quot;){
+                tmp = document.createElement(&quot;table&quot;);
+            }
+            else if(oNode.nodeName == &quot;td&quot;){
+                tmp = document.createElement(&quot;tr&quot;);
+            }
+            else if(oNode.nodeName == &quot;option&quot;){
+                tmp = document.createElement(&quot;select&quot;);
+            }
+            else{
+                tmp = document.createElement(&quot;div&quot;);
+            };
+            if(bChildren){
+                tmp.innerHTML = oNode.xml ? oNode.xml : oNode.outerHTML;
+            }else{
+                tmp.innerHTML = oNode.xml ? oNode.cloneNode(false).xml : oNode.cloneNode(false).outerHTML;
+            };
+            return tmp.getElementsByTagName(&quot;*&quot;)[0];
+        };
+    }catch(e){ };
 };
-/** loadXML(string) : XMLDocument */
-Freja._aux.loadXML = function(text) {
-	return (new DOMParser()).parseFromString(text, &quot;text/xml&quot;);
+if(!Sarissa.getParseErrorText){
+    /**
+     * &lt;p&gt;Returns a human readable description of the parsing error. Usefull
+     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
+     * element if you want to render it.&lt;/p&gt;
+     * &lt;p&gt;Many thanks to Christian Stocker for the initial patch.&lt;/p&gt;
+     * @argument oDoc The target DOM document
+     * @returns The parsing error description of the target Document in
+     *          human readable form (preformated text)
+     */
+    Sarissa.getParseErrorText = function (oDoc){
+        var parseErrorText = Sarissa.PARSED_OK;
+        if(!oDoc.documentElement){
+            parseErrorText = Sarissa.PARSED_EMPTY;
+        } else if(oDoc.documentElement.tagName == &quot;parsererror&quot;){
+            parseErrorText = oDoc.documentElement.firstChild.data;
+            parseErrorText += &quot;\n&quot; +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
+        } else if(oDoc.getElementsByTagName(&quot;parsererror&quot;).length &gt; 0){
+            var parsererror = oDoc.getElementsByTagName(&quot;parsererror&quot;)[0];
+            parseErrorText = Sarissa.getText(parsererror, true)+&quot;\n&quot;;
+        } else if(oDoc.parseError &amp;&amp; oDoc.parseError.errorCode != 0){
+            parseErrorText = Sarissa.PARSED_UNKNOWN_ERROR;
+        };
+        return parseErrorText;
+    };
 };
-/** transformXSL(XMLDocument, XSLDocument) : string */
-Freja._aux.transformXSL = function(xml, xsl, xslParameters) {
-	var processor = new XSLTProcessor();
-	processor.importStylesheet(xsl);
-	if(xslParameters) {
-		for (var paramName in xslParameters) {
-			processor.setParameter(null, paramName, xslParameters[paramName]);
-		}
-	}
-	 
-	return processor.transformToFragment(xml, window.document);
+Sarissa.getText = function(oNode, deep){
+    var s = &quot;&quot;;
+    var nodes = oNode.childNodes;
+    for(var i=0; i &lt; nodes.length; i++){
+        var node = nodes[i];
+        var nodeType = node.nodeType;
+        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
+            s += node.data;
+        } else if(deep == true
+                    &amp;&amp; (nodeType == Node.ELEMENT_NODE
+                        || nodeType == Node.DOCUMENT_NODE
+                        || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
+            s += Sarissa.getText(node, true);
+        };
+    };
+    return s;
 };
-/** cloneXMLDocument(document) : XMLDocument */
-Freja._aux.cloneXMLDocument = function(xmlDoc) {
-	var clone = null;
-	try {
-		clone = xmlDoc.cloneNode(true);
-	} catch(e) { /* squelch */ }
-	
-	// Can't clone a DocumentNode in Safari &amp; Opera. Let's try something else.
-	// @note Wouldn't it be easier to serialize the document to string and the parse it to a new document ?
-	if (!clone) {
-		if (document.implementation &amp;&amp; document.implementation.createDocument) {
-			clone = document.implementation.createDocument(&quot;&quot;, xmlDoc.documentElement.nodeName, null);
-			// importNode is not safe in Safari ! the source document is altered. used cloneNode to fix the prblm
-			var data = clone.importNode(xmlDoc.documentElement.cloneNode(true), true);
-			try {
-				clone.appendChild(data);
-			} catch(e) {				
-				// Opera has already created a documentElement and can't append another root node
-				var rootNode = clone.documentElement;
-			
-				for (var i = data.childNodes.length-1; i &gt;= 0; i--) {
-					rootNode.insertBefore(data.childNodes[i], rootNode.firstChild);
-				}
-				
-				// need to copy root node attributes
-				for (var i = 0; i &lt; xmlDoc.documentElement.attributes.length; i++) {
-					var name  = xmlDoc.documentElement.attributes.item(i).name;
-					var value = xmlDoc.documentElement.attributes.item(i).value;
-					clone.documentElement.setAttribute(name, value);
-				}				
-			}
-		}
-	}
-	
-	return clone;
+if(!window.XMLSerializer 
+    &amp;&amp; Sarissa.getDomDocument 
+    &amp;&amp; Sarissa.getDomDocument(&quot;&quot;,&quot;foo&quot;, null).xml){
+    /**
+     * Utility class to serialize DOM Node objects to XML strings
+     * @constructor
+     */
+    XMLSerializer = function(){};
+    /**
+     * Serialize the given DOM Node to an XML string
+     * @param oNode the DOM Node to serialize
+     */
+    XMLSerializer.prototype.serializeToString = function(oNode) {
+        return oNode.xml;
+    };
 };
 
-/** hasSupportForXSLT() : boolean */
-Freja._aux.hasSupportForXSLT = function() { return (typeof(XSLTProcessor) != &quot;undefined&quot;); };
-/** createQueryEngine() : Freja.QueryEngine */
-Freja._aux.createQueryEngine = function() {
-	if (Sarissa.IS_ENABLED_SELECT_NODES) {
-		return new Freja.QueryEngine.XPath();
-	} else {
-		return new Freja.QueryEngine.SimplePath();
-	}
+/**
+ * strips tags from a markup string
+ */
+Sarissa.stripTags = function (s) {
+    return s.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;);
 };
+/**
+ * &lt;p&gt;Deletes all child nodes of the given node&lt;/p&gt;
+ * @argument oNode the Node to empty
+ */
+Sarissa.clearChildNodes = function(oNode) {
+    // need to check for firstChild due to opera 8 bug with hasChildNodes
+    while(oNode.firstChild) {
+        oNode.removeChild(oNode.firstChild);
+    };
+};
+/**
+ * &lt;p&gt; Copies the childNodes of nodeFrom to nodeTo&lt;/p&gt;
+ * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
+ * the copy operation, unless you supply a true third parameter&lt;/p&gt;
+ * @argument nodeFrom the Node to copy the childNodes from
+ * @argument nodeTo the Node to copy the childNodes to
+ * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is false
+ */
+Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
+    if((!nodeFrom) || (!nodeTo)){
+        throw &quot;Both source and destination nodes must be provided&quot;;
+    };
+    if(!bPreserveExisting){
+        Sarissa.clearChildNodes(nodeTo);
+    };
+    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
+    var nodes = nodeFrom.childNodes;
+    if(typeof(ownerDoc.importNode) != &quot;undefined&quot;)  {
+        for(var i=0;i &lt; nodes.length;i++) {
+            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
+        };
+    } else {
+        for(var i=0;i &lt; nodes.length;i++) {
+            nodeTo.appendChild(nodes[i].cloneNode(true));
+        };
+    };
+};
 
+/**
+ * &lt;p&gt; Moves the childNodes of nodeFrom to nodeTo&lt;/p&gt;
+ * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
+ * the move operation, unless you supply a true third parameter&lt;/p&gt;
+ * @argument nodeFrom the Node to copy the childNodes from
+ * @argument nodeTo the Node to copy the childNodes to
+ * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is
+ */ 
+Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
+    if((!nodeFrom) || (!nodeTo)){
+        throw &quot;Both source and destination nodes must be provided&quot;;
+    };
+    if(!bPreserveExisting){
+        Sarissa.clearChildNodes(nodeTo);
+    };
+    var nodes = nodeFrom.childNodes;
+    // if within the same doc, just move, else copy and delete
+    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
+        while(nodeFrom.firstChild){
+            nodeTo.appendChild(nodeFrom.firstChild);
+        };
+    } else {
+        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
+        if(typeof(ownerDoc.importNode) != &quot;undefined&quot;) {
+           for(var i=0;i &lt; nodes.length;i++) {
+               nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
+           };
+        }else{
+           for(var i=0;i &lt; nodes.length;i++) {
+               nodeTo.appendChild(nodes[i].cloneNode(true));
+           };
+        };
+        Sarissa.clearChildNodes(nodeFrom);
+    };
+};
 
+/** 
+ * &lt;p&gt;Serialize any object to an XML string. All properties are serialized using the property name
+ * as the XML element name. Array elements are rendered as &lt;code&gt;array-item&lt;/code&gt; elements, 
+ * using their index/key as the value of the &lt;code&gt;key&lt;/code&gt; attribute.&lt;/p&gt;
+ * @argument anyObject the object to serialize
+ * @argument objectName a name for that object
+ * @return the XML serializationj of the given object as a string
+ */
+Sarissa.xmlize = function(anyObject, objectName, indentSpace){
+    indentSpace = indentSpace?indentSpace:'';
+    var s = indentSpace  + '&lt;' + objectName + '&gt;';
+    var isLeaf = false;
+    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String 
+        || anyObject instanceof Boolean || anyObject instanceof Date){
+        s += Sarissa.escape(&quot;&quot;+anyObject);
+        isLeaf = true;
+    }else{
+        s += &quot;\n&quot;;
+        var itemKey = '';
+        var isArrayItem = anyObject instanceof Array;
+        for(var name in anyObject){
+            s += Sarissa.xmlize(anyObject[name], (isArrayItem?&quot;array-item key=\&quot;&quot;+name+&quot;\&quot;&quot;:name), indentSpace + &quot;   &quot;);
+        };
+        s += indentSpace;
+    };
+    return s += (objectName.indexOf(' ')!=-1?&quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot; + objectName + &quot;&gt;\n&quot;);
+};
+
+/** 
+ * Escape the given string chacters that correspond to the five predefined XML entities
+ * @param sXml the string to escape
+ */
+Sarissa.escape = function(sXml){
+    return sXml.replace(/&amp;/g, &quot;&amp;&quot;)
+        .replace(/&lt;/g, &quot;&lt;&quot;)
+        .replace(/&gt;/g, &quot;&gt;&quot;)
+        .replace(/&quot;/g, &quot;&quot;&quot;)
+        .replace(/'/g, &quot;&apos;&quot;);
+};
+
+/** 
+ * Unescape the given string. This turns the occurences of the predefined XML 
+ * entities to become the characters they represent correspond to the five predefined XML entities
+ * @param sXml the string to unescape
+ */
+Sarissa.unescape = function(sXml){
+    return sXml.replace(/&apos;/g,&quot;'&quot;)
+        .replace(/&quot;/g,&quot;\&quot;&quot;)
+        .replace(/&gt;/g,&quot;&gt;&quot;)
+        .replace(/&lt;/g,&quot;&lt;&quot;)
+        .replace(/&amp;/g,&quot;&amp;&quot;);
+};
+/*
+ * Sarissa's IE XPath Emulation 
+ */
 /**
  * ====================================================================
  * About
@@ -396,6 +906,294 @@
 if(_SARISSA_IS_IE)
 	 Sarissa.IS_ENABLED_SELECT_NODES = true;
 
+
+/**
+  * Freja._aux
+  * wrapper for external dependencies (frameworks).
+  *
+  * This is the minimal auxiliary adapter. It contains self-sufficient
+  * implementations of all dependencies.
+  * 
+  */
+if (typeof(Freja) == &quot;undefined&quot;) {
+	Freja = {};
+}
+Freja._aux = {};
+/** bind(func, self) : function */
+// from <A HREF="http://blog.ianbicking.org/prototype-and-object-prototype.html">http://blog.ianbicking.org/prototype-and-object-prototype.html</A>
+Freja._aux.bind = function(func, self) {
+	if(typeof (func)==&quot;string&quot;){
+		func=self[func];
+	}
+
+	var im_func = null;
+    if (typeof(func.im_func) == 'function') {
+        im_func = func.im_func;
+    } else {
+        im_func = func;
+    }
+    func = function () {
+        return func.im_func.apply(func.im_self, arguments);
+    }
+    func.im_func = im_func;
+    func.im_self = self;
+	return func;
+};
+/** formContents(elem) : Array */
+Freja._aux.formContents = function(elem) {
+	if (!elem) elem = document;
+	var names = [];
+	var values = [];
+	var inputs = elem.getElementsByTagName(&quot;INPUT&quot;);
+	for (var i = 0; i &lt; inputs.length; ++i) {
+		var input = inputs[i];
+		if (input.name) {
+			if (input.type == &quot;radio&quot; || input.type == &quot;checkbox&quot;) {
+				if (input.checked) {
+					names.push(input.name);
+					values.push(input.value);
+				} else {
+					names.push(input.name);
+					values.push(&quot;&quot;);
+				}
+			} else {
+				names.push(input.name);
+				values.push(input.value);
+			}
+		}
+	}
+	var textareas = elem.getElementsByTagName(&quot;TEXTAREA&quot;);
+	for (var i = 0; i &lt; textareas.length; ++i) {
+		var input = textareas[i];
+		if (input.name) {
+			names.push(input.name);
+			values.push(input.value);
+		}
+	}
+	var selects = elem.getElementsByTagName(&quot;SELECT&quot;);
+	for (var i = 0; i &lt; selects.length; ++i) {
+		var input = selects[i];
+		if (input.name) {
+			if (input.selectedIndex &gt;= 0) {
+				var opt = input.options[input.selectedIndex];
+				names.push(input.name);
+				values.push((opt.value) ? opt.value : &quot;&quot;);
+			}
+		}
+	}
+	return [names, values];
+};
+/** getElement(id) : HTMLElement */
+Freja._aux.getElement = function(id) {
+	if (typeof(id) == &quot;object&quot;) {
+		return id;
+	} else {
+		return document.getElementById(id);
+	}
+};
+
+/** connect(src, signal, fnc) : void */
+Freja._aux.connect = function(src, signal, fnc) {
+
+	if(!src) return;
+	if (src.addEventListener) {
+		var wrapper = function(e) {
+			var evt = {
+				stop : function() {
+					if (e.cancelable) {
+						e.preventDefault();
+					}
+					e.stopPropagation();
+				}
+			}
+			fnc(evt);
+		}
+		src.addEventListener(signal.replace(/^(on)/, &quot;&quot;), wrapper, false);
+	} else if (src.attachEvent) {
+		var wrapper = function() {
+			var e = window.event;
+			var evt = {
+				stop : function() {
+					e.cancelBubble = true;
+					e.returnValue = false;
+				}
+			}
+			fnc(evt);
+		}
+		src.attachEvent(signal, wrapper);
+	}
+	if (!src._signals) {
+		src._signals = [];
+	}
+	if (!src._signals[signal]) {
+		src._signals[signal] = [];
+	}
+	// checks if the callback has already been registered with the same function  (Thx to Chris D)
+	for(var item=0; item &lt; src._signals[signal].length;item++) {
+        if(src._signals[signal][item].toString() == fnc.toString()) return;
+    } 
+    
+	src._signals[signal].push(fnc);
+};
+/** signal(src, signal, ...) : void */
+Freja._aux.signal = function(src, signal) {
+
+	try {
+		var sigs = src._signals[signal];
+		var args = [];
+		for (var i=2; i &lt; arguments.length; i++) {
+			args.push(arguments[i]);
+		}
+		for (var i=0; i &lt; sigs.length; i++) {
+			try {
+				sigs[i].apply(src, args);
+			} catch (e) { /* squelch */ }
+		}
+	} catch (e) { /* squelch */ }
+};
+/** createDeferred() : Deferred */
+Freja._aux.createDeferred = function() {
+	return new Freja._aux.Deferred();
+};
+/** openXMLHttpRequest(method, url, async, user, pass) : XMLHttpRequest */
+Freja._aux.openXMLHttpRequest = function(method, url, async, user, pass) {
+	var req = new XMLHttpRequest();
+	if (user &amp;&amp; pass) {
+		req.open(method, url, async, user, pass);
+	} else {
+		req.open(method, url, async);
+	}
+	if (method == &quot;POST&quot; || method == &quot;PUT&quot;) {
+		req.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
+	}
+	// RoR/cakePHP Ajax request detection compatibility:
+	req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');	
+	return req;
+};
+/** sendXMLHttpRequest(req, sendContent) : Deferred */
+Freja._aux.sendXMLHttpRequest = function(req, sendContent) {
+	var d = Freja._aux.createDeferred();
+	var bComplete = false;
+	req.onreadystatechange = function() {
+		if (req.readyState == 4 &amp;&amp; !bComplete) {
+			if (req.status == 0 || req.status == 200 || req.status == 201 || req.status == 304) {
+				d.callback(req);
+			} else {
+				d.errback(req);
+			}
+			bComplete = true;
+		}
+	}
+	if (!sendContent) sendContent = &quot;&quot;;
+	req.send(sendContent);
+	return d;
+};
+/** xmlize(anyObject, objectName) : string */
+Freja._aux.xmlize = Sarissa.xmlize;
+
+/** serializeXML(node) : string */
+Freja._aux.serializeXML = function(node) {
+	if (node.xml) return node.xml;
+	return (new XMLSerializer()).serializeToString(node);
+};
+/** loadXML(string) : XMLDocument */
+Freja._aux.loadXML = function(text) {
+	return (new DOMParser()).parseFromString(text, &quot;text/xml&quot;);
+};
+/** transformXSL(XMLDocument, XSLDocument) : string */
+Freja._aux.transformXSL = function(xml, xsl, xslParameters) {
+	var processor = new XSLTProcessor();
+	processor.importStylesheet(xsl);
+	if(xslParameters) {
+		for (var paramName in xslParameters) {
+			processor.setParameter(&quot;&quot;, paramName, xslParameters[paramName]);
+		}
+	}
+	 
+	return processor.transformToFragment(xml, window.document);
+};
+/** cloneXMLDocument(document) : XMLDocument */
+Freja._aux.cloneXMLDocument = function(xmlDoc) {
+	var clone = null;
+	try {
+		clone = xmlDoc.cloneNode(true);
+	} catch(e) { /* squelch */ }
+
+	// Can't clone a DocumentNode in Safari &amp; Opera. Let's try something else.
+	// @note Wouldn't it be easier to serialize the document to string and the parse it to a new document ?
+	if (!clone) {
+		if (document.implementation &amp;&amp; document.implementation.createDocument) {
+			clone = document.implementation.createDocument(&quot;&quot;, xmlDoc.documentElement.nodeName, null);
+			// importNode is not safe in Safari ! the source document is altered. used cloneNode to fix the prblm
+			var data = clone.importNode(xmlDoc.documentElement.cloneNode(true), true);
+			try {
+				clone.appendChild(data);
+			} catch(e) {
+				// Opera has already created a documentElement and can't append another root node
+				var rootNode = clone.documentElement;
+				for (var i = data.childNodes.length; i &gt;= 0; i--) {
+					rootNode.insertBefore(data.childNodes[i], rootNode.firstChild);
+				}
+				// need to copy root node attributes
+				for (var i = 0; i &lt; xmlDoc.documentElement.attributes.length; i++) {
+					var name  = xmlDoc.documentElement.attributes.item(i).name;
+					var value = xmlDoc.documentElement.attributes.item(i).value;
+					clone.documentElement.setAttribute(name, value);
+				}
+			}
+		}
+	}
+	return clone;
+};
+/** hasSupportForXSLT() : boolean */
+Freja._aux.hasSupportForXSLT = function() { return (typeof(XSLTProcessor) != &quot;undefined&quot;); };
+/** createQueryEngine() : Freja.QueryEngine */
+Freja._aux.createQueryEngine = function() {
+	if (Sarissa.IS_ENABLED_SELECT_NODES) {
+		return new Freja.QueryEngine.XPath();
+	} else {
+		return new Freja.QueryEngine.SimplePath();
+	}
+};
+/** A pale replacement for MochiKit.Async.Deferred */
+Freja._aux.Deferred = function() {
+	this._good = [];
+	this._bad = [];
+	this._pending = null;
+};
+Freja._aux.Deferred.prototype.callback = function() {
+	if (this._good.length == 0) {
+		this._pending = [this.callback, arguments];
+		return;
+	}
+	for (var i=0; i &lt; this._good.length; i++) {
+		this._good[i].apply(window, arguments);
+	}
+	this._good = [];
+};
+Freja._aux.Deferred.prototype.errback = function() {
+	if (this._bad.length == 0) {
+		this._pending = [this.errback, arguments];
+		return;
+	}
+	for (var i=0; i &lt; this._bad.length; i++) {
+		this._bad[i].apply(window, arguments);
+	}
+	this._bad = [];
+};
+Freja._aux.Deferred.prototype.addCallbacks = function(fncOK, fncError) {
+	if (fncOK) this._good[this._good.length] = fncOK;
+	if (fncError) this._bad[this._bad.length] = fncError;
+	if (this._pending) {
+		this._pending[0].apply(this, this._pending[1]);
+	}
+};
+Freja._aux.Deferred.prototype.addCallback = function(fncOK) {
+	this.addCallbacks(fncOK);
+};
+Freja._aux.Deferred.prototype.addErrback = function(fncError) {
+	this.addCallbacks(null, fncError);
+};
 
 /**
   * The baseclass for queryengines
@@ -463,7 +1261,8 @@
 			if(node.firstChild &amp;&amp; (node.firstChild.nodeType == 3 || node.firstChild.nodeType == 4)) {
 				node.firstChild.nodeValue = value;
 			} else {
-				node.appendChild(document.createTextNode(value));
+				if(value!=&quot;&quot;) // prevent a subsequent IE7/MSXML3 crash in view rendering.
+					node.appendChild(document.createTextNode(value));
 			}
 			break;
 		case 2: /* Attribute */
@@ -603,7 +1402,7 @@
 };
 /**
   * Writes the model back to the remote service
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.Model.prototype.save = function() {
 	var url = this.url;
@@ -626,7 +1425,7 @@
 };
 /**
   * Deletes the model from the remote service
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.Model.prototype.remove = function() {
 	var url = this.url;
@@ -638,7 +1437,7 @@
 	return Freja._aux.sendXMLHttpRequest(req);
 };
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.Model.prototype.reload = function() {
 	this.ready = false;
@@ -699,7 +1498,7 @@
   * @param    model            Freja.Model
   * @param    placeholder      string    If supplied, this will be used instead of the
   *                                      default placeholder.
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.View.prototype.render = function(model, placeholder, xslParameters) {
 	if (typeof(placeholder) == &quot;undefined&quot;) placeholder = this.placeholder;
@@ -753,7 +1552,11 @@
 
 	var d = Freja._aux.createDeferred();
 	try {
-		this._destination = Freja._aux.getElement(placeholder);
+		if (typeof(placeholder) == &quot;object&quot;) {
+			this._destination = placeholder;
+		} else {
+			this._destination = document.getElementById(placeholder);
+		}
 		// @todo    Is this a good idea ?
 		// Perhaps we should leave it to the programmer to do this.
 		this._destination.innerHTML = Freja.AssetManager.THROBBER_HTML;
@@ -841,7 +1644,7 @@
 Freja.View.Renderer.XSLTransformer = function() {};
 Freja.Class.extend(Freja.View.Renderer.XSLTransformer, Freja.View.Renderer);
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.View.Renderer.XSLTransformer.prototype.transform = function(model, view, xslParameters) {
         var d = Freja._aux.createDeferred();
@@ -866,7 +1669,7 @@
 };
 Freja.Class.extend(Freja.View.Renderer.RemoteXSLTransformer, Freja.View.Renderer);
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.View.Renderer.RemoteXSLTransformer.prototype.transform = function(model, view, xslParameters) {
         var d = Freja._aux.createDeferred();
@@ -1007,8 +1810,8 @@
   * Both IE6 and FF1.5 are known to support the required HTTP methods, so
   * if theese are your target platform, you can disable tunneling.
   */
-// Freja.AssetManager.HTTP_METHOD_TUNNEL = null;
-Freja.AssetManager.HTTP_METHOD_TUNNEL = &quot;Http-Method-Equivalent&quot;;
+//  Freja.AssetManager.HTTP_METHOD_TUNNEL = null;
+  Freja.AssetManager.HTTP_METHOD_TUNNEL = &quot;Http-Method-Equivalent&quot;;
 /**
   * Set this url to provide remote xslt-transformation for browsers that
   * doesn't support it natively.
@@ -1100,7 +1903,7 @@
 	this._password = password;
 };
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.AssetManager.loadAsset = function(url, preventCaching) {
 	var match = /^(file:\/\/.*\/)([^\/]*)$/.exec(window.location.href);

Added: branch/2.0.1/lib/Freja_pack.js
===================================================================
--- branch/2.0.1/lib/Freja_pack.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/lib/Freja_pack.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -0,0 +1,1385 @@
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;Freja&quot;);
+}
+if(typeof (Freja)==&quot;undefined&quot;){
+Freja={};
+}
+Freja.NAME=&quot;Freja&quot;;
+Freja.VERSION=&quot;2.0.1&quot;;
+Freja.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
+};
+Freja.toString=function(){
+return this.__repr__();
+};
+Freja.Class={};
+Freja.Class.extend=function(_1,_2){
+var _3=function(){
+};
+_3.prototype=_2.prototype;
+_1.prototype=new _3();
+_1.prototype.constructor=_1;
+_1.prototype.superconstructor=_2;
+_1.prototype.supertype=_2.prototype;
+};
+function Sarissa(){
+}
+Sarissa.PARSED_OK=&quot;Document contains no parsing errors&quot;;
+Sarissa.PARSED_EMPTY=&quot;Document is empty&quot;;
+Sarissa.PARSED_UNKNOWN_ERROR=&quot;Not well-formed or other error&quot;;
+var _sarissa_iNsCounter=0;
+var _SARISSA_IEPREFIX4XSLPARAM=&quot;&quot;;
+var _SARISSA_HAS_DOM_IMPLEMENTATION=document.implementation&amp;&true;
+var _SARISSA_HAS_DOM_CREATE_DOCUMENT=_SARISSA_HAS_DOM_IMPLEMENTATION&amp;&amp;document.implementation.createDocument;
+var _SARISSA_HAS_DOM_FEATURE=_SARISSA_HAS_DOM_IMPLEMENTATION&amp;&amp;document.implementation.hasFeature;
+var _SARISSA_IS_MOZ=_SARISSA_HAS_DOM_CREATE_DOCUMENT&amp;&amp;_SARISSA_HAS_DOM_FEATURE;
+var _SARISSA_IS_SAFARI=(navigator.userAgent&amp;&amp;navigator.vendor&amp;&amp;(navigator.userAgent.toLowerCase().indexOf(&quot;applewebkit&quot;)!=-1||navigator.vendor.indexOf(&quot;Apple&quot;)!=-1));
+var _SARISSA_IS_IE=document.all&amp;&amp;window.ActiveXObject&amp;&amp;navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;)&gt;-1&amp;&amp;navigator.userAgent.toLowerCase().indexOf(&quot;opera&quot;)==-1;
+if(!window.Node||!Node.ELEMENT_NODE){
+Node={ELEMENT_NODE:1,ATTRIBUTE_NODE:2,TEXT_NODE:3,CDATA_SECTION_NODE:4,ENTITY_REFERENCE_NODE:5,ENTITY_NODE:6,PROCESSING_INSTRUCTION_NODE:7,COMMENT_NODE:8,DOCUMENT_NODE:9,DOCUMENT_TYPE_NODE:10,DOCUMENT_FRAGMENT_NODE:11,NOTATION_NODE:12};
+}
+if(typeof XMLDocument==&quot;undefined&quot;&amp;&amp;typeof Document!=&quot;undefined&quot;){
+XMLDocument=Document;
+}
+if(_SARISSA_IS_IE){
+_SARISSA_IEPREFIX4XSLPARAM=&quot;xsl:&quot;;
+var _SARISSA_DOM_PROGID=&quot;&quot;;
+var _SARISSA_XMLHTTP_PROGID=&quot;&quot;;
+var _SARISSA_DOM_XMLWRITER=&quot;&quot;;
+Sarissa.pickRecentProgID=function(_4){
+var _5=false;
+for(var i=0;i&lt;_4.length&amp;&amp;!_5;i++){
+try{
+var _7=new ActiveXObject(_4[i]);
+o2Store=_4[i];
+_5=true;
+}
+catch(objException){
+}
+}
+if(!_5){
+throw &quot;Could not retreive a valid progID of Class: &quot;+_4[_4.length-1]+&quot;. (original exception: &quot;+e+&quot;)&quot;;
+}
+_4=null;
+return o2Store;
+};
+_SARISSA_DOM_PROGID=null;
+_SARISSA_THREADEDDOM_PROGID=null;
+_SARISSA_XSLTEMPLATE_PROGID=null;
+_SARISSA_XMLHTTP_PROGID=null;
+if(!window.XMLHttpRequest){
+XMLHttpRequest=function(){
+if(!_SARISSA_XMLHTTP_PROGID){
+_SARISSA_XMLHTTP_PROGID=Sarissa.pickRecentProgID([&quot;Msxml2.XMLHTTP.6.0&quot;,&quot;MSXML2.XMLHTTP.3.0&quot;,&quot;MSXML2.XMLHTTP&quot;,&quot;Microsoft.XMLHTTP&quot;]);
+}
+return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
+};
+}
+Sarissa.getDomDocument=function(_8,_9){
+if(!_SARISSA_DOM_PROGID){
+_SARISSA_DOM_PROGID=Sarissa.pickRecentProgID([&quot;Msxml2.DOMDocument.6.0&quot;,&quot;Msxml2.DOMDocument.3.0&quot;,&quot;MSXML2.DOMDocument&quot;,&quot;MSXML.DOMDocument&quot;,&quot;Microsoft.XMLDOM&quot;]);
+}
+var _a=new ActiveXObject(_SARISSA_DOM_PROGID);
+if(_9){
+var _b=&quot;&quot;;
+if(_8){
+if(_9.indexOf(&quot;:&quot;)&gt;1){
+_b=_9.substring(0,_9.indexOf(&quot;:&quot;));
+_9=_9.substring(_9.indexOf(&quot;:&quot;)+1);
+}else{
+_b=&quot;a&quot;+(_sarissa_iNsCounter++);
+}
+}
+if(_8){
+_a.loadXML(&quot;&lt;&quot;+_b+&quot;:&quot;+_9+&quot; xmlns:&quot;+_b+&quot;=\&quot;&quot;+_8+&quot;\&quot;&quot;+&quot; /&gt;&quot;);
+}else{
+_a.loadXML(&quot;&lt;&quot;+_9+&quot; /&gt;&quot;);
+}
+}
+return _a;
+};
+Sarissa.getParseErrorText=function(_c){
+var _d=Sarissa.PARSED_OK;
+if(_c.parseError.errorCode!=0){
+_d=&quot;XML Parsing Error: &quot;+_c.parseError.reason+&quot;\nLocation: &quot;+_c.parseError.url+&quot;\nLine Number &quot;+_c.parseError.line+&quot;, Column &quot;+_c.parseError.linepos+&quot;:\n&quot;+_c.parseError.srcText+&quot;\n&quot;;
+for(var i=0;i&lt;_c.parseError.linepos;i++){
+_d+=&quot;-&quot;;
+}
+_d+=&quot;^\n&quot;;
+}else{
+if(_c.documentElement==null){
+_d=Sarissa.PARSED_EMPTY;
+}
+}
+return _d;
+};
+Sarissa.setXpathNamespaces=function(_f,_10){
+_f.setProperty(&quot;SelectionLanguage&quot;,&quot;XPath&quot;);
+_f.setProperty(&quot;SelectionNamespaces&quot;,_10);
+};
+XSLTProcessor=function(){
+if(!_SARISSA_XSLTEMPLATE_PROGID){
+_SARISSA_XSLTEMPLATE_PROGID=Sarissa.pickRecentProgID([&quot;Msxml2.XSLTemplate.6.0&quot;,&quot;MSXML2.XSLTemplate.3.0&quot;]);
+}
+this.template=new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
+this.processor=null;
+};
+XSLTProcessor.prototype.importStylesheet=function(_11){
+if(!_SARISSA_THREADEDDOM_PROGID){
+_SARISSA_THREADEDDOM_PROGID=Sarissa.pickRecentProgID([&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;,&quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
+}
+_11.setProperty(&quot;SelectionLanguage&quot;,&quot;XPath&quot;);
+_11.setProperty(&quot;SelectionNamespaces&quot;,&quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+var _12=new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
+if(_11.url&amp;&amp;_11.selectSingleNode(&quot;//xsl:*[local-name() = 'import' or local-name() = 'include']&quot;)!=null){
+_12.async=false;
+if(_SARISSA_THREADEDDOM_PROGID==&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;){
+_12.setProperty(&quot;AllowDocumentFunction&quot;,true);
+_12.resolveExternals=true;
+}
+_12.load(_11.url);
+}else{
+_12.loadXML(_11.xml);
+}
+_12.setProperty(&quot;SelectionNamespaces&quot;,&quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+var _13=_12.selectSingleNode(&quot;//xsl:output&quot;);
+this.outputMethod=_13?_13.getAttribute(&quot;method&quot;):&quot;html&quot;;
+this.template.stylesheet=_12;
+this.processor=this.template.createProcessor();
+this.paramsSet=new Array();
+};
+XSLTProcessor.prototype.transformToDocument=function(_14){
+if(_SARISSA_THREADEDDOM_PROGID){
+this.processor.input=_14;
+var _15=new ActiveXObject(_SARISSA_DOM_PROGID);
+this.processor.output=_15;
+this.processor.transform();
+return _15;
+}else{
+if(!_SARISSA_DOM_XMLWRITER){
+_SARISSA_DOM_XMLWRITER=Sarissa.pickRecentProgID([&quot;Msxml2.MXXMLWriter.6.0&quot;,&quot;Msxml2.MXXMLWriter.3.0&quot;,&quot;MSXML2.MXXMLWriter&quot;,&quot;MSXML.MXXMLWriter&quot;,&quot;Microsoft.XMLDOM&quot;]);
+}
+this.processor.input=_14;
+var _15=new ActiveXObject(_SARISSA_DOM_XMLWRITER);
+this.processor.output=_15;
+this.processor.transform();
+var _16=new ActiveXObject(_SARISSA_DOM_PROGID);
+_16.loadXML(_15.output+&quot;&quot;);
+return _16;
+}
+};
+XSLTProcessor.prototype.transformToFragment=function(_17,_18){
+this.processor.input=_17;
+this.processor.transform();
+var s=this.processor.output;
+var f=_18.createDocumentFragment();
+if(this.outputMethod==&quot;text&quot;){
+f.appendChild(_18.createTextNode(s));
+}else{
+if(_18.body&amp;&amp;_18.body.innerHTML){
+var _1b=_18.createElement(&quot;div&quot;);
+_1b.innerHTML=s;
+while(_1b.hasChildNodes()){
+f.appendChild(_1b.firstChild);
+}
+}else{
+var _1c=new ActiveXObject(_SARISSA_DOM_PROGID);
+if(s.substring(0,5)==&quot;&lt;?xml&quot;){
+s=s.substring(s.indexOf(&quot;?&gt;&quot;)+2);
+}
+var xml=&quot;&quot;.concat(&quot;&lt;my&gt;&quot;,s,&quot;&lt;/my&gt;&quot;);
+_1c.loadXML(xml);
+var _1b=_1c.documentElement;
+while(_1b.hasChildNodes()){
+f.appendChild(_1b.firstChild);
+}
+}
+}
+return f;
+};
+XSLTProcessor.prototype.setParameter=function(_1e,_1f,_20){
+if(_1e){
+this.processor.addParameter(_1f,_20,_1e);
+}else{
+this.processor.addParameter(_1f,_20);
+}
+if(!this.paramsSet[&quot;&quot;+_1e]){
+this.paramsSet[&quot;&quot;+_1e]=new Array();
+}
+this.paramsSet[&quot;&quot;+_1e][_1f]=_20;
+};
+XSLTProcessor.prototype.getParameter=function(_21,_22){
+_21=_21||&quot;&quot;;
+if(this.paramsSet[_21]&amp;&amp;this.paramsSet[_21][_22]){
+return this.paramsSet[_21][_22];
+}else{
+return null;
+}
+};
+XSLTProcessor.prototype.clearParameters=function(){
+for(var _23 in this.paramsSet){
+for(var _24 in this.paramsSet[_23]){
+if(_23){
+this.processor.addParameter(_24,null,_23);
+}else{
+this.processor.addParameter(_24,null);
+}
+}
+}
+this.paramsSet=new Array();
+};
+}else{
+if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
+Sarissa.__handleLoad__=function(_25){
+Sarissa.__setReadyState__(_25,4);
+};
+_sarissa_XMLDocument_onload=function(){
+Sarissa.__handleLoad__(this);
+};
+Sarissa.__setReadyState__=function(_26,_27){
+_26.readyState=_27;
+_26.readystate=_27;
+if(_26.onreadystatechange!=null&amp;&amp;typeof _26.onreadystatechange==&quot;function&quot;){
+_26.onreadystatechange();
+}
+};
+Sarissa.getDomDocument=function(_28,_29){
+var _2a=document.implementation.createDocument(_28?_28:null,_29?_29:null,null);
+if(!_2a.onreadystatechange){
+_2a.onreadystatechange=null;
+}
+if(!_2a.readyState){
+_2a.readyState=0;
+}
+_2a.addEventListener(&quot;load&quot;,_sarissa_XMLDocument_onload,false);
+return _2a;
+};
+if(window.XMLDocument){
+}else{
+if(_SARISSA_HAS_DOM_FEATURE&amp;&amp;window.Document&amp;&amp;!Document.prototype.load&amp;&amp;document.implementation.hasFeature(&quot;LS&quot;,&quot;3.0&quot;)){
+Sarissa.getDomDocument=function(_2b,_2c){
+var _2d=document.implementation.createDocument(_2b?_2b:null,_2c?_2c:null,null);
+return _2d;
+};
+}else{
+Sarissa.getDomDocument=function(_2e,_2f){
+var _30=document.implementation.createDocument(_2e?_2e:null,_2f?_2f:null,null);
+if(_30&amp;&amp;(_2e||_2f)&amp;&amp;!_30.documentElement){
+_30.appendChild(_30.createElementNS(_2e,_2f));
+}
+return _30;
+};
+}
+}
+}
+}
+if(!window.DOMParser){
+if(_SARISSA_IS_SAFARI){
+DOMParser=function(){
+};
+DOMParser.prototype.parseFromString=function(_31,_32){
+var _33=new XMLHttpRequest();
+_33.open(&quot;GET&quot;,&quot;data:text/xml;charset=utf-8,&quot;+encodeURIComponent(_31),false);
+_33.send(null);
+return _33.responseXML;
+};
+}else{
+if(Sarissa.getDomDocument&amp;&amp;Sarissa.getDomDocument()&amp;&amp;Sarissa.getDomDocument(null,&quot;bar&quot;).xml){
+DOMParser=function(){
+};
+DOMParser.prototype.parseFromString=function(_34,_35){
+var doc=Sarissa.getDomDocument();
+doc.loadXML(_34);
+return doc;
+};
+}
+}
+}
+if((typeof (document.importNode)==&quot;undefined&quot;)&amp;&amp;_SARISSA_IS_IE){
+try{
+document.importNode=function(_37,_38){
+var tmp;
+if(_37.nodeName==&quot;tbody&quot;||_37.nodeName==&quot;tr&quot;){
+tmp=document.createElement(&quot;table&quot;);
+}else{
+if(_37.nodeName==&quot;td&quot;){
+tmp=document.createElement(&quot;tr&quot;);
+}else{
+if(_37.nodeName==&quot;option&quot;){
+tmp=document.createElement(&quot;select&quot;);
+}else{
+tmp=document.createElement(&quot;div&quot;);
+}
+}
+}
+if(_38){
+tmp.innerHTML=_37.xml?_37.xml:_37.outerHTML;
+}else{
+tmp.innerHTML=_37.xml?_37.cloneNode(false).xml:_37.cloneNode(false).outerHTML;
+}
+return tmp.getElementsByTagName(&quot;*&quot;)[0];
+};
+}
+catch(e){
+}
+}
+if(!Sarissa.getParseErrorText){
+Sarissa.getParseErrorText=function(_3a){
+var _3b=Sarissa.PARSED_OK;
+if(!_3a.documentElement){
+_3b=Sarissa.PARSED_EMPTY;
+}else{
+if(_3a.documentElement.tagName==&quot;parsererror&quot;){
+_3b=_3a.documentElement.firstChild.data;
+_3b+=&quot;\n&quot;+_3a.documentElement.firstChild.nextSibling.firstChild.data;
+}else{
+if(_3a.getElementsByTagName(&quot;parsererror&quot;).length&gt;0){
+var _3c=_3a.getElementsByTagName(&quot;parsererror&quot;)[0];
+_3b=Sarissa.getText(_3c,true)+&quot;\n&quot;;
+}else{
+if(_3a.parseError&amp;&amp;_3a.parseError.errorCode!=0){
+_3b=Sarissa.PARSED_UNKNOWN_ERROR;
+}
+}
+}
+}
+return _3b;
+};
+}
+Sarissa.getText=function(_3d,_3e){
+var s=&quot;&quot;;
+var _40=_3d.childNodes;
+for(var i=0;i&lt;_40.length;i++){
+var _42=_40[i];
+var _43=_42.nodeType;
+if(_43==Node.TEXT_NODE||_43==Node.CDATA_SECTION_NODE){
+s+=_42.data;
+}else{
+if(_3e==true&amp;&amp;(_43==Node.ELEMENT_NODE||_43==Node.DOCUMENT_NODE||_43==Node.DOCUMENT_FRAGMENT_NODE)){
+s+=Sarissa.getText(_42,true);
+}
+}
+}
+return s;
+};
+if(!window.XMLSerializer&amp;&amp;Sarissa.getDomDocument&amp;&amp;Sarissa.getDomDocument(&quot;&quot;,&quot;foo&quot;,null).xml){
+XMLSerializer=function(){
+};
+XMLSerializer.prototype.serializeToString=function(_44){
+return _44.xml;
+};
+}
+Sarissa.stripTags=function(s){
+return s.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;);
+};
+Sarissa.clearChildNodes=function(_46){
+while(_46.firstChild){
+_46.removeChild(_46.firstChild);
+}
+};
+Sarissa.copyChildNodes=function(_47,_48,_49){
+if((!_47)||(!_48)){
+throw &quot;Both source and destination nodes must be provided&quot;;
+}
+if(!_49){
+Sarissa.clearChildNodes(_48);
+}
+var _4a=_48.nodeType==Node.DOCUMENT_NODE?_48:_48.ownerDocument;
+var _4b=_47.childNodes;
+if(typeof (_4a.importNode)!=&quot;undefined&quot;){
+for(var i=0;i&lt;_4b.length;i++){
+_48.appendChild(_4a.importNode(_4b[i],true));
+}
+}else{
+for(var i=0;i&lt;_4b.length;i++){
+_48.appendChild(_4b[i].cloneNode(true));
+}
+}
+};
+Sarissa.moveChildNodes=function(_4d,_4e,_4f){
+if((!_4d)||(!_4e)){
+throw &quot;Both source and destination nodes must be provided&quot;;
+}
+if(!_4f){
+Sarissa.clearChildNodes(_4e);
+}
+var _50=_4d.childNodes;
+if(_4d.ownerDocument==_4e.ownerDocument){
+while(_4d.firstChild){
+_4e.appendChild(_4d.firstChild);
+}
+}else{
+var _51=_4e.nodeType==Node.DOCUMENT_NODE?_4e:_4e.ownerDocument;
+if(typeof (_51.importNode)!=&quot;undefined&quot;){
+for(var i=0;i&lt;_50.length;i++){
+_4e.appendChild(_51.importNode(_50[i],true));
+}
+}else{
+for(var i=0;i&lt;_50.length;i++){
+_4e.appendChild(_50[i].cloneNode(true));
+}
+}
+Sarissa.clearChildNodes(_4d);
+}
+};
+Sarissa.xmlize=function(_53,_54,_55){
+_55=_55?_55:&quot;&quot;;
+var s=_55+&quot;&lt;&quot;+_54+&quot;&gt;&quot;;
+var _57=false;
+if(!(_53 instanceof Object)||_53 instanceof Number||_53 instanceof String||_53 instanceof Boolean||_53 instanceof Date){
+s+=Sarissa.escape(&quot;&quot;+_53);
+_57=true;
+}else{
+s+=&quot;\n&quot;;
+var _58=&quot;&quot;;
+var _59=_53 instanceof Array;
+for(var _5a in _53){
+s+=Sarissa.xmlize(_53[_5a],(_59?&quot;array-item key=\&quot;&quot;+_5a+&quot;\&quot;&quot;:_5a),_55+&quot;   &quot;);
+}
+s+=_55;
+}
+return s+=(_54.indexOf(&quot; &quot;)!=-1?&quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot;+_54+&quot;&gt;\n&quot;);
+};
+Sarissa.escape=function(_5b){
+return _5b.replace(/&amp;/g,&quot;&amp;&quot;).replace(/&lt;/g,&quot;&lt;&quot;).replace(/&gt;/g,&quot;&gt;&quot;).replace(/&quot;/g,&quot;&quot;&quot;).replace(/'/g,&quot;&apos;&quot;);
+};
+Sarissa.unescape=function(_5c){
+return _5c.replace(/&apos;/g,&quot;'&quot;).replace(/&quot;/g,&quot;\&quot;&quot;).replace(/&gt;/g,&quot;&gt;&quot;).replace(/&lt;/g,&quot;&lt;&quot;).replace(/&amp;/g,&quot;&amp;&quot;);
+};
+if(_SARISSA_HAS_DOM_FEATURE&amp;&amp;document.implementation.hasFeature(&quot;XPath&quot;,&quot;3.0&quot;)){
+function SarissaNodeList(i){
+this.length=i;
+}
+SarissaNodeList.prototype=new Array(0);
+SarissaNodeList.prototype.constructor=Array;
+SarissaNodeList.prototype.item=function(i){
+return (i&lt;0||i&gt;=this.length)?null:this[i];
+};
+SarissaNodeList.prototype.expr=&quot;&quot;;
+if(window.XMLDocument&amp;&amp;(!XMLDocument.prototype.setProperty)){
+XMLDocument.prototype.setProperty=function(x,y){
+};
+}
+Sarissa.setXpathNamespaces=function(_61,_62){
+_61._sarissa_useCustomResolver=true;
+var _63=_62.indexOf(&quot; &quot;)&gt;-1?_62.split(&quot; &quot;):new Array(_62);
+_61._sarissa_xpathNamespaces=new Array(_63.length);
+for(var i=0;i&lt;_63.length;i++){
+var ns=_63[i];
+var _66=ns.indexOf(&quot;:&quot;);
+var _67=ns.indexOf(&quot;=&quot;);
+if(_66&gt;0&amp;&amp;_67&gt;_66+1){
+var _68=ns.substring(_66+1,_67);
+var uri=ns.substring(_67+2,ns.length-1);
+_61._sarissa_xpathNamespaces[_68]=uri;
+}else{
+throw &quot;Bad format on namespace declaration(s) given&quot;;
+}
+}
+};
+XMLDocument.prototype._sarissa_useCustomResolver=false;
+XMLDocument.prototype._sarissa_xpathNamespaces=new Array();
+XMLDocument.prototype.selectNodes=function(_6a,_6b,_6c){
+var _6d=this;
+var _6e=this._sarissa_useCustomResolver?function(_6f){
+var s=_6d._sarissa_xpathNamespaces[_6f];
+if(s){
+return s;
+}else{
+throw &quot;No namespace URI found for prefix: '&quot;+_6f+&quot;'&quot;;
+}
+}:this.createNSResolver(this.documentElement);
+var _71=null;
+if(!_6c){
+var _72=this.evaluate(_6a,(_6b?_6b:this),_6e,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null);
+var _73=new SarissaNodeList(_72.snapshotLength);
+_73.expr=_6a;
+for(var i=0;i&lt;_73.length;i++){
+_73[i]=_72.snapshotItem(i);
+}
+_71=_73;
+}else{
+_71=_72=this.evaluate(_6a,(_6b?_6b:this),_6e,XPathResult.FIRST_ORDERED_NODE_TYPE,null).singleNodeValue;
+}
+return _71;
+};
+Element.prototype.selectNodes=function(_75){
+var doc=this.ownerDocument;
+if(doc.selectNodes){
+return doc.selectNodes(_75,this);
+}else{
+throw &quot;Method selectNodes is only supported by XML Elements&quot;;
+}
+};
+XMLDocument.prototype.selectSingleNode=function(_77,_78){
+var ctx=_78?_78:null;
+return this.selectNodes(_77,ctx,true);
+};
+Element.prototype.selectSingleNode=function(_7a){
+var doc=this.ownerDocument;
+if(doc.selectSingleNode){
+return doc.selectSingleNode(_7a,this);
+}else{
+throw &quot;Method selectNodes is only supported by XML Elements&quot;;
+}
+};
+Sarissa.IS_ENABLED_SELECT_NODES=true;
+}
+if(_SARISSA_IS_IE){
+Sarissa.IS_ENABLED_SELECT_NODES=true;
+}
+if(typeof (Freja)==&quot;undefined&quot;){
+Freja={};
+}
+Freja._aux={};
+Freja._aux.bind=function(_7c,_7d){
+if(typeof (_7c)==&quot;string&quot;){
+_7c=_7d[_7c];
+}
+var _7e=null;
+if(typeof (_7c.im_func)==&quot;function&quot;){
+_7e=_7c.im_func;
+}else{
+_7e=_7c;
+}
+_7c=function(){
+return _7c.im_func.apply(_7c.im_self,arguments);
+};
+_7c.im_func=_7e;
+_7c.im_self=_7d;
+return _7c;
+};
+Freja._aux.formContents=function(_7f){
+if(!_7f){
+_7f=document;
+}
+var _80=[];
+var _81=[];
+var _82=_7f.getElementsByTagName(&quot;INPUT&quot;);
+for(var i=0;i&lt;_82.length;++i){
+var _84=_82[i];
+if(_84.name){
+if(_84.type==&quot;radio&quot;||_84.type==&quot;checkbox&quot;){
+if(_84.checked){
+_80.push(_84.name);
+_81.push(_84.value);
+}else{
+_80.push(_84.name);
+_81.push(&quot;&quot;);
+}
+}else{
+_80.push(_84.name);
+_81.push(_84.value);
+}
+}
+}
+var _85=_7f.getElementsByTagName(&quot;TEXTAREA&quot;);
+for(var i=0;i&lt;_85.length;++i){
+var _84=_85[i];
+if(_84.name){
+_80.push(_84.name);
+_81.push(_84.value);
+}
+}
+var _86=_7f.getElementsByTagName(&quot;SELECT&quot;);
+for(var i=0;i&lt;_86.length;++i){
+var _84=_86[i];
+if(_84.name){
+if(_84.selectedIndex&gt;=0){
+var opt=_84.options[_84.selectedIndex];
+_80.push(_84.name);
+_81.push((opt.value)?opt.value:&quot;&quot;);
+}
+}
+}
+return [_80,_81];
+};
+Freja._aux.getElement=function(id){
+if(typeof (id)==&quot;object&quot;){
+return id;
+}else{
+return document.getElementById(id);
+}
+};
+Freja._aux.connect=function(src,_8a,fnc){
+if(!src){
+return;
+}
+if(src.addEventListener){
+var _8c=function(e){
+var evt={stop:function(){
+if(e.cancelable){
+e.preventDefault();
+}
+e.stopPropagation();
+}};
+fnc(evt);
+};
+src.addEventListener(_8a.replace(/^(on)/,&quot;&quot;),_8c,false);
+}else{
+if(src.attachEvent){
+var _8c=function(){
+var e=window.event;
+var evt={stop:function(){
+e.cancelBubble=true;
+e.returnValue=false;
+}};
+fnc(evt);
+};
+src.attachEvent(_8a,_8c);
+}
+}
+if(!src._signals){
+src._signals=[];
+}
+if(!src._signals[_8a]){
+src._signals[_8a]=[];
+}
+for(var _91=0;_91&lt;src._signals[_8a].length;_91++){
+if(src._signals[_8a][_91].toString()==fnc.toString()){
+return;
+}
+}
+src._signals[_8a].push(fnc);
+};
+Freja._aux.signal=function(src,_93){
+try{
+var _94=src._signals[_93];
+var _95=[];
+for(var i=2;i&lt;arguments.length;i++){
+_95.push(arguments[i]);
+}
+for(var i=0;i&lt;_94.length;i++){
+try{
+_94[i].apply(src,_95);
+}
+catch(e){
+}
+}
+}
+catch(e){
+}
+};
+Freja._aux.createDeferred=function(){
+return new Freja._aux.Deferred();
+};
+Freja._aux.openXMLHttpRequest=function(_97,url,_99,_9a,_9b){
+var req=new XMLHttpRequest();
+if(_9a&amp;&amp;_9b){
+req.open(_97,url,_99,_9a,_9b);
+}else{
+req.open(_97,url,_99);
+}
+if(_97==&quot;POST&quot;||_97==&quot;PUT&quot;){
+req.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
+}
+req.setRequestHeader(&quot;X-Requested-With&quot;,&quot;XMLHttpRequest&quot;);
+return req;
+};
+Freja._aux.sendXMLHttpRequest=function(req,_9e){
+var d=Freja._aux.createDeferred();
+var _a0=false;
+req.onreadystatechange=function(){
+if(req.readyState==4&amp;&amp;!_a0){
+if(req.status==0||req.status==200||req.status==201||req.status==304){
+d.callback(req);
+}else{
+d.errback(req);
+}
+_a0=true;
+}
+};
+if(!_9e){
+_9e=&quot;&quot;;
+}
+req.send(_9e);
+return d;
+};
+Freja._aux.xmlize=Sarissa.xmlize;
+Freja._aux.serializeXML=function(_a1){
+if(_a1.xml){
+return _a1.xml;
+}
+return (new XMLSerializer()).serializeToString(_a1);
+};
+Freja._aux.loadXML=function(_a2){
+return (new DOMParser()).parseFromString(_a2,&quot;text/xml&quot;);
+};
+Freja._aux.transformXSL=function(xml,xsl,_a5){
+var _a6=new XSLTProcessor();
+_a6.importStylesheet(xsl);
+if(_a5){
+for(var _a7 in _a5){
+_a6.setParameter(&quot;&quot;,_a7,_a5[_a7]);
+}
+}
+return _a6.transformToFragment(xml,window.document);
+};
+Freja._aux.cloneXMLDocument=function(_a8){
+var _a9=null;
+try{
+_a9=_a8.cloneNode(true);
+}
+catch(e){
+}
+if(!_a9){
+if(document.implementation&amp;&amp;document.implementation.createDocument){
+_a9=document.implementation.createDocument(&quot;&quot;,_a8.documentElement.nodeName,null);
+var _aa=_a9.importNode(_a8.documentElement.cloneNode(true),true);
+try{
+_a9.appendChild(_aa);
+}
+catch(e){
+var _ab=_a9.documentElement;
+for(var i=_aa.childNodes.length;i&gt;=0;i--){
+_ab.insertBefore(_aa.childNodes[i],_ab.firstChild);
+}
+for(var i=0;i&lt;_a8.documentElement.attributes.length;i++){
+var _ad=_a8.documentElement.attributes.item(i).name;
+var _ae=_a8.documentElement.attributes.item(i).value;
+_a9.documentElement.setAttribute(_ad,_ae);
+}
+}
+}
+}
+return _a9;
+};
+Freja._aux.hasSupportForXSLT=function(){
+return (typeof (XSLTProcessor)!=&quot;undefined&quot;);
+};
+Freja._aux.createQueryEngine=function(){
+if(Sarissa.IS_ENABLED_SELECT_NODES){
+return new Freja.QueryEngine.XPath();
+}else{
+return new Freja.QueryEngine.SimplePath();
+}
+};
+Freja._aux.Deferred=function(){
+this._good=[];
+this._bad=[];
+this._pending=null;
+};
+Freja._aux.Deferred.prototype.callback=function(){
+if(this._good.length==0){
+this._pending=[this.callback,arguments];
+return;
+}
+for(var i=0;i&lt;this._good.length;i++){
+this._good[i].apply(window,arguments);
+}
+this._good=[];
+};
+Freja._aux.Deferred.prototype.errback=function(){
+if(this._bad.length==0){
+this._pending=[this.errback,arguments];
+return;
+}
+for(var i=0;i&lt;this._bad.length;i++){
+this._bad[i].apply(window,arguments);
+}
+this._bad=[];
+};
+Freja._aux.Deferred.prototype.addCallbacks=function(_b1,_b2){
+if(_b1){
+this._good[this._good.length]=_b1;
+}
+if(_b2){
+this._bad[this._bad.length]=_b2;
+}
+if(this._pending){
+this._pending[0].apply(this,this._pending[1]);
+}
+};
+Freja._aux.Deferred.prototype.addCallback=function(_b3){
+this.addCallbacks(_b3);
+};
+Freja._aux.Deferred.prototype.addErrback=function(_b4){
+this.addCallbacks(null,_b4);
+};
+Freja.QueryEngine=function(){
+};
+Freja.QueryEngine.prototype.getElementById=function(_b5,id){
+var _b7=_b5.getElementsByTagName(&quot;*&quot;);
+for(var i=0;i&lt;_b7.length;i++){
+if(_b7[i].getAttribute(&quot;id&quot;)==id){
+return _b7[i];
+}
+}
+};
+Freja.QueryEngine.prototype.get=function(_b9,_ba){
+var _bb=this._find(_b9,_ba);
+if(!_bb){
+throw new Error(&quot;Can't evaluate expression &quot;+_ba);
+}
+switch(_bb.nodeType){
+case 1:
+if(_bb.firstChild&amp;&amp;(_bb.firstChild.nodeType==3||_bb.firstChild.nodeType==4)){
+return _bb.firstChild.nodeValue;
+}
+break;
+case 2:
+return _bb.nodeValue;
+break;
+case 3:
+case 4:
+return _bb.nodeValue;
+break;
+}
+return null;
+};
+Freja.QueryEngine.prototype.set=function(_bc,_bd,_be){
+var _bf=this._find(_bc,_bd);
+if(!_bf){
+var _c0=_bd.substr(_bd.lastIndexOf(&quot;/&quot;)+1);
+if(_c0.charAt(0)==&quot;@&quot;){
+var _c1=_bd.substring(0,_bd.lastIndexOf(&quot;/&quot;));
+var _c2=this._find(_bc,_c1);
+if(_c2){
+_c2.setAttribute(_c0.substr(1),_be);
+return;
+}
+}
+throw new Error(&quot;Can't evaluate expression &quot;+_bd);
+}
+switch(_bf.nodeType){
+case 1:
+if(_bf.firstChild&amp;&amp;(_bf.firstChild.nodeType==3||_bf.firstChild.nodeType==4)){
+_bf.firstChild.nodeValue=_be;
+}else{
+if(_be!=&quot;&quot;){
+_bf.appendChild(_bc.createTextNode(_be));
+}
+}
+break;
+case 2:
+_bf.nodeValue=_be;
+break;
+case 3:
+case 4:
+_bf.nodeValue=_be;
+break;
+}
+return;
+};
+Freja.QueryEngine.XPath=function(){
+};
+Freja.Class.extend(Freja.QueryEngine.XPath,Freja.QueryEngine);
+Freja.QueryEngine.XPath.prototype._find=function(_c3,_c4){
+var _c5=_c3.selectSingleNode(_c4);
+return _c5;
+};
+Freja.QueryEngine.SimplePath=function(){
+};
+Freja.Class.extend(Freja.QueryEngine.SimplePath,Freja.QueryEngine);
+Freja.QueryEngine.SimplePath.prototype._find=function(_c6,_c7){
+if(!_c7.match(/^[\d\w\/@\[\]=_\-']*$/)){
+throw new Error(&quot;Can't evaluate expression &quot;+_c7);
+}
+var _c8=_c7.split(&quot;/&quot;);
+var _c9=_c6;
+var _ca=new RegExp(&quot;^@([\\d\\w]*)&quot;);
+var _cb=new RegExp(&quot;^([@\\d\\w]*)\\[([\\d]*)\\]$&quot;);
+var _cc=new RegExp(&quot;^([\\d\\w]+)\\[@([@\\d\\w]+)=['\&quot;]{1}(.*)['\&quot;]{1}\\]$&quot;);
+var _cd=null;
+var _ce=0;
+for(var i=0;i&lt;_c8.length;++i){
+var _d0=_c8[i];
+var _d1=_cc.exec(_d0);
+if(_d1){
+if(i&gt;0&amp;&amp;_c8[i-1]==&quot;&quot;){
+var cn=_c9.getElementsByTagName(_d1[1]);
+}else{
+var cn=_c9.childNodes;
+}
+for(var j=0,l=cn.length;j&lt;l;j++){
+if(cn[j].nodeType==1&amp;&amp;cn[j].tagName==_d1[1]&amp;&amp;cn[j].getAttribute(_d1[2])==_d1[3]){
+_c9=cn[j];
+break;
+}
+}
+if(j==l){
+throw new Error(&quot;Can't evaluate expression &quot;+_d0);
+}
+}else{
+_ce=_cb.exec(_d0);
+if(_ce){
+_d0=_ce[1];
+_ce=_ce[2]-1;
+}else{
+_ce=0;
+}
+if(_d0!=&quot;&quot;){
+_cd=_ca.exec(_d0);
+if(_cd){
+_c9=_c9.getAttributeNode(_cd[1]);
+}else{
+_c9=_c9.getElementsByTagName(_d0).item(_ce);
+}
+}
+}
+}
+if(_c9&amp;&amp;_c9.firstChild&amp;&amp;_c9.firstChild.nodeType==3){
+return _c9.firstChild;
+}
+if(_c9&amp;&amp;_c9.firstChild&amp;&amp;_c9.firstChild.nodeType==4){
+return _c9.firstChild;
+}
+if(!_c9){
+throw new Error(&quot;Can't evaluate expression &quot;+_c7);
+}
+return _c9;
+};
+Freja.Model=function(url,_d5){
+this.url=url;
+this.ready=false;
+this.document=null;
+this._query=_d5;
+};
+Freja.Model.prototype.getElementById=function(id){
+if(this.document){
+return this._query.getElementById(this.document,id);
+}
+return null;
+};
+Freja.Model.prototype.get=function(_d7){
+if(this.document){
+return this._query.get(this.document,_d7);
+}
+return null;
+};
+Freja.Model.prototype.set=function(_d8,_d9){
+if(this.document){
+return this._query.set(this.document,_d8,_d9);
+}
+return null;
+};
+Freja.Model.prototype.updateFrom=function(_da){
+var _db=_da.getValues();
+for(var i=0;i&lt;_db[0].length;++i){
+if(_db[0][i].lastIndexOf(&quot;/&quot;)!=-1){
+this.set(_db[0][i],_db[1][i]);
+}
+}
+};
+Freja.Model.prototype.save=function(){
+var url=this.url;
+var _de=/^(file:\/\/.*\/)([^\/]*)$/.exec(window.location.href);
+if(_de){
+url=_de[1]+url;
+}
+var d=Freja._aux.createDeferred();
+var req=Freja.AssetManager.openXMLHttpRequest(&quot;POST&quot;,url);
+try{
+Freja._aux.sendXMLHttpRequest(req,Freja._aux.serializeXML(this.document)).addCallbacks(Freja._aux.bind(d.callback,d),Freja._aux.bind(d.errback,d));
+}
+catch(ex){
+d.errback(ex);
+}
+return d;
+};
+Freja.Model.prototype.remove=function(){
+var url=this.url;
+var _e2=/^(file:\/\/.*\/)([^\/]*)$/.exec(window.location.href);
+if(_e2){
+url=_e2[1]+url;
+}
+var req=Freja.AssetManager.openXMLHttpRequest(&quot;DELETE&quot;,url);
+return Freja._aux.sendXMLHttpRequest(req);
+};
+Freja.Model.prototype.reload=function(){
+this.ready=false;
+var _e4=Freja._aux.bind(function(_e5){
+this.document=_e5;
+this.ready=true;
+Freja._aux.signal(this,&quot;onload&quot;);
+},this);
+var d=Freja.AssetManager.loadAsset(this.url,true);
+d.addCallbacks(_e4,Freja.AssetManager.onerror);
+return d;
+};
+Freja.Model.DataSource=function(_e7,_e8){
+this.createURL=_e7;
+this.indexURL=_e8;
+};
+Freja.Model.DataSource.prototype.select=function(){
+return getModel(this.indexURL);
+};
+Freja.Model.DataSource.prototype.create=function(_e9){
+var url=this.createURL;
+var _eb=/^(file:\/\/.*\/)([^\/]*)$/.exec(window.location.href);
+if(_eb){
+url=_eb[1]+url;
+}
+var req=Freja.AssetManager.openXMLHttpRequest(&quot;PUT&quot;,url);
+var _ed={};
+for(var i=0,len=_e9[0].length;i&lt;len;++i){
+_ed[_e9[0][i]]=_e9[1][i];
+}
+return Freja._aux.sendXMLHttpRequest(req,Freja._aux.xmlize(_ed,&quot;record&quot;));
+};
+Freja.View=function(url,_f0){
+this.url=url;
+this.ready=false;
+this.document=null;
+this._renderer=_f0;
+this._destination=null;
+this.behaviors=[];
+this.placeholder=null;
+Freja._aux.connect(this,&quot;onrendercomplete&quot;,Freja._aux.bind(this._connectBehavior,this));
+};
+Freja.View.prototype.render=function(_f1,_f2,_f3){
+if(typeof (_f2)==&quot;undefined&quot;){
+_f2=this.placeholder;
+}
+if(typeof (_f3)==&quot;undefined&quot;){
+_f3=this.xslParameters;
+}
+var _f4=function(_f5,_f6,_f7,_f8){
+this.model=_f5;
+this.view=_f6;
+this.deferred=_f7;
+this.xslParameters=_f8;
+};
+_f4.prototype.trigger=function(){
+try{
+if(!this.view.ready){
+Freja._aux.connect(this.view,&quot;onload&quot;,Freja._aux.bind(this.trigger,this));
+return;
+}
+if(typeof (this.model)==&quot;object&quot;&amp;&amp;this.model instanceof Freja.Model&amp;&amp;!this.model.ready){
+Freja._aux.connect(this.model,&quot;onload&quot;,Freja._aux.bind(this.trigger,this));
+return;
+}
+var _f9;
+if(typeof (this.model)==&quot;undefined&quot;){
+_f9={document:Freja._aux.loadXML(&quot;&lt;?xml version='1.0' ?&gt;&lt;dummy/&gt;&quot;)};
+}else{
+if(this.model instanceof Freja.Model){
+_f9=this.model;
+}else{
+_f9={document:Freja._aux.loadXML(&quot;&lt;?xml version='1.0' ?&gt;\n&quot;+Freja._aux.xmlize(this.model,&quot;item&quot;))};
+}
+}
+var _fa=this.view._renderer.transform(_f9,this.view,this.xslParameters);
+_fa.addCallback(Freja._aux.bind(function(_fb){
+if(typeof _fb==&quot;string&quot;){
+this._destination.innerHTML=_fb;
+}else{
+this._destination.innerHTML=&quot;&quot;;
+this._destination.appendChild(_fb);
+}
+},this.view));
+_fa.addCallback(Freja._aux.bind(function(){
+Freja._aux.signal(this,&quot;onrendercomplete&quot;,this._destination);
+},this.view));
+_fa.addCallback(this.deferred.callback);
+_fa.addErrback(this.deferred.errback);
+}
+catch(ex){
+this.deferred.errback(ex);
+}
+};
+var d=Freja._aux.createDeferred();
+try{
+if(typeof (_f2)==&quot;object&quot;){
+this._destination=_f2;
+}else{
+this._destination=document.getElementById(_f2);
+}
+this._destination.innerHTML=Freja.AssetManager.THROBBER_HTML;
+var h=new _f4(_f1,this,d,_f3);
+h.trigger();
+}
+catch(ex){
+d.errback(ex);
+}
+return d;
+};
+Freja.View.prototype._connectBehavior=function(_fe){
+try{
+var _ff=function(node,_101,_102){
+Freja._aux.connect(node,_101,Freja._aux.bind(function(e){
+var _104=false;
+try{
+_104=_102(this);
+}
+catch(ex){
+throw new Error(&quot;An error ocurred in user handler.\n&quot;+ex.message);
+}
+finally{
+if(!_104){
+e.stop();
+}
+}
+},node));
+};
+var _105=function(node,_107){
+for(var i=0,c=node.childNodes,l=c.length;i&lt;l;++i){
+var _109=c[i];
+if(_109.nodeType==1){
+if(_109.className){
+var _10a=_109.className.split(&quot; &quot;);
+for(var j=0;j&lt;_10a.length;j++){
+var _10c=_107[_10a[j]];
+if(_10c){
+for(var _10d in _10c){
+if(_10d==&quot;init&quot;){
+_10c.init(_109);
+}else{
+_ff(_109,_10d,_10c[_10d]);
+}
+}
+}
+}
+}
+_105(_109,_107);
+}
+}
+};
+for(var ids in this.behaviors){
+_105(_fe,this.behaviors);
+break;
+}
+}
+catch(ex){
+alert(ex.message);
+}
+};
+Freja.View.prototype.getValues=function(){
+return Freja._aux.formContents(this._destination);
+};
+Freja.View.Renderer=function(){
+};
+Freja.View.Renderer.XSLTransformer=function(){
+};
+Freja.Class.extend(Freja.View.Renderer.XSLTransformer,Freja.View.Renderer);
+Freja.View.Renderer.XSLTransformer.prototype.transform=function(_10f,view,_111){
+var d=Freja._aux.createDeferred();
+try{
+var html=Freja._aux.transformXSL(_10f.document,view.document,_111);
+if(!html){
+d.errback(new Error(&quot;XSL Transformation error.&quot;));
+}else{
+d.callback(html);
+}
+}
+catch(ex){
+d.errback(ex);
+}
+return d;
+};
+Freja.View.Renderer.RemoteXSLTransformer=function(url){
+this.url=url;
+};
+Freja.Class.extend(Freja.View.Renderer.RemoteXSLTransformer,Freja.View.Renderer);
+Freja.View.Renderer.RemoteXSLTransformer.prototype.transform=function(_115,view,_117){
+var d=Freja._aux.createDeferred();
+var _119=view.url;
+var _11a=&quot;xslFile=&quot;+encodeURIComponent(_119)+&quot;&amp;xmlData=&quot;+encodeURIComponent(Freja._aux.serializeXML(_115.document));
+var _11b=&quot;&quot;;
+for(var _11c in _117){
+_11b+=encodeURIComponent(_11c+&quot;,&quot;+_117[_11c]);
+}
+if(_11b.length&gt;0){
+_11a=_11a+&quot;&amp;xslParam=&quot;+_11b;
+}
+var req=Freja.AssetManager.openXMLHttpRequest(&quot;POST&quot;,Freja.AssetManager.XSLT_SERVICE_URL);
+req.onreadystatechange=function(){
+if(req.readyState==4){
+if(req.status==200){
+d.callback(req.responseText);
+}else{
+d.errback(req.responseText);
+}
+}
+};
+req.send(_11a);
+return d;
+};
+Freja.UndoHistory=function(){
+this.cache=[];
+this.maxLength=5;
+this._position=0;
+this._undoSteps=0;
+};
+Freja.UndoHistory.prototype.add=function(_11e){
+var _11f=this._position%this.maxLength;
+var _120=_11e.document;
+this.cache[_11f]={};
+this.cache[_11f].model=_11e;
+this.cache[_11f].document=Freja._aux.cloneXMLDocument(_120);
+if(!this.cache[_11f].document){
+throw new Error(&quot;Couldn't add to history.&quot;);
+}else{
+this._position++;
+var _121=_11f;
+while(this._undoSteps&gt;0){
+_121=(_121+1)%this.maxLength;
+this.cache[_121]={};
+this._undoSteps--;
+}
+return _11f;
+}
+};
+Freja.UndoHistory.prototype.undo=function(_122){
+if(this._undoSteps&lt;this.cache.length){
+this._undoSteps++;
+this._position--;
+if(this._position&lt;0){
+this._position=this.maxLength-1;
+}
+var _123=this.cache[this._position].model;
+if(this.cache[this._position].document){
+_123.document=this.cache[this._position].document;
+}else{
+throw new Error(&quot;The model's DOMDocument wasn't properly copied into the history&quot;);
+}
+if(typeof (_122)!=&quot;undefined&quot;&amp;&amp;_122&gt;1){
+this.undo(_122-1);
+}
+}else{
+throw new Error(&quot;Nothing to undo&quot;);
+}
+};
+Freja.UndoHistory.prototype.redo=function(){
+if(this._undoSteps&gt;0){
+this._undoSteps--;
+this._position=(this._position+1)%this.maxLength;
+var _124=this.cache[this._position].model;
+_124.document=this.cache[this._position].document;
+}else{
+throw new Error(&quot;Nothing to redo&quot;);
+}
+};
+Freja.UndoHistory.prototype.removeLast=function(){
+this._position--;
+if(this._position&lt;0){
+this._position=this.maxLength-1;
+}
+this.cache[this._position]={};
+this._undoSteps=0;
+};
+Freja.AssetManager={models:[],views:[],_username:null,_password:null};
+Freja.AssetManager.HTTP_REQUEST_TYPE=&quot;async&quot;;
+Freja.AssetManager.HTTP_METHOD_TUNNEL=&quot;Http-Method-Equivalent&quot;;
+Freja.AssetManager.XSLT_SERVICE_URL=&quot;srvc-xslt.php&quot;;
+Freja.AssetManager.THROBBER_HTML=&quot;&lt;span style='color:white;background:firebrick'&gt;Loading ...&lt;/span&gt;&quot;;
+Freja.AssetManager.createRenderer=function(){
+if(Freja._aux.hasSupportForXSLT()){
+return new Freja.View.Renderer.XSLTransformer();
+}else{
+return new Freja.View.Renderer.RemoteXSLTransformer(this.XSLT_SERVICE_URL);
+}
+};
+Freja.AssetManager.clearCache=function(){
+this.models=[];
+this.views=[];
+};
+Freja.AssetManager.getModel=function(url){
+for(var i=0;i&lt;this.models.length;i++){
+if(this.models[i].url==url){
+return this.models[i];
+}
+}
+var m=new Freja.Model(url,Freja._aux.createQueryEngine());
+var _128=Freja._aux.bind(function(_129){
+this.document=_129;
+this.ready=true;
+Freja._aux.signal(this,&quot;onload&quot;);
+},m);
+this.loadAsset(url,true).addCallbacks(_128,Freja.AssetManager.onerror);
+this.models.push(m);
+return m;
+};
+Freja.AssetManager.getView=function(url){
+for(var i=0;i&lt;this.views.length;i++){
+if(this.views[i].url==url){
+return this.views[i];
+}
+}
+var v=new Freja.View(url,this.createRenderer());
+var _12d=Freja._aux.bind(function(_12e){
+this.document=_12e;
+this.ready=true;
+Freja._aux.signal(this,&quot;onload&quot;);
+},v);
+this.loadAsset(url,false).addCallbacks(_12d,Freja.AssetManager.onerror);
+this.views.push(v);
+return v;
+};
+Freja.AssetManager.openXMLHttpRequest=function(_12f,url){
+var _131=null;
+if(Freja.AssetManager.HTTP_METHOD_TUNNEL&amp;&amp;_12f!=&quot;GET&quot;&amp;&amp;_12f!=&quot;POST&quot;){
+_131=_12f;
+_12f=&quot;POST&quot;;
+}
+var req=Freja._aux.openXMLHttpRequest(_12f,url,Freja.AssetManager.HTTP_REQUEST_TYPE==&quot;async&quot;,Freja.AssetManager._username,Freja.AssetManager._password);
+if(_131){
+req.setRequestHeader(Freja.AssetManager.HTTP_METHOD_TUNNEL,_131);
+}
+return req;
+};
+Freja.AssetManager.setCredentials=function(_133,_134){
+this._username=_133;
+this._password=_134;
+};
+Freja.AssetManager.loadAsset=function(url,_136){
+var _137=/^(file:\/\/.*\/)([^\/]*)$/.exec(window.location.href);
+if(_137){
+url=_137[1]+url;
+}
+var d=Freja._aux.createDeferred();
+var _139=function(_13a){
+try{
+if(_13a.responseText==&quot;&quot;){
+throw new Error(&quot;Empty response.&quot;);
+}
+if(_13a.responseXML.xml==&quot;&quot;){
+var _13b=Freja._aux.loadXML(_13a.responseText);
+}else{
+var _13b=_13a.responseXML;
+}
+}
+catch(ex){
+d.errback(ex);
+}
+if(window.document.all){
+setTimeout(function(){
+d.callback(_13b);
+},1);
+}else{
+d.callback(_13b);
+}
+};
+try{
+if(_136&amp;&amp;Freja.AssetManager.HTTP_METHOD_TUNNEL){
+var req=Freja._aux.openXMLHttpRequest(&quot;POST&quot;,url,Freja.AssetManager.HTTP_REQUEST_TYPE==&quot;async&quot;,Freja.AssetManager._username,Freja.AssetManager._password);
+req.setRequestHeader(Freja.AssetManager.HTTP_METHOD_TUNNEL,&quot;GET&quot;);
+req.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
+}else{
+var req=Freja._aux.openXMLHttpRequest(&quot;GET&quot;,url,Freja.AssetManager.HTTP_REQUEST_TYPE==&quot;async&quot;,Freja.AssetManager._username,Freja.AssetManager._password);
+}
+var comm=Freja._aux.sendXMLHttpRequest(req);
+if(Freja.AssetManager.HTTP_REQUEST_TYPE==&quot;async&quot;){
+comm.addCallbacks(_139,function(req){
+d.errback(new Error(&quot;Request failed:&quot;+req.status));
+});
+}else{
+if(req.status==0||req.status==200||req.status==201||req.status==304){
+_139(req);
+}else{
+d.errback(new Error(&quot;Request failed:&quot;+req.status));
+}
+}
+}
+catch(ex){
+d.errback(ex);
+}
+return d;
+};
+Freja.AssetManager.onerror=function(ex){
+alert(&quot;Freja.AssetManager.onerror\n&quot;+ex.message);
+};
+window.getModel=Freja._aux.bind(&quot;getModel&quot;,Freja.AssetManager);
+window.getView=Freja._aux.bind(&quot;getView&quot;,Freja.AssetManager);
+

Modified: branch/2.0.1/lib/MochiKit.js
===================================================================
--- branch/2.0.1/lib/MochiKit.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/lib/MochiKit.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -2255,7 +2255,7 @@
 }
 catch(e){
 }
-if(_290==200||_290==304){
+if(_290==0||_290==200||_290==201||_290==304){
 d.callback(this);
 }else{
 var err=new MochiKit.Async.XMLHttpRequestError(this,&quot;Request failed&quot;);

Modified: branch/2.0.1/lib/Sarissa.js
===================================================================
--- branch/2.0.1/lib/Sarissa.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/lib/Sarissa.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -1,653 +1,662 @@
-/**
- * ====================================================================
- * About
- * ====================================================================
- * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
- * The library supports Gecko based browsers like Mozilla and Firefox,
- * Internet Explorer (5.5+ with MSXML3.0+), Konqueror, Safari and a little of Opera
- * @version 0.9.7.6
- * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
- * ====================================================================
- * Licence
- * ====================================================================
- * Sarissa is free software distributed under the GNU GPL version 2 (see &lt;a href=&quot;gpl.txt&quot;&gt;gpl.txt&lt;/a&gt;) or higher, 
- * GNU LGPL version 2.1 (see &lt;a href=&quot;lgpl.txt&quot;&gt;lgpl.txt&lt;/a&gt;) or higher and Apache Software License 2.0 or higher 
- * (see &lt;a href=&quot;asl.txt&quot;&gt;asl.txt&lt;/a&gt;). This means you can choose one of the three and use that if you like. If 
- * you make modifications under the ASL, i would appreciate it if you submitted those.
- * In case your copy of Sarissa does not include the license texts, you may find
- * them online in various formats at &lt;a href=&quot;<A HREF="http://www.gnu.org">http://www.gnu.org</A>&quot;&gt;<A HREF="http://www.gnu.org&lt;/a">http://www.gnu.org&lt;/a</A>&gt; and 
- * &lt;a href=&quot;<A HREF="http://www.apache.org">http://www.apache.org</A>&quot;&gt;<A HREF="http://www.apache.org&lt;/a">http://www.apache.org&lt;/a</A>&gt;.
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY 
- * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
- * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
- * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
- * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- */
-/**
- * &lt;p&gt;Sarissa is a utility class. Provides &quot;static&quot; methods for DOMDocument, 
- * DOM Node serialization to XML strings and other utility goodies.&lt;/p&gt;
- * @constructor
- */
-function Sarissa(){};
-Sarissa.PARSED_OK = &quot;Document contains no parsing errors&quot;;
-Sarissa.PARSED_EMPTY = &quot;Document is empty&quot;;
-Sarissa.PARSED_UNKNOWN_ERROR = &quot;Not well-formed or other error&quot;;
-var _sarissa_iNsCounter = 0;
-var _SARISSA_IEPREFIX4XSLPARAM = &quot;&quot;;
-var _SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation &amp;&amp; true;
-var _SARISSA_HAS_DOM_CREATE_DOCUMENT = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.createDocument;
-var _SARISSA_HAS_DOM_FEATURE = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.hasFeature;
-var _SARISSA_IS_MOZ = _SARISSA_HAS_DOM_CREATE_DOCUMENT &amp;&amp; _SARISSA_HAS_DOM_FEATURE;
-var _SARISSA_IS_SAFARI = (navigator.userAgent &amp;&amp; navigator.vendor &amp;&amp; (navigator.userAgent.toLowerCase().indexOf(&quot;applewebkit&quot;) != -1 || navigator.vendor.indexOf(&quot;Apple&quot;) != -1));
-var _SARISSA_IS_IE = document.all &amp;&amp; window.ActiveXObject &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;) &gt; -1  &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;opera&quot;) == -1;
-if(!window.Node || !Node.ELEMENT_NODE){
-    Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
-};
-
-if(typeof XMLDocument == &quot;undefined&quot; &amp;&amp; typeof Document !=&quot;undefined&quot;){ XMLDocument = Document; } 
-
-// IE initialization
-if(_SARISSA_IS_IE){
-    // for XSLT parameter names, prefix needed by IE
-    _SARISSA_IEPREFIX4XSLPARAM = &quot;xsl:&quot;;
-    // used to store the most recent ProgID available out of the above
-    var _SARISSA_DOM_PROGID = &quot;&quot;;
-    var _SARISSA_XMLHTTP_PROGID = &quot;&quot;;
-    var _SARISSA_DOM_XMLWRITER = &quot;&quot;;
-    /**
-     * Called when the Sarissa_xx.js file is parsed, to pick most recent
-     * ProgIDs for IE, then gets destroyed.
-     * @private
-     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
-     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
-     */
-    Sarissa.pickRecentProgID = function (idList){
-        // found progID flag
-        var bFound = false;
-        for(var i=0; i &lt; idList.length &amp;&amp; !bFound; i++){
-            try{
-                var oDoc = new ActiveXObject(idList[i]);
-                o2Store = idList[i];
-                bFound = true;
-            }catch (objException){
-                // trap; try next progID
-            };
-        };
-        if (!bFound) {
-            throw &quot;Could not retreive a valid progID of Class: &quot; + idList[idList.length-1]+&quot;. (original exception: &quot;+e+&quot;)&quot;;
-        };
-        idList = null;
-        return o2Store;
-    };
-    // pick best available MSXML progIDs
-    _SARISSA_DOM_PROGID = null;
-    _SARISSA_THREADEDDOM_PROGID = null;
-    _SARISSA_XSLTEMPLATE_PROGID = null;
-    _SARISSA_XMLHTTP_PROGID = null;
-    if(!window.XMLHttpRequest){
-        /**
-         * Emulate XMLHttpRequest
-         * @constructor
-         */
-        XMLHttpRequest = function() {
-            if(!_SARISSA_XMLHTTP_PROGID){
-                _SARISSA_XMLHTTP_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XMLHTTP.6.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]);
-            };
-            return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
-        };
-    };
-    // we dont need this anymore
-    //============================================
-    // Factory methods (IE)
-    //============================================
-    // see non-IE version
-    Sarissa.getDomDocument = function(sUri, sName){
-        if(!_SARISSA_DOM_PROGID){
-            _SARISSA_DOM_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.DOMDocument.6.0&quot;, &quot;Msxml2.DOMDocument.3.0&quot;, &quot;MSXML2.DOMDocument&quot;, &quot;MSXML.DOMDocument&quot;, &quot;Microsoft.XMLDOM&quot;]);
-        };
-        var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
-        // if a root tag name was provided, we need to load it in the DOM object
-        if (sName){
-            // create an artifical namespace prefix 
-            // or reuse existing prefix if applicable
-            var prefix = &quot;&quot;;
-            if(sUri){
-                if(sName.indexOf(&quot;:&quot;) &gt; 1){
-                    prefix = sName.substring(0, sName.indexOf(&quot;:&quot;));
-                    sName = sName.substring(sName.indexOf(&quot;:&quot;)+1); 
-                }else{
-                    prefix = &quot;a&quot; + (_sarissa_iNsCounter++);
-                };
-            };
-            // use namespaces if a namespace URI exists
-            if(sUri){
-                oDoc.loadXML('&lt;' + prefix+':'+sName + &quot; xmlns:&quot; + prefix + &quot;=\&quot;&quot; + sUri + &quot;\&quot;&quot; + &quot; /&gt;&quot;);
-            } else {
-                oDoc.loadXML('&lt;' + sName + &quot; /&gt;&quot;);
-            };
-        };
-        return oDoc;
-    };
-    // see non-IE version   
-    Sarissa.getParseErrorText = function (oDoc) {
-        var parseErrorText = Sarissa.PARSED_OK;
-        if(oDoc.parseError.errorCode != 0){
-            parseErrorText = &quot;XML Parsing Error: &quot; + oDoc.parseError.reason + 
-                &quot;\nLocation: &quot; + oDoc.parseError.url + 
-                &quot;\nLine Number &quot; + oDoc.parseError.line + &quot;, Column &quot; + 
-                oDoc.parseError.linepos + 
-                &quot;:\n&quot; + oDoc.parseError.srcText +
-                &quot;\n&quot;;
-            for(var i = 0;  i &lt; oDoc.parseError.linepos;i++){
-                parseErrorText += &quot;-&quot;;
-            };
-            parseErrorText +=  &quot;^\n&quot;;
-        }
-        else if(oDoc.documentElement == null){
-            parseErrorText = Sarissa.PARSED_EMPTY;
-        };
-        return parseErrorText;
-    };
-    // see non-IE version
-    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
-        oDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
-        oDoc.setProperty(&quot;SelectionNamespaces&quot;, sNsSet);
-    };   
-    /**
-     * Basic implementation of Mozilla's XSLTProcessor for IE. 
-     * Reuses the same XSLT stylesheet for multiple transforms
-     * @constructor
-     */
-    XSLTProcessor = function(){
-        if(!_SARISSA_XSLTEMPLATE_PROGID){
-            _SARISSA_XSLTEMPLATE_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XSLTemplate.6.0&quot;, &quot;MSXML2.XSLTemplate.3.0&quot;]);
-        };
-        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
-        this.processor = null;
-    };
-    /**
-     * Imports the given XSLT DOM and compiles it to a reusable transform
-     * &lt;b&gt;Note:&lt;/b&gt; If the stylesheet was loaded from a URL and contains xsl:import or xsl:include elements,it will be reloaded to resolve those
-     * @argument xslDoc The XSLT DOMDocument to import
-     */
-    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
-        if(!_SARISSA_THREADEDDOM_PROGID){
-            _SARISSA_THREADEDDOM_PROGID = Sarissa.pickRecentProgID([&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;, &quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
-        };
-        xslDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
-        xslDoc.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
-        // convert stylesheet to free threaded
-        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
-        // make included/imported stylesheets work if exist and xsl was originally loaded from url
-        if(xslDoc.url &amp;&amp; xslDoc.selectSingleNode(&quot;//xsl:*[local-name() = 'import' or local-name() = 'include']&quot;) != null){
-            converted.async = false;
-            if (_SARISSA_THREADEDDOM_PROGID == &quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;) { 
-                converted.setProperty(&quot;AllowDocumentFunction&quot;, true); 
-                converted.resolveExternals = true; 
-            }
-            converted.load(xslDoc.url);
-        } else {
-            converted.loadXML(xslDoc.xml);
-        };
-        converted.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
-        var output = converted.selectSingleNode(&quot;//xsl:output&quot;);
-        this.outputMethod = output ? output.getAttribute(&quot;method&quot;) : &quot;html&quot;;
-        this.template.stylesheet = converted;
-        this.processor = this.template.createProcessor();
-        // for getParameter and clearParameters
-        this.paramsSet = new Array();
-    };
-
-    /**
-     * Transform the given XML DOM and return the transformation result as a new DOM document
-     * @argument sourceDoc The XML DOMDocument to transform
-     * @return The transformation result as a DOM Document
-     */
-    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
-        // fix for bug 1549749
-        if(_SARISSA_THREADEDDOM_PROGID){
-            this.processor.input=sourceDoc;
-            var outDoc=new ActiveXObject(_SARISSA_DOM_PROGID);
-            this.processor.output=outDoc;
-            this.processor.transform();
-            return outDoc;
-        }
-        else{
-            if(!_SARISSA_DOM_XMLWRITER){
-                _SARISSA_DOM_XMLWRITER = Sarissa.pickRecentProgID([&quot;Msxml2.MXXMLWriter.6.0&quot;, &quot;Msxml2.MXXMLWriter.3.0&quot;, &quot;MSXML2.MXXMLWriter&quot;, &quot;MSXML.MXXMLWriter&quot;, &quot;Microsoft.XMLDOM&quot;]);
-            };
-            this.processor.input = sourceDoc;
-            var outDoc = new ActiveXObject(_SARISSA_DOM_XMLWRITER);
-            this.processor.output = outDoc; 
-            this.processor.transform();
-            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
-            oDoc.loadXML(outDoc.output+&quot;&quot;);
-            return oDoc;
-        };
-    };
-    
-    /**
-     * Transform the given XML DOM and return the transformation result as a new DOM fragment.
-     * &lt;b&gt;Note&lt;/b&gt;: The xsl:output method must match the nature of the owner document (XML/HTML).
-     * @argument sourceDoc The XML DOMDocument to transform
-     * @argument ownerDoc The owner of the result fragment
-     * @return The transformation result as a DOM Document
-     */
-    XSLTProcessor.prototype.transformToFragment = function (sourceDoc, ownerDoc) {
-        this.processor.input = sourceDoc;
-        this.processor.transform();
-        var s = this.processor.output;
-        var f = ownerDoc.createDocumentFragment();
-        if (this.outputMethod == 'text') {
-            f.appendChild(ownerDoc.createTextNode(s));
-        } else if (ownerDoc.body &amp;&amp; ownerDoc.body.innerHTML) {
-            var container = ownerDoc.createElement('div');
-            container.innerHTML = s;
-            while (container.hasChildNodes()) {
-                f.appendChild(container.firstChild);
-            }
-        }
-        else {
-            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
-            if (s.substring(0, 5) == '&lt;?xml') {
-                s = s.substring(s.indexOf('?&gt;') + 2);
-            }
-            var xml = ''.concat('&lt;my&gt;', s, '&lt;/my&gt;');
-            oDoc.loadXML(xml);
-            var container = oDoc.documentElement;
-            while (container.hasChildNodes()) {
-                f.appendChild(container.firstChild);
-            }
-        }
-        return f;
-    };
-    
-    /**
-     * Set global XSLT parameter of the imported stylesheet
-     * @argument nsURI The parameter namespace URI
-     * @argument name The parameter base name
-     * @argument value The new parameter value
-     */
-    XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
-        // nsURI is optional but cannot be null 
-        if(nsURI){
-            this.processor.addParameter(name, value, nsURI);
-        }else{
-            this.processor.addParameter(name, value);
-        };
-        // update updated params for getParameter 
-        if(!this.paramsSet[&quot;&quot;+nsURI]){
-            this.paramsSet[&quot;&quot;+nsURI] = new Array();
-        };
-        this.paramsSet[&quot;&quot;+nsURI][name] = value;
-    };
-    /**
-     * Gets a parameter if previously set by setParameter. Returns null
-     * otherwise
-     * @argument name The parameter base name
-     * @argument value The new parameter value
-     * @return The parameter value if reviously set by setParameter, null otherwise
-     */
-    XSLTProcessor.prototype.getParameter = function(nsURI, name){
-        nsURI = nsURI || &quot;&quot;;
-        if(this.paramsSet[nsURI] &amp;&amp; this.paramsSet[nsURI][name]){
-            return this.paramsSet[nsURI][name];
-        }else{
-            return null;
-        };
-    };
-    /**
-     * Clear parameters (set them to default values as defined in the stylesheet itself)
-     */
-    XSLTProcessor.prototype.clearParameters = function(){
-        for(var nsURI in this.paramsSet){
-            for(var name in this.paramsSet[nsURI]){
-                if(nsURI){
-                    this.processor.addParameter(name, null, nsURI);
-                }else{
-                    this.processor.addParameter(name, null);
-                };
-            };
-        };
-        this.paramsSet = new Array();
-    };
-}else{ /* end IE initialization, try to deal with real browsers now ;-) */
-    if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
-        /**
-         * &lt;p&gt;Ensures the document was loaded correctly, otherwise sets the
-         * parseError to -1 to indicate something went wrong. Internal use&lt;/p&gt;
-         * @private
-         */
-        Sarissa.__handleLoad__ = function(oDoc){
-            Sarissa.__setReadyState__(oDoc, 4);
-        };
-        /**
-        * &lt;p&gt;Attached by an event handler to the load event. Internal use.&lt;/p&gt;
-        * @private
-        */
-        _sarissa_XMLDocument_onload = function(){
-            Sarissa.__handleLoad__(this);
-        };
-        /**
-         * &lt;p&gt;Sets the readyState property of the given DOM Document object.
-         * Internal use.&lt;/p&gt;
-         * @private
-         * @argument oDoc the DOM Document object to fire the
-         *          readystatechange event
-         * @argument iReadyState the number to change the readystate property to
-         */
-        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
-            oDoc.readyState = iReadyState;
-            oDoc.readystate = iReadyState;
-            if (oDoc.onreadystatechange != null &amp;&amp; typeof oDoc.onreadystatechange == &quot;function&quot;)
-                oDoc.onreadystatechange();
-        };
-        Sarissa.getDomDocument = function(sUri, sName){
-            var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
-            if(!oDoc.onreadystatechange){
-            
-                /**
-                * &lt;p&gt;Emulate IE's onreadystatechange attribute&lt;/p&gt;
-                */
-                oDoc.onreadystatechange = null;
-            };
-            if(!oDoc.readyState){
-                /**
-                * &lt;p&gt;Emulates IE's readyState property, which always gives an integer from 0 to 4:&lt;/p&gt;
-                * &lt;ul&gt;&lt;li&gt;1 == LOADING,&lt;/li&gt;
-                * &lt;li&gt;2 == LOADED,&lt;/li&gt;
-                * &lt;li&gt;3 == INTERACTIVE,&lt;/li&gt;
-                * &lt;li&gt;4 == COMPLETED&lt;/li&gt;&lt;/ul&gt;
-                */
-                oDoc.readyState = 0;
-            };
-            oDoc.addEventListener(&quot;load&quot;, _sarissa_XMLDocument_onload, false);
-            return oDoc;
-        };
-        if(window.XMLDocument){
-            // do nothing
-        }// TODO: check if the new document has content before trying to copynodes, check  for error handling in DOM 3 LS
-        else if(_SARISSA_HAS_DOM_FEATURE &amp;&amp; window.Document &amp;&amp; !Document.prototype.load &amp;&amp; document.implementation.hasFeature('LS', '3.0')){
-            //Opera 9 may get the XPath branch which gives creates XMLDocument, therefore it doesn't reach here which is good
-            /**
-            * &lt;p&gt;Factory method to obtain a new DOM Document object&lt;/p&gt;
-            * @argument sUri the namespace of the root node (if any)
-            * @argument sUri the local name of the root node (if any)
-            * @returns a new DOM Document
-            */
-            Sarissa.getDomDocument = function(sUri, sName){
-                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
-                return oDoc;
-            };
-        }
-        else {
-            Sarissa.getDomDocument = function(sUri, sName){
-                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
-                // looks like safari does not create the root element for some unknown reason
-                if(oDoc &amp;&amp; (sUri || sName) &amp;&amp; !oDoc.documentElement){
-                    oDoc.appendChild(oDoc.createElementNS(sUri, sName));
-                };
-                return oDoc;
-            };
-        };
-    };//if(_SARISSA_HAS_DOM_CREATE_DOCUMENT)
-};
-//==========================================
-// Common stuff
-//==========================================
-if(!window.DOMParser){
-    if(_SARISSA_IS_SAFARI){
-        /*
-         * DOMParser is a utility class, used to construct DOMDocuments from XML strings
-         * @constructor
-         */
-        DOMParser = function() { };
-        /** 
-        * Construct a new DOM Document from the given XMLstring
-        * @param sXml the given XML string
-        * @param contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml). 
-        * @return a new DOM Document from the given XML string
-        */
-        DOMParser.prototype.parseFromString = function(sXml, contentType){
-            var xmlhttp = new XMLHttpRequest();
-            xmlhttp.open(&quot;GET&quot;, &quot;data:text/xml;charset=utf-8,&quot; + encodeURIComponent(sXml), false);
-            xmlhttp.send(null);
-            return xmlhttp.responseXML;
-        };
-    }else if(Sarissa.getDomDocument &amp;&amp; Sarissa.getDomDocument() &amp;&amp; Sarissa.getDomDocument(null, &quot;bar&quot;).xml){
-        DOMParser = function() { };
-        DOMParser.prototype.parseFromString = function(sXml, contentType){
-            var doc = Sarissa.getDomDocument();
-            doc.loadXML(sXml);
-            return doc;
-        };
-    };
-};
-
-if((typeof(document.importNode) == &quot;undefined&quot;) &amp;&amp; _SARISSA_IS_IE){
-    try{
-        /**
-        * Implementation of importNode for the context window document in IE
-        * @param oNode the Node to import
-        * @param bChildren whether to include the children of oNode
-        * @returns the imported node for further use
-        */
-        document.importNode = function(oNode, bChildren){
-            var tmp;
-            if(oNode.nodeName == &quot;tbody&quot; || oNode.nodeName == &quot;tr&quot;){
-                tmp = document.createElement(&quot;table&quot;);
-            }
-            else if(oNode.nodeName == &quot;td&quot;){
-                tmp = document.createElement(&quot;tr&quot;);
-            }
-            else if(oNode.nodeName == &quot;option&quot;){
-                tmp = document.createElement(&quot;select&quot;);
-            }
-            else{
-                tmp = document.createElement(&quot;div&quot;);
-            };
-            if(bChildren){
-                tmp.innerHTML = oNode.xml ? oNode.xml : oNode.outerHTML;
-            }else{
-                tmp.innerHTML = oNode.xml ? oNode.cloneNode(false).xml : oNode.cloneNode(false).outerHTML;
-            };
-            return tmp.getElementsByTagName(&quot;*&quot;)[0];
-        };
-    }catch(e){ };
-};
-if(!Sarissa.getParseErrorText){
-    /**
-     * &lt;p&gt;Returns a human readable description of the parsing error. Usefull
-     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
-     * element if you want to render it.&lt;/p&gt;
-     * &lt;p&gt;Many thanks to Christian Stocker for the initial patch.&lt;/p&gt;
-     * @argument oDoc The target DOM document
-     * @returns The parsing error description of the target Document in
-     *          human readable form (preformated text)
-     */
-    Sarissa.getParseErrorText = function (oDoc){
-        var parseErrorText = Sarissa.PARSED_OK;
-        if(!oDoc.documentElement){
-            parseErrorText = Sarissa.PARSED_EMPTY;
-        } else if(oDoc.documentElement.tagName == &quot;parsererror&quot;){
-            parseErrorText = oDoc.documentElement.firstChild.data;
-            parseErrorText += &quot;\n&quot; +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
-        } else if(oDoc.getElementsByTagName(&quot;parsererror&quot;).length &gt; 0){
-            var parsererror = oDoc.getElementsByTagName(&quot;parsererror&quot;)[0];
-            parseErrorText = Sarissa.getText(parsererror, true)+&quot;\n&quot;;
-        } else if(oDoc.parseError &amp;&amp; oDoc.parseError.errorCode != 0){
-            parseErrorText = Sarissa.PARSED_UNKNOWN_ERROR;
-        };
-        return parseErrorText;
-    };
-};
-Sarissa.getText = function(oNode, deep){
-    var s = &quot;&quot;;
-    var nodes = oNode.childNodes;
-    for(var i=0; i &lt; nodes.length; i++){
-        var node = nodes[i];
-        var nodeType = node.nodeType;
-        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
-            s += node.data;
-        } else if(deep == true
-                    &amp;&amp; (nodeType == Node.ELEMENT_NODE
-                        || nodeType == Node.DOCUMENT_NODE
-                        || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
-            s += Sarissa.getText(node, true);
-        };
-    };
-    return s;
-};
-if(!window.XMLSerializer 
-    &amp;&amp; Sarissa.getDomDocument 
-    &amp;&amp; Sarissa.getDomDocument(&quot;&quot;,&quot;foo&quot;, null).xml){
-    /**
-     * Utility class to serialize DOM Node objects to XML strings
-     * @constructor
-     */
-    XMLSerializer = function(){};
-    /**
-     * Serialize the given DOM Node to an XML string
-     * @param oNode the DOM Node to serialize
-     */
-    XMLSerializer.prototype.serializeToString = function(oNode) {
-        return oNode.xml;
-    };
-};
-
-/**
- * strips tags from a markup string
- */
-Sarissa.stripTags = function (s) {
-    return s.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;);
-};
-/**
- * &lt;p&gt;Deletes all child nodes of the given node&lt;/p&gt;
- * @argument oNode the Node to empty
- */
-Sarissa.clearChildNodes = function(oNode) {
-    // need to check for firstChild due to opera 8 bug with hasChildNodes
-    while(oNode.firstChild) {
-        oNode.removeChild(oNode.firstChild);
-    };
-};
-/**
- * &lt;p&gt; Copies the childNodes of nodeFrom to nodeTo&lt;/p&gt;
- * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
- * the copy operation, unless you supply a true third parameter&lt;/p&gt;
- * @argument nodeFrom the Node to copy the childNodes from
- * @argument nodeTo the Node to copy the childNodes to
- * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is false
- */
-Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
-    if((!nodeFrom) || (!nodeTo)){
-        throw &quot;Both source and destination nodes must be provided&quot;;
-    };
-    if(!bPreserveExisting){
-        Sarissa.clearChildNodes(nodeTo);
-    };
-    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
-    var nodes = nodeFrom.childNodes;
-    if(typeof(ownerDoc.importNode) != &quot;undefined&quot;)  {
-        for(var i=0;i &lt; nodes.length;i++) {
-            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
-        };
-    } else {
-        for(var i=0;i &lt; nodes.length;i++) {
-            nodeTo.appendChild(nodes[i].cloneNode(true));
-        };
-    };
-};
-
-/**
- * &lt;p&gt; Moves the childNodes of nodeFrom to nodeTo&lt;/p&gt;
- * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
- * the move operation, unless you supply a true third parameter&lt;/p&gt;
- * @argument nodeFrom the Node to copy the childNodes from
- * @argument nodeTo the Node to copy the childNodes to
- * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is
- */ 
-Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
-    if((!nodeFrom) || (!nodeTo)){
-        throw &quot;Both source and destination nodes must be provided&quot;;
-    };
-    if(!bPreserveExisting){
-        Sarissa.clearChildNodes(nodeTo);
-    };
-    var nodes = nodeFrom.childNodes;
-    // if within the same doc, just move, else copy and delete
-    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
-        while(nodeFrom.firstChild){
-            nodeTo.appendChild(nodeFrom.firstChild);
-        };
-    } else {
-        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
-        if(typeof(ownerDoc.importNode) != &quot;undefined&quot;) {
-           for(var i=0;i &lt; nodes.length;i++) {
-               nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
-           };
-        }else{
-           for(var i=0;i &lt; nodes.length;i++) {
-               nodeTo.appendChild(nodes[i].cloneNode(true));
-           };
-        };
-        Sarissa.clearChildNodes(nodeFrom);
-    };
-};
-
-/** 
- * &lt;p&gt;Serialize any object to an XML string. All properties are serialized using the property name
- * as the XML element name. Array elements are rendered as &lt;code&gt;array-item&lt;/code&gt; elements, 
- * using their index/key as the value of the &lt;code&gt;key&lt;/code&gt; attribute.&lt;/p&gt;
- * @argument anyObject the object to serialize
- * @argument objectName a name for that object
- * @return the XML serializationj of the given object as a string
- */
-Sarissa.xmlize = function(anyObject, objectName, indentSpace){
-    indentSpace = indentSpace?indentSpace:'';
-    var s = indentSpace  + '&lt;' + objectName + '&gt;';
-    var isLeaf = false;
-    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String 
-        || anyObject instanceof Boolean || anyObject instanceof Date){
-        s += Sarissa.escape(&quot;&quot;+anyObject);
-        isLeaf = true;
-    }else{
-        s += &quot;\n&quot;;
-        var itemKey = '';
-        var isArrayItem = anyObject instanceof Array;
-        for(var name in anyObject){
-            s += Sarissa.xmlize(anyObject[name], (isArrayItem?&quot;array-item key=\&quot;&quot;+name+&quot;\&quot;&quot;:name), indentSpace + &quot;   &quot;);
-        };
-        s += indentSpace;
-    };
-    return s += (objectName.indexOf(' ')!=-1?&quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot; + objectName + &quot;&gt;\n&quot;);
-};
-
-/** 
- * Escape the given string chacters that correspond to the five predefined XML entities
- * @param sXml the string to escape
- */
-Sarissa.escape = function(sXml){
-    return sXml.replace(/&amp;/g, &quot;&amp;&quot;)
-        .replace(/&lt;/g, &quot;&lt;&quot;)
-        .replace(/&gt;/g, &quot;&gt;&quot;)
-        .replace(/&quot;/g, &quot;&quot;&quot;)
-        .replace(/'/g, &quot;&apos;&quot;);
-};
-
-/** 
- * Unescape the given string. This turns the occurences of the predefined XML 
- * entities to become the characters they represent correspond to the five predefined XML entities
- * @param sXml the string to unescape
- */
-Sarissa.unescape = function(sXml){
-    return sXml.replace(/&apos;/g,&quot;'&quot;)
-        .replace(/&quot;/g,&quot;\&quot;&quot;)
-        .replace(/&gt;/g,&quot;&gt;&quot;)
-        .replace(/&lt;/g,&quot;&lt;&quot;)
-        .replace(/&amp;/g,&quot;&amp;&quot;);
-};
-//   EOF
+/**
+ * ====================================================================
+ * About
+ * ====================================================================
+ * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
+ * The library supports Gecko based browsers like Mozilla and Firefox,
+ * Internet Explorer (5.5+ with MSXML3.0+), Konqueror, Safari and a little of Opera
+ * @version @sarissa.version@
+ * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
+ * ====================================================================
+ * Licence
+ * ====================================================================
+ * Sarissa is free software distributed under the GNU GPL version 2 (see &lt;a href=&quot;gpl.txt&quot;&gt;gpl.txt&lt;/a&gt;) or higher, 
+ * GNU LGPL version 2.1 (see &lt;a href=&quot;lgpl.txt&quot;&gt;lgpl.txt&lt;/a&gt;) or higher and Apache Software License 2.0 or higher 
+ * (see &lt;a href=&quot;asl.txt&quot;&gt;asl.txt&lt;/a&gt;). This means you can choose one of the three and use that if you like. If 
+ * you make modifications under the ASL, i would appreciate it if you submitted those.
+ * In case your copy of Sarissa does not include the license texts, you may find
+ * them online in various formats at &lt;a href=&quot;<A HREF="http://www.gnu.org">http://www.gnu.org</A>&quot;&gt;<A HREF="http://www.gnu.org&lt;/a">http://www.gnu.org&lt;/a</A>&gt; and 
+ * &lt;a href=&quot;<A HREF="http://www.apache.org">http://www.apache.org</A>&quot;&gt;<A HREF="http://www.apache.org&lt;/a">http://www.apache.org&lt;/a</A>&gt;.
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY 
+ * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
+ * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
+ * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+/**
+ * &lt;p&gt;Sarissa is a utility class. Provides &quot;static&quot; methods for DOMDocument, 
+ * DOM Node serialization to XML strings and other utility goodies.&lt;/p&gt;
+ * @constructor
+ */
+function Sarissa(){};
+Sarissa.PARSED_OK = &quot;Document contains no parsing errors&quot;;
+Sarissa.PARSED_EMPTY = &quot;Document is empty&quot;;
+Sarissa.PARSED_UNKNOWN_ERROR = &quot;Not well-formed or other error&quot;;
+var _sarissa_iNsCounter = 0;
+var _SARISSA_IEPREFIX4XSLPARAM = &quot;&quot;;
+var _SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation &amp;&amp; true;
+var _SARISSA_HAS_DOM_CREATE_DOCUMENT = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.createDocument;
+var _SARISSA_HAS_DOM_FEATURE = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.hasFeature;
+var _SARISSA_IS_MOZ = _SARISSA_HAS_DOM_CREATE_DOCUMENT &amp;&amp; _SARISSA_HAS_DOM_FEATURE;
+var _SARISSA_IS_SAFARI = (navigator.userAgent &amp;&amp; navigator.vendor &amp;&amp; (navigator.userAgent.toLowerCase().indexOf(&quot;applewebkit&quot;) != -1 || navigator.vendor.indexOf(&quot;Apple&quot;) != -1));
+var _SARISSA_IS_IE = document.all &amp;&amp; window.ActiveXObject &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;) &gt; -1  &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;opera&quot;) == -1;
+if(!window.Node || !Node.ELEMENT_NODE){
+    Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
+};
+
+if(typeof XMLDocument == &quot;undefined&quot; &amp;&amp; typeof Document !=&quot;undefined&quot;){ XMLDocument = Document; } 
+
+// IE initialization
+if(_SARISSA_IS_IE){
+    // for XSLT parameter names, prefix needed by IE
+    _SARISSA_IEPREFIX4XSLPARAM = &quot;xsl:&quot;;
+    // used to store the most recent ProgID available out of the above
+    var _SARISSA_DOM_PROGID = &quot;&quot;;
+    var _SARISSA_XMLHTTP_PROGID = &quot;&quot;;
+    var _SARISSA_DOM_XMLWRITER = &quot;&quot;;
+    /**
+     * Called when the Sarissa_xx.js file is parsed, to pick most recent
+     * ProgIDs for IE, then gets destroyed.
+     * @private
+     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
+     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
+     */
+    Sarissa.pickRecentProgID = function (idList){
+        // found progID flag
+        var bFound = false;
+        for(var i=0; i &lt; idList.length &amp;&amp; !bFound; i++){
+            try{
+                var oDoc = new ActiveXObject(idList[i]);
+                o2Store = idList[i];
+                bFound = true;
+            }catch (objException){
+                // trap; try next progID
+            };
+        };
+        if (!bFound) {
+            throw &quot;Could not retreive a valid progID of Class: &quot; + idList[idList.length-1]+&quot;. (original exception: &quot;+e+&quot;)&quot;;
+        };
+        idList = null;
+        return o2Store;
+    };
+    // pick best available MSXML progIDs
+    _SARISSA_DOM_PROGID = null;
+    _SARISSA_THREADEDDOM_PROGID = null;
+    _SARISSA_XSLTEMPLATE_PROGID = null;
+    _SARISSA_XMLHTTP_PROGID = null;
+    if(!window.XMLHttpRequest){
+        /**
+         * Emulate XMLHttpRequest
+         * @constructor
+         */
+        XMLHttpRequest = function() {
+            if(!_SARISSA_XMLHTTP_PROGID){
+                _SARISSA_XMLHTTP_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XMLHTTP.6.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]);
+            };
+            return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
+        };
+    };
+    // we dont need this anymore
+    //============================================
+    // Factory methods (IE)
+    //============================================
+    // see non-IE version
+    Sarissa.getDomDocument = function(sUri, sName){
+        if(!_SARISSA_DOM_PROGID){
+            _SARISSA_DOM_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.DOMDocument.6.0&quot;, &quot;Msxml2.DOMDocument.3.0&quot;, &quot;MSXML2.DOMDocument&quot;, &quot;MSXML.DOMDocument&quot;, &quot;Microsoft.XMLDOM&quot;]);
+        };
+        var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+        // if a root tag name was provided, we need to load it in the DOM object
+        if (sName){
+            // create an artifical namespace prefix 
+            // or reuse existing prefix if applicable
+            var prefix = &quot;&quot;;
+            if(sUri){
+                if(sName.indexOf(&quot;:&quot;) &gt; 1){
+                    prefix = sName.substring(0, sName.indexOf(&quot;:&quot;));
+                    sName = sName.substring(sName.indexOf(&quot;:&quot;)+1); 
+                }else{
+                    prefix = &quot;a&quot; + (_sarissa_iNsCounter++);
+                };
+            };
+            // use namespaces if a namespace URI exists
+            if(sUri){
+                oDoc.loadXML('&lt;' + prefix+':'+sName + &quot; xmlns:&quot; + prefix + &quot;=\&quot;&quot; + sUri + &quot;\&quot;&quot; + &quot; /&gt;&quot;);
+            } else {
+                oDoc.loadXML('&lt;' + sName + &quot; /&gt;&quot;);
+            };
+        };
+        return oDoc;
+    };
+    // see non-IE version   
+    Sarissa.getParseErrorText = function (oDoc) {
+        var parseErrorText = Sarissa.PARSED_OK;
+        if(oDoc.parseError.errorCode != 0){
+            parseErrorText = &quot;XML Parsing Error: &quot; + oDoc.parseError.reason + 
+                &quot;\nLocation: &quot; + oDoc.parseError.url + 
+                &quot;\nLine Number &quot; + oDoc.parseError.line + &quot;, Column &quot; + 
+                oDoc.parseError.linepos + 
+                &quot;:\n&quot; + oDoc.parseError.srcText +
+                &quot;\n&quot;;
+            for(var i = 0;  i &lt; oDoc.parseError.linepos;i++){
+                parseErrorText += &quot;-&quot;;
+            };
+            parseErrorText +=  &quot;^\n&quot;;
+        }
+        else if(oDoc.documentElement == null){
+            parseErrorText = Sarissa.PARSED_EMPTY;
+        };
+        return parseErrorText;
+    };
+    // see non-IE version
+    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
+        oDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
+        oDoc.setProperty(&quot;SelectionNamespaces&quot;, sNsSet);
+    };   
+    /**
+     * Basic implementation of Mozilla's XSLTProcessor for IE. 
+     * Reuses the same XSLT stylesheet for multiple transforms
+     * @constructor
+     */
+    XSLTProcessor = function(){
+        if(!_SARISSA_XSLTEMPLATE_PROGID){
+            _SARISSA_XSLTEMPLATE_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XSLTemplate.6.0&quot;, &quot;MSXML2.XSLTemplate.3.0&quot;]);
+        };
+        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
+        this.processor = null;
+    };
+    /**
+     * Imports the given XSLT DOM and compiles it to a reusable transform
+     * &lt;b&gt;Note:&lt;/b&gt; If the stylesheet was loaded from a URL and contains xsl:import or xsl:include elements,it will be reloaded to resolve those
+     * @argument xslDoc The XSLT DOMDocument to import
+     */
+    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
+        if(!_SARISSA_THREADEDDOM_PROGID){
+            _SARISSA_THREADEDDOM_PROGID = Sarissa.pickRecentProgID([&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;, &quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
+        };
+        xslDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
+        xslDoc.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+        // convert stylesheet to free threaded
+        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
+        // make included/imported stylesheets work if exist and xsl was originally loaded from url
+        if(xslDoc.url &amp;&amp; xslDoc.selectSingleNode(&quot;//xsl:*[local-name() = 'import' or local-name() = 'include']&quot;) != null){
+            converted.async = false;
+            if (_SARISSA_THREADEDDOM_PROGID == &quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;) { 
+                converted.setProperty(&quot;AllowDocumentFunction&quot;, true); 
+                converted.resolveExternals = true; 
+            }
+            converted.load(xslDoc.url);
+        } else {
+            converted.loadXML(xslDoc.xml);
+        };
+        converted.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+        var output = converted.selectSingleNode(&quot;//xsl:output&quot;);
+        this.outputMethod = output ? output.getAttribute(&quot;method&quot;) : &quot;html&quot;;
+        this.template.stylesheet = converted;
+        this.processor = this.template.createProcessor();
+        // for getParameter and clearParameters
+        this.paramsSet = new Array();
+    };
+
+    /**
+     * Transform the given XML DOM and return the transformation result as a new DOM document
+     * @argument sourceDoc The XML DOMDocument to transform
+     * @return The transformation result as a DOM Document
+     */
+    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
+        // fix for bug 1549749
+        if(_SARISSA_THREADEDDOM_PROGID){
+            this.processor.input=sourceDoc;
+            var outDoc=new ActiveXObject(_SARISSA_DOM_PROGID);
+            this.processor.output=outDoc;
+            this.processor.transform();
+            return outDoc;
+        }
+        else{
+            if(!_SARISSA_DOM_XMLWRITER){
+                _SARISSA_DOM_XMLWRITER = Sarissa.pickRecentProgID([&quot;Msxml2.MXXMLWriter.6.0&quot;, &quot;Msxml2.MXXMLWriter.3.0&quot;, &quot;MSXML2.MXXMLWriter&quot;, &quot;MSXML.MXXMLWriter&quot;, &quot;Microsoft.XMLDOM&quot;]);
+            };
+            this.processor.input = sourceDoc;
+            var outDoc = new ActiveXObject(_SARISSA_DOM_XMLWRITER);
+            this.processor.output = outDoc; 
+            this.processor.transform();
+            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+            oDoc.loadXML(outDoc.output+&quot;&quot;);
+            return oDoc;
+        };
+    };
+    
+    /**
+     * Transform the given XML DOM and return the transformation result as a new DOM fragment.
+     * &lt;b&gt;Note&lt;/b&gt;: The xsl:output method must match the nature of the owner document (XML/HTML).
+     * @argument sourceDoc The XML DOMDocument to transform
+     * @argument ownerDoc The owner of the result fragment
+     * @return The transformation result as a DOM Document
+     */
+    XSLTProcessor.prototype.transformToFragment = function (sourceDoc, ownerDoc) {
+        this.processor.input = sourceDoc;
+        this.processor.transform();
+        var s = this.processor.output;
+        var f = ownerDoc.createDocumentFragment();
+        if (this.outputMethod == 'text') {
+            f.appendChild(ownerDoc.createTextNode(s));
+        } else if (ownerDoc.body &amp;&amp; ownerDoc.body.innerHTML) {
+            var container = ownerDoc.createElement('div');
+            container.innerHTML = s;
+            while (container.hasChildNodes()) {
+                f.appendChild(container.firstChild);
+            }
+        }
+        else {
+            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+            if (s.substring(0, 5) == '&lt;?xml') {
+                s = s.substring(s.indexOf('?&gt;') + 2);
+            }
+            var xml = ''.concat('&lt;my&gt;', s, '&lt;/my&gt;');
+            oDoc.loadXML(xml);
+            var container = oDoc.documentElement;
+            while (container.hasChildNodes()) {
+                f.appendChild(container.firstChild);
+            }
+        }
+        return f;
+    };
+    
+    /**
+     * Set global XSLT parameter of the imported stylesheet
+     * @argument nsURI The parameter namespace URI
+     * @argument name The parameter base name
+     * @argument value The new parameter value
+     */
+    XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
+        // make value a zero length string if null to allow clearing
+        value = (value) ? value : &quot;&quot;;
+        // nsURI is optional but cannot be null 
+        if(nsURI){
+            this.processor.addParameter(name, value, nsURI);
+        }else{
+            this.processor.addParameter(name, value);
+        };
+        // update updated params for getParameter 
+        if(!this.paramsSet[&quot;&quot;+nsURI]){
+            this.paramsSet[&quot;&quot;+nsURI] = new Array();
+        };
+        this.paramsSet[&quot;&quot;+nsURI][name] = value;
+    };
+    /**
+     * Gets a parameter if previously set by setParameter. Returns null
+     * otherwise
+     * @argument name The parameter base name
+     * @argument value The new parameter value
+     * @return The parameter value if reviously set by setParameter, null otherwise
+     */
+    XSLTProcessor.prototype.getParameter = function(nsURI, name){
+        nsURI = nsURI || &quot;&quot;;
+        if(this.paramsSet[nsURI] &amp;&amp; this.paramsSet[nsURI][name]){
+            return this.paramsSet[nsURI][name];
+        }else{
+            return null;
+        };
+    };
+    /**
+     * Clear parameters (set them to default values as defined in the stylesheet itself)
+     */
+    XSLTProcessor.prototype.clearParameters = function(){
+        for(var nsURI in this.paramsSet){
+            for(var name in this.paramsSet[nsURI]){
+                if(nsURI){
+                    this.processor.addParameter(name, &quot;&quot;, nsURI);
+                }else{
+                    this.processor.addParameter(name, &quot;&quot;);
+                };
+            };
+        };
+        this.paramsSet = new Array();
+    };
+}else{ /* end IE initialization, try to deal with real browsers now ;-) */
+    if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
+        /**
+         * &lt;p&gt;Ensures the document was loaded correctly, otherwise sets the
+         * parseError to -1 to indicate something went wrong. Internal use&lt;/p&gt;
+         * @private
+         */
+        Sarissa.__handleLoad__ = function(oDoc){
+            Sarissa.__setReadyState__(oDoc, 4);
+        };
+        /**
+        * &lt;p&gt;Attached by an event handler to the load event. Internal use.&lt;/p&gt;
+        * @private
+        */
+        _sarissa_XMLDocument_onload = function(){
+            Sarissa.__handleLoad__(this);
+        };
+        /**
+         * &lt;p&gt;Sets the readyState property of the given DOM Document object.
+         * Internal use.&lt;/p&gt;
+         * @private
+         * @argument oDoc the DOM Document object to fire the
+         *          readystatechange event
+         * @argument iReadyState the number to change the readystate property to
+         */
+        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
+            oDoc.readyState = iReadyState;
+            oDoc.readystate = iReadyState;
+            if (oDoc.onreadystatechange != null &amp;&amp; typeof oDoc.onreadystatechange == &quot;function&quot;)
+                oDoc.onreadystatechange();
+        };
+        Sarissa.getDomDocument = function(sUri, sName){
+            var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+            if(!oDoc.onreadystatechange){
+            
+                /**
+                * &lt;p&gt;Emulate IE's onreadystatechange attribute&lt;/p&gt;
+                */
+                oDoc.onreadystatechange = null;
+            };
+            if(!oDoc.readyState){
+                /**
+                * &lt;p&gt;Emulates IE's readyState property, which always gives an integer from 0 to 4:&lt;/p&gt;
+                * &lt;ul&gt;&lt;li&gt;1 == LOADING,&lt;/li&gt;
+                * &lt;li&gt;2 == LOADED,&lt;/li&gt;
+                * &lt;li&gt;3 == INTERACTIVE,&lt;/li&gt;
+                * &lt;li&gt;4 == COMPLETED&lt;/li&gt;&lt;/ul&gt;
+                */
+                oDoc.readyState = 0;
+            };
+            oDoc.addEventListener(&quot;load&quot;, _sarissa_XMLDocument_onload, false);
+            return oDoc;
+        };
+        if(window.XMLDocument){
+            // do nothing
+        }// TODO: check if the new document has content before trying to copynodes, check  for error handling in DOM 3 LS
+        else if(_SARISSA_HAS_DOM_FEATURE &amp;&amp; window.Document &amp;&amp; !Document.prototype.load &amp;&amp; document.implementation.hasFeature('LS', '3.0')){
+    		//Opera 9 may get the XPath branch which gives creates XMLDocument, therefore it doesn't reach here which is good
+            /**
+            * &lt;p&gt;Factory method to obtain a new DOM Document object&lt;/p&gt;
+            * @argument sUri the namespace of the root node (if any)
+            * @argument sUri the local name of the root node (if any)
+            * @returns a new DOM Document
+            */
+            Sarissa.getDomDocument = function(sUri, sName){
+                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+                return oDoc;
+            };
+        }
+        else {
+            Sarissa.getDomDocument = function(sUri, sName){
+                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+                // looks like safari does not create the root element for some unknown reason
+                if(oDoc &amp;&amp; (sUri || sName) &amp;&amp; !oDoc.documentElement){
+                    oDoc.appendChild(oDoc.createElementNS(sUri, sName));
+                };
+                return oDoc;
+            };
+        };
+    };//if(_SARISSA_HAS_DOM_CREATE_DOCUMENT)
+};
+//==========================================
+// Common stuff
+//==========================================
+if(!window.DOMParser){
+    if(_SARISSA_IS_SAFARI){
+        /*
+         * DOMParser is a utility class, used to construct DOMDocuments from XML strings
+         * @constructor
+         */
+        DOMParser = function() { };
+        /** 
+        * Construct a new DOM Document from the given XMLstring
+        * @param sXml the given XML string
+        * @param contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml). 
+        * @return a new DOM Document from the given XML string
+        */
+        DOMParser.prototype.parseFromString = function(sXml, contentType){
+            var xmlhttp = new XMLHttpRequest();
+            xmlhttp.open(&quot;GET&quot;, &quot;data:text/xml;charset=utf-8,&quot; + encodeURIComponent(sXml), false);
+            xmlhttp.send(null);
+            return xmlhttp.responseXML;
+        };
+    }else if(Sarissa.getDomDocument &amp;&amp; Sarissa.getDomDocument() &amp;&amp; Sarissa.getDomDocument(null, &quot;bar&quot;).xml){
+        DOMParser = function() { };
+        DOMParser.prototype.parseFromString = function(sXml, contentType){
+            var doc = Sarissa.getDomDocument();
+            doc.loadXML(sXml);
+            return doc;
+        };
+    };
+};
+
+if((typeof(document.importNode) == &quot;undefined&quot;) &amp;&amp; _SARISSA_IS_IE){
+    try{
+        /**
+        * Implementation of importNode for the context window document in IE.
+        * If &lt;code&gt;oNode&lt;/code&gt; is a TextNode, &lt;code&gt;bChildren&lt;/code&gt; is ignored.
+        * @param oNode the Node to import
+        * @param bChildren whether to include the children of oNode
+        * @returns the imported node for further use
+        */
+        document.importNode = function(oNode, bChildren){
+            var tmp;
+            if (oNode.nodeName=='#text') {
+                return document.createTextElement(oNode.data);
+            }
+            else {
+                if(oNode.nodeName == &quot;tbody&quot; || oNode.nodeName == &quot;tr&quot;){
+                    tmp = document.createElement(&quot;table&quot;);
+                }
+                else if(oNode.nodeName == &quot;td&quot;){
+                    tmp = document.createElement(&quot;tr&quot;);
+                }
+                else if(oNode.nodeName == &quot;option&quot;){
+                    tmp = document.createElement(&quot;select&quot;);
+                }
+                else{
+                    tmp = document.createElement(&quot;div&quot;);
+                };
+                if(bChildren){
+                    tmp.innerHTML = oNode.xml ? oNode.xml : oNode.outerHTML;
+                }else{
+                    tmp.innerHTML = oNode.xml ? oNode.cloneNode(false).xml : oNode.cloneNode(false).outerHTML;
+                };
+                return tmp.getElementsByTagName(&quot;*&quot;)[0];
+            };
+            
+        };
+    }catch(e){ };
+};
+if(!Sarissa.getParseErrorText){
+    /**
+     * &lt;p&gt;Returns a human readable description of the parsing error. Usefull
+     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
+     * element if you want to render it.&lt;/p&gt;
+     * &lt;p&gt;Many thanks to Christian Stocker for the initial patch.&lt;/p&gt;
+     * @argument oDoc The target DOM document
+     * @returns The parsing error description of the target Document in
+     *          human readable form (preformated text)
+     */
+    Sarissa.getParseErrorText = function (oDoc){
+        var parseErrorText = Sarissa.PARSED_OK;
+        if(!oDoc.documentElement){
+            parseErrorText = Sarissa.PARSED_EMPTY;
+        } else if(oDoc.documentElement.tagName == &quot;parsererror&quot;){
+            parseErrorText = oDoc.documentElement.firstChild.data;
+            parseErrorText += &quot;\n&quot; +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
+        } else if(oDoc.getElementsByTagName(&quot;parsererror&quot;).length &gt; 0){
+            var parsererror = oDoc.getElementsByTagName(&quot;parsererror&quot;)[0];
+            parseErrorText = Sarissa.getText(parsererror, true)+&quot;\n&quot;;
+        } else if(oDoc.parseError &amp;&amp; oDoc.parseError.errorCode != 0){
+            parseErrorText = Sarissa.PARSED_UNKNOWN_ERROR;
+        };
+        return parseErrorText;
+    };
+};
+Sarissa.getText = function(oNode, deep){
+    var s = &quot;&quot;;
+    var nodes = oNode.childNodes;
+    for(var i=0; i &lt; nodes.length; i++){
+        var node = nodes[i];
+        var nodeType = node.nodeType;
+        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
+            s += node.data;
+        } else if(deep == true
+                    &amp;&amp; (nodeType == Node.ELEMENT_NODE
+                        || nodeType == Node.DOCUMENT_NODE
+                        || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
+            s += Sarissa.getText(node, true);
+        };
+    };
+    return s;
+};
+if(!window.XMLSerializer 
+    &amp;&amp; Sarissa.getDomDocument 
+    &amp;&amp; Sarissa.getDomDocument(&quot;&quot;,&quot;foo&quot;, null).xml){
+    /**
+     * Utility class to serialize DOM Node objects to XML strings
+     * @constructor
+     */
+    XMLSerializer = function(){};
+    /**
+     * Serialize the given DOM Node to an XML string
+     * @param oNode the DOM Node to serialize
+     */
+    XMLSerializer.prototype.serializeToString = function(oNode) {
+        return oNode.xml;
+    };
+};
+
+/**
+ * strips tags from a markup string
+ */
+Sarissa.stripTags = function (s) {
+    return s.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;);
+};
+/**
+ * &lt;p&gt;Deletes all child nodes of the given node&lt;/p&gt;
+ * @argument oNode the Node to empty
+ */
+Sarissa.clearChildNodes = function(oNode) {
+    // need to check for firstChild due to opera 8 bug with hasChildNodes
+    while(oNode.firstChild) {
+        oNode.removeChild(oNode.firstChild);
+    };
+};
+/**
+ * &lt;p&gt; Copies the childNodes of nodeFrom to nodeTo&lt;/p&gt;
+ * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
+ * the copy operation, unless you supply a true third parameter&lt;/p&gt;
+ * @argument nodeFrom the Node to copy the childNodes from
+ * @argument nodeTo the Node to copy the childNodes to
+ * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is false
+ */
+Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
+    if((!nodeFrom) || (!nodeTo)){
+        throw &quot;Both source and destination nodes must be provided&quot;;
+    };
+    if(!bPreserveExisting){
+        Sarissa.clearChildNodes(nodeTo);
+    };
+    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
+    var nodes = nodeFrom.childNodes;
+    if(typeof(ownerDoc.importNode) != &quot;undefined&quot;)  {
+        for(var i=0;i &lt; nodes.length;i++) {
+            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
+        };
+    } else {
+        for(var i=0;i &lt; nodes.length;i++) {
+            nodeTo.appendChild(nodes[i].cloneNode(true));
+        };
+    };
+};
+
+/**
+ * &lt;p&gt; Moves the childNodes of nodeFrom to nodeTo&lt;/p&gt;
+ * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
+ * the move operation, unless you supply a true third parameter&lt;/p&gt;
+ * @argument nodeFrom the Node to copy the childNodes from
+ * @argument nodeTo the Node to copy the childNodes to
+ * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is
+ */ 
+Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
+    if((!nodeFrom) || (!nodeTo)){
+        throw &quot;Both source and destination nodes must be provided&quot;;
+    };
+    if(!bPreserveExisting){
+        Sarissa.clearChildNodes(nodeTo);
+    };
+    var nodes = nodeFrom.childNodes;
+    // if within the same doc, just move, else copy and delete
+    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
+        while(nodeFrom.firstChild){
+            nodeTo.appendChild(nodeFrom.firstChild);
+        };
+    } else {
+        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
+        if(typeof(ownerDoc.importNode) != &quot;undefined&quot;) {
+           for(var i=0;i &lt; nodes.length;i++) {
+               nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
+           };
+        }else{
+           for(var i=0;i &lt; nodes.length;i++) {
+               nodeTo.appendChild(nodes[i].cloneNode(true));
+           };
+        };
+        Sarissa.clearChildNodes(nodeFrom);
+    };
+};
+
+/** 
+ * &lt;p&gt;Serialize any object to an XML string. All properties are serialized using the property name
+ * as the XML element name. Array elements are rendered as &lt;code&gt;array-item&lt;/code&gt; elements, 
+ * using their index/key as the value of the &lt;code&gt;key&lt;/code&gt; attribute.&lt;/p&gt;
+ * @argument anyObject the object to serialize
+ * @argument objectName a name for that object
+ * @return the XML serializationj of the given object as a string
+ */
+Sarissa.xmlize = function(anyObject, objectName, indentSpace){
+    indentSpace = indentSpace?indentSpace:'';
+    var s = indentSpace  + '&lt;' + objectName + '&gt;';
+    var isLeaf = false;
+    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String 
+        || anyObject instanceof Boolean || anyObject instanceof Date){
+        s += Sarissa.escape(&quot;&quot;+anyObject);
+        isLeaf = true;
+    }else{
+        s += &quot;\n&quot;;
+        var itemKey = '';
+        var isArrayItem = anyObject instanceof Array;
+        for(var name in anyObject){
+            s += Sarissa.xmlize(anyObject[name], (isArrayItem?&quot;array-item key=\&quot;&quot;+name+&quot;\&quot;&quot;:name), indentSpace + &quot;   &quot;);
+        };
+        s += indentSpace;
+    };
+    return s += (objectName.indexOf(' ')!=-1?&quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot; + objectName + &quot;&gt;\n&quot;);
+};
+
+/** 
+ * Escape the given string chacters that correspond to the five predefined XML entities
+ * @param sXml the string to escape
+ */
+Sarissa.escape = function(sXml){
+    return sXml.replace(/&amp;/g, &quot;&amp;&quot;)
+        .replace(/&lt;/g, &quot;&lt;&quot;)
+        .replace(/&gt;/g, &quot;&gt;&quot;)
+        .replace(/&quot;/g, &quot;&quot;&quot;)
+        .replace(/'/g, &quot;&apos;&quot;);
+};
+
+/** 
+ * Unescape the given string. This turns the occurences of the predefined XML 
+ * entities to become the characters they represent correspond to the five predefined XML entities
+ * @param sXml the string to unescape
+ */
+Sarissa.unescape = function(sXml){
+    return sXml.replace(/&apos;/g,&quot;'&quot;)
+        .replace(/&quot;/g,&quot;\&quot;&quot;)
+        .replace(/&gt;/g,&quot;&gt;&quot;)
+        .replace(/&lt;/g,&quot;&lt;&quot;)
+        .replace(/&amp;/g,&quot;&amp;&quot;);
+};
+//   EOF

Added: branch/2.0.1/lib/Sarissa_pack.js
===================================================================
--- branch/2.0.1/lib/Sarissa_pack.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/lib/Sarissa_pack.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -0,0 +1,425 @@
+function Sarissa(){
+}
+Sarissa.PARSED_OK=&quot;Document contains no parsing errors&quot;;
+Sarissa.PARSED_EMPTY=&quot;Document is empty&quot;;
+Sarissa.PARSED_UNKNOWN_ERROR=&quot;Not well-formed or other error&quot;;
+var _sarissa_iNsCounter=0;
+var _SARISSA_IEPREFIX4XSLPARAM=&quot;&quot;;
+var _SARISSA_HAS_DOM_IMPLEMENTATION=document.implementation&amp;&true;
+var _SARISSA_HAS_DOM_CREATE_DOCUMENT=_SARISSA_HAS_DOM_IMPLEMENTATION&amp;&amp;document.implementation.createDocument;
+var _SARISSA_HAS_DOM_FEATURE=_SARISSA_HAS_DOM_IMPLEMENTATION&amp;&amp;document.implementation.hasFeature;
+var _SARISSA_IS_MOZ=_SARISSA_HAS_DOM_CREATE_DOCUMENT&amp;&amp;_SARISSA_HAS_DOM_FEATURE;
+var _SARISSA_IS_SAFARI=(navigator.userAgent&amp;&amp;navigator.vendor&amp;&amp;(navigator.userAgent.toLowerCase().indexOf(&quot;applewebkit&quot;)!=-1||navigator.vendor.indexOf(&quot;Apple&quot;)!=-1));
+var _SARISSA_IS_IE=document.all&amp;&amp;window.ActiveXObject&amp;&amp;navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;)&gt;-1&amp;&amp;navigator.userAgent.toLowerCase().indexOf(&quot;opera&quot;)==-1;
+if(!window.Node||!Node.ELEMENT_NODE){
+Node={ELEMENT_NODE:1,ATTRIBUTE_NODE:2,TEXT_NODE:3,CDATA_SECTION_NODE:4,ENTITY_REFERENCE_NODE:5,ENTITY_NODE:6,PROCESSING_INSTRUCTION_NODE:7,COMMENT_NODE:8,DOCUMENT_NODE:9,DOCUMENT_TYPE_NODE:10,DOCUMENT_FRAGMENT_NODE:11,NOTATION_NODE:12};
+}
+if(typeof XMLDocument==&quot;undefined&quot;&amp;&amp;typeof Document!=&quot;undefined&quot;){
+XMLDocument=Document;
+}
+if(_SARISSA_IS_IE){
+_SARISSA_IEPREFIX4XSLPARAM=&quot;xsl:&quot;;
+var _SARISSA_DOM_PROGID=&quot;&quot;;
+var _SARISSA_XMLHTTP_PROGID=&quot;&quot;;
+var _SARISSA_DOM_XMLWRITER=&quot;&quot;;
+Sarissa.pickRecentProgID=function(_1){
+var _2=false;
+for(var i=0;i&lt;_1.length&amp;&amp;!_2;i++){
+try{
+var _4=new ActiveXObject(_1[i]);
+o2Store=_1[i];
+_2=true;
+}
+catch(objException){
+}
+}
+if(!_2){
+throw &quot;Could not retreive a valid progID of Class: &quot;+_1[_1.length-1]+&quot;. (original exception: &quot;+e+&quot;)&quot;;
+}
+_1=null;
+return o2Store;
+};
+_SARISSA_DOM_PROGID=null;
+_SARISSA_THREADEDDOM_PROGID=null;
+_SARISSA_XSLTEMPLATE_PROGID=null;
+_SARISSA_XMLHTTP_PROGID=null;
+if(!window.XMLHttpRequest){
+XMLHttpRequest=function(){
+if(!_SARISSA_XMLHTTP_PROGID){
+_SARISSA_XMLHTTP_PROGID=Sarissa.pickRecentProgID([&quot;Msxml2.XMLHTTP.6.0&quot;,&quot;MSXML2.XMLHTTP.3.0&quot;,&quot;MSXML2.XMLHTTP&quot;,&quot;Microsoft.XMLHTTP&quot;]);
+}
+return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
+};
+}
+Sarissa.getDomDocument=function(_5,_6){
+if(!_SARISSA_DOM_PROGID){
+_SARISSA_DOM_PROGID=Sarissa.pickRecentProgID([&quot;Msxml2.DOMDocument.6.0&quot;,&quot;Msxml2.DOMDocument.3.0&quot;,&quot;MSXML2.DOMDocument&quot;,&quot;MSXML.DOMDocument&quot;,&quot;Microsoft.XMLDOM&quot;]);
+}
+var _7=new ActiveXObject(_SARISSA_DOM_PROGID);
+if(_6){
+var _8=&quot;&quot;;
+if(_5){
+if(_6.indexOf(&quot;:&quot;)&gt;1){
+_8=_6.substring(0,_6.indexOf(&quot;:&quot;));
+_6=_6.substring(_6.indexOf(&quot;:&quot;)+1);
+}else{
+_8=&quot;a&quot;+(_sarissa_iNsCounter++);
+}
+}
+if(_5){
+_7.loadXML(&quot;&lt;&quot;+_8+&quot;:&quot;+_6+&quot; xmlns:&quot;+_8+&quot;=\&quot;&quot;+_5+&quot;\&quot;&quot;+&quot; /&gt;&quot;);
+}else{
+_7.loadXML(&quot;&lt;&quot;+_6+&quot; /&gt;&quot;);
+}
+}
+return _7;
+};
+Sarissa.getParseErrorText=function(_9){
+var _a=Sarissa.PARSED_OK;
+if(_9.parseError.errorCode!=0){
+_a=&quot;XML Parsing Error: &quot;+_9.parseError.reason+&quot;\nLocation: &quot;+_9.parseError.url+&quot;\nLine Number &quot;+_9.parseError.line+&quot;, Column &quot;+_9.parseError.linepos+&quot;:\n&quot;+_9.parseError.srcText+&quot;\n&quot;;
+for(var i=0;i&lt;_9.parseError.linepos;i++){
+_a+=&quot;-&quot;;
+}
+_a+=&quot;^\n&quot;;
+}else{
+if(_9.documentElement==null){
+_a=Sarissa.PARSED_EMPTY;
+}
+}
+return _a;
+};
+Sarissa.setXpathNamespaces=function(_c,_d){
+_c.setProperty(&quot;SelectionLanguage&quot;,&quot;XPath&quot;);
+_c.setProperty(&quot;SelectionNamespaces&quot;,_d);
+};
+XSLTProcessor=function(){
+if(!_SARISSA_XSLTEMPLATE_PROGID){
+_SARISSA_XSLTEMPLATE_PROGID=Sarissa.pickRecentProgID([&quot;Msxml2.XSLTemplate.6.0&quot;,&quot;MSXML2.XSLTemplate.3.0&quot;]);
+}
+this.template=new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
+this.processor=null;
+};
+XSLTProcessor.prototype.importStylesheet=function(_e){
+if(!_SARISSA_THREADEDDOM_PROGID){
+_SARISSA_THREADEDDOM_PROGID=Sarissa.pickRecentProgID([&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;,&quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
+}
+_e.setProperty(&quot;SelectionLanguage&quot;,&quot;XPath&quot;);
+_e.setProperty(&quot;SelectionNamespaces&quot;,&quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+var _f=new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
+if(_e.url&amp;&amp;_e.selectSingleNode(&quot;//xsl:*[local-name() = 'import' or local-name() = 'include']&quot;)!=null){
+_f.async=false;
+if(_SARISSA_THREADEDDOM_PROGID==&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;){
+_f.setProperty(&quot;AllowDocumentFunction&quot;,true);
+_f.resolveExternals=true;
+}
+_f.load(_e.url);
+}else{
+_f.loadXML(_e.xml);
+}
+_f.setProperty(&quot;SelectionNamespaces&quot;,&quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+var _10=_f.selectSingleNode(&quot;//xsl:output&quot;);
+this.outputMethod=_10?_10.getAttribute(&quot;method&quot;):&quot;html&quot;;
+this.template.stylesheet=_f;
+this.processor=this.template.createProcessor();
+this.paramsSet=new Array();
+};
+XSLTProcessor.prototype.transformToDocument=function(_11){
+if(_SARISSA_THREADEDDOM_PROGID){
+this.processor.input=_11;
+var _12=new ActiveXObject(_SARISSA_DOM_PROGID);
+this.processor.output=_12;
+this.processor.transform();
+return _12;
+}else{
+if(!_SARISSA_DOM_XMLWRITER){
+_SARISSA_DOM_XMLWRITER=Sarissa.pickRecentProgID([&quot;Msxml2.MXXMLWriter.6.0&quot;,&quot;Msxml2.MXXMLWriter.3.0&quot;,&quot;MSXML2.MXXMLWriter&quot;,&quot;MSXML.MXXMLWriter&quot;,&quot;Microsoft.XMLDOM&quot;]);
+}
+this.processor.input=_11;
+var _12=new ActiveXObject(_SARISSA_DOM_XMLWRITER);
+this.processor.output=_12;
+this.processor.transform();
+var _13=new ActiveXObject(_SARISSA_DOM_PROGID);
+_13.loadXML(_12.output+&quot;&quot;);
+return _13;
+}
+};
+XSLTProcessor.prototype.transformToFragment=function(_14,_15){
+this.processor.input=_14;
+this.processor.transform();
+var s=this.processor.output;
+var f=_15.createDocumentFragment();
+if(this.outputMethod==&quot;text&quot;){
+f.appendChild(_15.createTextNode(s));
+}else{
+if(_15.body&amp;&amp;_15.body.innerHTML){
+var _18=_15.createElement(&quot;div&quot;);
+_18.innerHTML=s;
+while(_18.hasChildNodes()){
+f.appendChild(_18.firstChild);
+}
+}else{
+var _19=new ActiveXObject(_SARISSA_DOM_PROGID);
+if(s.substring(0,5)==&quot;&lt;?xml&quot;){
+s=s.substring(s.indexOf(&quot;?&gt;&quot;)+2);
+}
+var xml=&quot;&quot;.concat(&quot;&lt;my&gt;&quot;,s,&quot;&lt;/my&gt;&quot;);
+_19.loadXML(xml);
+var _18=_19.documentElement;
+while(_18.hasChildNodes()){
+f.appendChild(_18.firstChild);
+}
+}
+}
+return f;
+};
+XSLTProcessor.prototype.setParameter=function(_1b,_1c,_1d){
+if(_1b){
+this.processor.addParameter(_1c,_1d,_1b);
+}else{
+this.processor.addParameter(_1c,_1d);
+}
+if(!this.paramsSet[&quot;&quot;+_1b]){
+this.paramsSet[&quot;&quot;+_1b]=new Array();
+}
+this.paramsSet[&quot;&quot;+_1b][_1c]=_1d;
+};
+XSLTProcessor.prototype.getParameter=function(_1e,_1f){
+_1e=_1e||&quot;&quot;;
+if(this.paramsSet[_1e]&amp;&amp;this.paramsSet[_1e][_1f]){
+return this.paramsSet[_1e][_1f];
+}else{
+return null;
+}
+};
+XSLTProcessor.prototype.clearParameters=function(){
+for(var _20 in this.paramsSet){
+for(var _21 in this.paramsSet[_20]){
+if(_20){
+this.processor.addParameter(_21,null,_20);
+}else{
+this.processor.addParameter(_21,null);
+}
+}
+}
+this.paramsSet=new Array();
+};
+}else{
+if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
+Sarissa.__handleLoad__=function(_22){
+Sarissa.__setReadyState__(_22,4);
+};
+_sarissa_XMLDocument_onload=function(){
+Sarissa.__handleLoad__(this);
+};
+Sarissa.__setReadyState__=function(_23,_24){
+_23.readyState=_24;
+_23.readystate=_24;
+if(_23.onreadystatechange!=null&amp;&amp;typeof _23.onreadystatechange==&quot;function&quot;){
+_23.onreadystatechange();
+}
+};
+Sarissa.getDomDocument=function(_25,_26){
+var _27=document.implementation.createDocument(_25?_25:null,_26?_26:null,null);
+if(!_27.onreadystatechange){
+_27.onreadystatechange=null;
+}
+if(!_27.readyState){
+_27.readyState=0;
+}
+_27.addEventListener(&quot;load&quot;,_sarissa_XMLDocument_onload,false);
+return _27;
+};
+if(window.XMLDocument){
+}else{
+if(_SARISSA_HAS_DOM_FEATURE&amp;&amp;window.Document&amp;&amp;!Document.prototype.load&amp;&amp;document.implementation.hasFeature(&quot;LS&quot;,&quot;3.0&quot;)){
+Sarissa.getDomDocument=function(_28,_29){
+var _2a=document.implementation.createDocument(_28?_28:null,_29?_29:null,null);
+return _2a;
+};
+}else{
+Sarissa.getDomDocument=function(_2b,_2c){
+var _2d=document.implementation.createDocument(_2b?_2b:null,_2c?_2c:null,null);
+if(_2d&amp;&amp;(_2b||_2c)&amp;&amp;!_2d.documentElement){
+_2d.appendChild(_2d.createElementNS(_2b,_2c));
+}
+return _2d;
+};
+}
+}
+}
+}
+if(!window.DOMParser){
+if(_SARISSA_IS_SAFARI){
+DOMParser=function(){
+};
+DOMParser.prototype.parseFromString=function(_2e,_2f){
+var _30=new XMLHttpRequest();
+_30.open(&quot;GET&quot;,&quot;data:text/xml;charset=utf-8,&quot;+encodeURIComponent(_2e),false);
+_30.send(null);
+return _30.responseXML;
+};
+}else{
+if(Sarissa.getDomDocument&amp;&amp;Sarissa.getDomDocument()&amp;&amp;Sarissa.getDomDocument(null,&quot;bar&quot;).xml){
+DOMParser=function(){
+};
+DOMParser.prototype.parseFromString=function(_31,_32){
+var doc=Sarissa.getDomDocument();
+doc.loadXML(_31);
+return doc;
+};
+}
+}
+}
+if((typeof (document.importNode)==&quot;undefined&quot;)&amp;&amp;_SARISSA_IS_IE){
+try{
+document.importNode=function(_34,_35){
+var tmp;
+if(_34.nodeName==&quot;tbody&quot;||_34.nodeName==&quot;tr&quot;){
+tmp=document.createElement(&quot;table&quot;);
+}else{
+if(_34.nodeName==&quot;td&quot;){
+tmp=document.createElement(&quot;tr&quot;);
+}else{
+if(_34.nodeName==&quot;option&quot;){
+tmp=document.createElement(&quot;select&quot;);
+}else{
+tmp=document.createElement(&quot;div&quot;);
+}
+}
+}
+if(_35){
+tmp.innerHTML=_34.xml?_34.xml:_34.outerHTML;
+}else{
+tmp.innerHTML=_34.xml?_34.cloneNode(false).xml:_34.cloneNode(false).outerHTML;
+}
+return tmp.getElementsByTagName(&quot;*&quot;)[0];
+};
+}
+catch(e){
+}
+}
+if(!Sarissa.getParseErrorText){
+Sarissa.getParseErrorText=function(_37){
+var _38=Sarissa.PARSED_OK;
+if(!_37.documentElement){
+_38=Sarissa.PARSED_EMPTY;
+}else{
+if(_37.documentElement.tagName==&quot;parsererror&quot;){
+_38=_37.documentElement.firstChild.data;
+_38+=&quot;\n&quot;+_37.documentElement.firstChild.nextSibling.firstChild.data;
+}else{
+if(_37.getElementsByTagName(&quot;parsererror&quot;).length&gt;0){
+var _39=_37.getElementsByTagName(&quot;parsererror&quot;)[0];
+_38=Sarissa.getText(_39,true)+&quot;\n&quot;;
+}else{
+if(_37.parseError&amp;&amp;_37.parseError.errorCode!=0){
+_38=Sarissa.PARSED_UNKNOWN_ERROR;
+}
+}
+}
+}
+return _38;
+};
+}
+Sarissa.getText=function(_3a,_3b){
+var s=&quot;&quot;;
+var _3d=_3a.childNodes;
+for(var i=0;i&lt;_3d.length;i++){
+var _3f=_3d[i];
+var _40=_3f.nodeType;
+if(_40==Node.TEXT_NODE||_40==Node.CDATA_SECTION_NODE){
+s+=_3f.data;
+}else{
+if(_3b==true&amp;&amp;(_40==Node.ELEMENT_NODE||_40==Node.DOCUMENT_NODE||_40==Node.DOCUMENT_FRAGMENT_NODE)){
+s+=Sarissa.getText(_3f,true);
+}
+}
+}
+return s;
+};
+if(!window.XMLSerializer&amp;&amp;Sarissa.getDomDocument&amp;&amp;Sarissa.getDomDocument(&quot;&quot;,&quot;foo&quot;,null).xml){
+XMLSerializer=function(){
+};
+XMLSerializer.prototype.serializeToString=function(_41){
+return _41.xml;
+};
+}
+Sarissa.stripTags=function(s){
+return s.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;);
+};
+Sarissa.clearChildNodes=function(_43){
+while(_43.firstChild){
+_43.removeChild(_43.firstChild);
+}
+};
+Sarissa.copyChildNodes=function(_44,_45,_46){
+if((!_44)||(!_45)){
+throw &quot;Both source and destination nodes must be provided&quot;;
+}
+if(!_46){
+Sarissa.clearChildNodes(_45);
+}
+var _47=_45.nodeType==Node.DOCUMENT_NODE?_45:_45.ownerDocument;
+var _48=_44.childNodes;
+if(typeof (_47.importNode)!=&quot;undefined&quot;){
+for(var i=0;i&lt;_48.length;i++){
+_45.appendChild(_47.importNode(_48[i],true));
+}
+}else{
+for(var i=0;i&lt;_48.length;i++){
+_45.appendChild(_48[i].cloneNode(true));
+}
+}
+};
+Sarissa.moveChildNodes=function(_4a,_4b,_4c){
+if((!_4a)||(!_4b)){
+throw &quot;Both source and destination nodes must be provided&quot;;
+}
+if(!_4c){
+Sarissa.clearChildNodes(_4b);
+}
+var _4d=_4a.childNodes;
+if(_4a.ownerDocument==_4b.ownerDocument){
+while(_4a.firstChild){
+_4b.appendChild(_4a.firstChild);
+}
+}else{
+var _4e=_4b.nodeType==Node.DOCUMENT_NODE?_4b:_4b.ownerDocument;
+if(typeof (_4e.importNode)!=&quot;undefined&quot;){
+for(var i=0;i&lt;_4d.length;i++){
+_4b.appendChild(_4e.importNode(_4d[i],true));
+}
+}else{
+for(var i=0;i&lt;_4d.length;i++){
+_4b.appendChild(_4d[i].cloneNode(true));
+}
+}
+Sarissa.clearChildNodes(_4a);
+}
+};
+Sarissa.xmlize=function(_50,_51,_52){
+_52=_52?_52:&quot;&quot;;
+var s=_52+&quot;&lt;&quot;+_51+&quot;&gt;&quot;;
+var _54=false;
+if(!(_50 instanceof Object)||_50 instanceof Number||_50 instanceof String||_50 instanceof Boolean||_50 instanceof Date){
+s+=Sarissa.escape(&quot;&quot;+_50);
+_54=true;
+}else{
+s+=&quot;\n&quot;;
+var _55=&quot;&quot;;
+var _56=_50 instanceof Array;
+for(var _57 in _50){
+s+=Sarissa.xmlize(_50[_57],(_56?&quot;array-item key=\&quot;&quot;+_57+&quot;\&quot;&quot;:_57),_52+&quot;   &quot;);
+}
+s+=_52;
+}
+return s+=(_51.indexOf(&quot; &quot;)!=-1?&quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot;+_51+&quot;&gt;\n&quot;);
+};
+Sarissa.escape=function(_58){
+return _58.replace(/&amp;/g,&quot;&amp;&quot;).replace(/&lt;/g,&quot;&lt;&quot;).replace(/&gt;/g,&quot;&gt;&quot;).replace(/&quot;/g,&quot;&quot;&quot;).replace(/'/g,&quot;&apos;&quot;);
+};
+Sarissa.unescape=function(_59){
+return _59.replace(/&apos;/g,&quot;'&quot;).replace(/&quot;/g,&quot;\&quot;&quot;).replace(/&gt;/g,&quot;&gt;&quot;).replace(/&lt;/g,&quot;&lt;&quot;).replace(/&amp;/g,&quot;&amp;&quot;);
+};
+

Added: branch/2.0.1/pack.bat
===================================================================
--- branch/2.0.1/pack.bat	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/pack.bat	2007-03-19 22:07:30 UTC (rev 82)
@@ -0,0 +1 @@
+java -jar custom_rhino.jar -c lib/Freja.js &gt; lib/Freja_pack.js 2&gt;&amp;1
\ No newline at end of file

Modified: branch/2.0.1/src/AssetManager.js
===================================================================
--- branch/2.0.1/src/AssetManager.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/src/AssetManager.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -22,8 +22,8 @@
   * Both IE6 and FF1.5 are known to support the required HTTP methods, so
   * if theese are your target platform, you can disable tunneling.
   */
-// Freja.AssetManager.HTTP_METHOD_TUNNEL = null;
-Freja.AssetManager.HTTP_METHOD_TUNNEL = &quot;Http-Method-Equivalent&quot;;
+//  Freja.AssetManager.HTTP_METHOD_TUNNEL = null;
+  Freja.AssetManager.HTTP_METHOD_TUNNEL = &quot;Http-Method-Equivalent&quot;;
 /**
   * Set this url to provide remote xslt-transformation for browsers that
   * doesn't support it natively.
@@ -115,7 +115,7 @@
 	this._password = password;
 };
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.AssetManager.loadAsset = function(url, preventCaching) {
 	var match = /^(file:\/\/.*\/)([^\/]*)$/.exec(window.location.href);

Modified: branch/2.0.1/src/Model.js
===================================================================
--- branch/2.0.1/src/Model.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/src/Model.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -48,7 +48,7 @@
 };
 /**
   * Writes the model back to the remote service
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.Model.prototype.save = function() {
 	var url = this.url;
@@ -71,7 +71,7 @@
 };
 /**
   * Deletes the model from the remote service
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.Model.prototype.remove = function() {
 	var url = this.url;
@@ -83,7 +83,7 @@
 	return Freja._aux.sendXMLHttpRequest(req);
 };
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.Model.prototype.reload = function() {
 	this.ready = false;

Modified: branch/2.0.1/src/View.js
===================================================================
--- branch/2.0.1/src/View.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/src/View.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -15,7 +15,7 @@
   * @param    model            Freja.Model
   * @param    placeholder      string    If supplied, this will be used instead of the
   *                                      default placeholder.
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.View.prototype.render = function(model, placeholder, xslParameters) {
 	if (typeof(placeholder) == &quot;undefined&quot;) placeholder = this.placeholder;
@@ -69,7 +69,11 @@
 
 	var d = Freja._aux.createDeferred();
 	try {
-		this._destination = Freja._aux.getElement(placeholder);
+		if (typeof(placeholder) == &quot;object&quot;) {
+			this._destination = placeholder;
+		} else {
+			this._destination = document.getElementById(placeholder);
+		}
 		// @todo    Is this a good idea ?
 		// Perhaps we should leave it to the programmer to do this.
 		this._destination.innerHTML = Freja.AssetManager.THROBBER_HTML;
@@ -157,7 +161,7 @@
 Freja.View.Renderer.XSLTransformer = function() {};
 Freja.Class.extend(Freja.View.Renderer.XSLTransformer, Freja.View.Renderer);
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.View.Renderer.XSLTransformer.prototype.transform = function(model, view, xslParameters) {
         var d = Freja._aux.createDeferred();
@@ -182,7 +186,7 @@
 };
 Freja.Class.extend(Freja.View.Renderer.RemoteXSLTransformer, Freja.View.Renderer);
 /**
-  * @returns MochiKit.Async.Deferred
+  * @returns Freja._aux.Deferred
   */
 Freja.View.Renderer.RemoteXSLTransformer.prototype.transform = function(model, view, xslParameters) {
         var d = Freja._aux.createDeferred();

Modified: branch/2.0.1/src/auxiliary/minimal.js
===================================================================
--- branch/2.0.1/src/auxiliary/minimal.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/src/auxiliary/minimal.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -1,10 +1,870 @@
+
 /**
+ * ====================================================================
+ * About
+ * ====================================================================
+ * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
+ * The library supports Gecko based browsers like Mozilla and Firefox,
+ * Internet Explorer (5.5+ with MSXML3.0+), Konqueror, Safari and a little of Opera
+ * @version 0.9.7.6
+ * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
+ * ====================================================================
+ * Licence
+ * ====================================================================
+ * Sarissa is free software distributed under the GNU GPL version 2 (see &lt;a href=&quot;gpl.txt&quot;&gt;gpl.txt&lt;/a&gt;) or higher, 
+ * GNU LGPL version 2.1 (see &lt;a href=&quot;lgpl.txt&quot;&gt;lgpl.txt&lt;/a&gt;) or higher and Apache Software License 2.0 or higher 
+ * (see &lt;a href=&quot;asl.txt&quot;&gt;asl.txt&lt;/a&gt;). This means you can choose one of the three and use that if you like. If 
+ * you make modifications under the ASL, i would appreciate it if you submitted those.
+ * In case your copy of Sarissa does not include the license texts, you may find
+ * them online in various formats at &lt;a href=&quot;<A HREF="http://www.gnu.org">http://www.gnu.org</A>&quot;&gt;<A HREF="http://www.gnu.org&lt;/a">http://www.gnu.org&lt;/a</A>&gt; and 
+ * &lt;a href=&quot;<A HREF="http://www.apache.org">http://www.apache.org</A>&quot;&gt;<A HREF="http://www.apache.org&lt;/a">http://www.apache.org&lt;/a</A>&gt;.
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY 
+ * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
+ * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
+ * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+/**
+ * &lt;p&gt;Sarissa is a utility class. Provides &quot;static&quot; methods for DOMDocument, 
+ * DOM Node serialization to XML strings and other utility goodies.&lt;/p&gt;
+ * @constructor
+ */
+function Sarissa(){};
+Sarissa.PARSED_OK = &quot;Document contains no parsing errors&quot;;
+Sarissa.PARSED_EMPTY = &quot;Document is empty&quot;;
+Sarissa.PARSED_UNKNOWN_ERROR = &quot;Not well-formed or other error&quot;;
+var _sarissa_iNsCounter = 0;
+var _SARISSA_IEPREFIX4XSLPARAM = &quot;&quot;;
+var _SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation &amp;&amp; true;
+var _SARISSA_HAS_DOM_CREATE_DOCUMENT = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.createDocument;
+var _SARISSA_HAS_DOM_FEATURE = _SARISSA_HAS_DOM_IMPLEMENTATION &amp;&amp; document.implementation.hasFeature;
+var _SARISSA_IS_MOZ = _SARISSA_HAS_DOM_CREATE_DOCUMENT &amp;&amp; _SARISSA_HAS_DOM_FEATURE;
+var _SARISSA_IS_SAFARI = (navigator.userAgent &amp;&amp; navigator.vendor &amp;&amp; (navigator.userAgent.toLowerCase().indexOf(&quot;applewebkit&quot;) != -1 || navigator.vendor.indexOf(&quot;Apple&quot;) != -1));
+var _SARISSA_IS_IE = document.all &amp;&amp; window.ActiveXObject &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;) &gt; -1  &amp;&amp; navigator.userAgent.toLowerCase().indexOf(&quot;opera&quot;) == -1;
+if(!window.Node || !Node.ELEMENT_NODE){
+    Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
+};
+
+if(typeof XMLDocument == &quot;undefined&quot; &amp;&amp; typeof Document !=&quot;undefined&quot;){ XMLDocument = Document; } 
+
+// IE initialization
+if(_SARISSA_IS_IE){
+    // for XSLT parameter names, prefix needed by IE
+    _SARISSA_IEPREFIX4XSLPARAM = &quot;xsl:&quot;;
+    // used to store the most recent ProgID available out of the above
+    var _SARISSA_DOM_PROGID = &quot;&quot;;
+    var _SARISSA_XMLHTTP_PROGID = &quot;&quot;;
+    var _SARISSA_DOM_XMLWRITER = &quot;&quot;;
+    /**
+     * Called when the Sarissa_xx.js file is parsed, to pick most recent
+     * ProgIDs for IE, then gets destroyed.
+     * @private
+     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
+     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
+     */
+    Sarissa.pickRecentProgID = function (idList){
+        // found progID flag
+        var bFound = false;
+        for(var i=0; i &lt; idList.length &amp;&amp; !bFound; i++){
+            try{
+                var oDoc = new ActiveXObject(idList[i]);
+                o2Store = idList[i];
+                bFound = true;
+            }catch (objException){
+                // trap; try next progID
+            };
+        };
+        if (!bFound) {
+            throw &quot;Could not retreive a valid progID of Class: &quot; + idList[idList.length-1]+&quot;. (original exception: &quot;+e+&quot;)&quot;;
+        };
+        idList = null;
+        return o2Store;
+    };
+    // pick best available MSXML progIDs
+    _SARISSA_DOM_PROGID = null;
+    _SARISSA_THREADEDDOM_PROGID = null;
+    _SARISSA_XSLTEMPLATE_PROGID = null;
+    _SARISSA_XMLHTTP_PROGID = null;
+    if(!window.XMLHttpRequest){
+        /**
+         * Emulate XMLHttpRequest
+         * @constructor
+         */
+        XMLHttpRequest = function() {
+            if(!_SARISSA_XMLHTTP_PROGID){
+                _SARISSA_XMLHTTP_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XMLHTTP.6.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]);
+            };
+            return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
+        };
+    };
+    // we dont need this anymore
+    //============================================
+    // Factory methods (IE)
+    //============================================
+    // see non-IE version
+    Sarissa.getDomDocument = function(sUri, sName){
+        if(!_SARISSA_DOM_PROGID){
+            _SARISSA_DOM_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.DOMDocument.6.0&quot;, &quot;Msxml2.DOMDocument.3.0&quot;, &quot;MSXML2.DOMDocument&quot;, &quot;MSXML.DOMDocument&quot;, &quot;Microsoft.XMLDOM&quot;]);
+        };
+        var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+        // if a root tag name was provided, we need to load it in the DOM object
+        if (sName){
+            // create an artifical namespace prefix 
+            // or reuse existing prefix if applicable
+            var prefix = &quot;&quot;;
+            if(sUri){
+                if(sName.indexOf(&quot;:&quot;) &gt; 1){
+                    prefix = sName.substring(0, sName.indexOf(&quot;:&quot;));
+                    sName = sName.substring(sName.indexOf(&quot;:&quot;)+1); 
+                }else{
+                    prefix = &quot;a&quot; + (_sarissa_iNsCounter++);
+                };
+            };
+            // use namespaces if a namespace URI exists
+            if(sUri){
+                oDoc.loadXML('&lt;' + prefix+':'+sName + &quot; xmlns:&quot; + prefix + &quot;=\&quot;&quot; + sUri + &quot;\&quot;&quot; + &quot; /&gt;&quot;);
+            } else {
+                oDoc.loadXML('&lt;' + sName + &quot; /&gt;&quot;);
+            };
+        };
+        return oDoc;
+    };
+    // see non-IE version   
+    Sarissa.getParseErrorText = function (oDoc) {
+        var parseErrorText = Sarissa.PARSED_OK;
+        if(oDoc.parseError.errorCode != 0){
+            parseErrorText = &quot;XML Parsing Error: &quot; + oDoc.parseError.reason + 
+                &quot;\nLocation: &quot; + oDoc.parseError.url + 
+                &quot;\nLine Number &quot; + oDoc.parseError.line + &quot;, Column &quot; + 
+                oDoc.parseError.linepos + 
+                &quot;:\n&quot; + oDoc.parseError.srcText +
+                &quot;\n&quot;;
+            for(var i = 0;  i &lt; oDoc.parseError.linepos;i++){
+                parseErrorText += &quot;-&quot;;
+            };
+            parseErrorText +=  &quot;^\n&quot;;
+        }
+        else if(oDoc.documentElement == null){
+            parseErrorText = Sarissa.PARSED_EMPTY;
+        };
+        return parseErrorText;
+    };
+    // see non-IE version
+    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
+        oDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
+        oDoc.setProperty(&quot;SelectionNamespaces&quot;, sNsSet);
+    };   
+    /**
+     * Basic implementation of Mozilla's XSLTProcessor for IE. 
+     * Reuses the same XSLT stylesheet for multiple transforms
+     * @constructor
+     */
+    XSLTProcessor = function(){
+        if(!_SARISSA_XSLTEMPLATE_PROGID){
+            _SARISSA_XSLTEMPLATE_PROGID = Sarissa.pickRecentProgID([&quot;Msxml2.XSLTemplate.6.0&quot;, &quot;MSXML2.XSLTemplate.3.0&quot;]);
+        };
+        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
+        this.processor = null;
+    };
+    /**
+     * Imports the given XSLT DOM and compiles it to a reusable transform
+     * &lt;b&gt;Note:&lt;/b&gt; If the stylesheet was loaded from a URL and contains xsl:import or xsl:include elements,it will be reloaded to resolve those
+     * @argument xslDoc The XSLT DOMDocument to import
+     */
+    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
+        if(!_SARISSA_THREADEDDOM_PROGID){
+            _SARISSA_THREADEDDOM_PROGID = Sarissa.pickRecentProgID([&quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;, &quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
+        };
+        xslDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
+        xslDoc.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+        // convert stylesheet to free threaded
+        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
+        // make included/imported stylesheets work if exist and xsl was originally loaded from url
+        if(xslDoc.url &amp;&amp; xslDoc.selectSingleNode(&quot;//xsl:*[local-name() = 'import' or local-name() = 'include']&quot;) != null){
+            converted.async = false;
+            if (_SARISSA_THREADEDDOM_PROGID == &quot;MSXML2.FreeThreadedDOMDocument.6.0&quot;) { 
+                converted.setProperty(&quot;AllowDocumentFunction&quot;, true); 
+                converted.resolveExternals = true; 
+            }
+            converted.load(xslDoc.url);
+        } else {
+            converted.loadXML(xslDoc.xml);
+        };
+        converted.setProperty(&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
+        var output = converted.selectSingleNode(&quot;//xsl:output&quot;);
+        this.outputMethod = output ? output.getAttribute(&quot;method&quot;) : &quot;html&quot;;
+        this.template.stylesheet = converted;
+        this.processor = this.template.createProcessor();
+        // for getParameter and clearParameters
+        this.paramsSet = new Array();
+    };
+
+    /**
+     * Transform the given XML DOM and return the transformation result as a new DOM document
+     * @argument sourceDoc The XML DOMDocument to transform
+     * @return The transformation result as a DOM Document
+     */
+    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
+        // fix for bug 1549749
+        if(_SARISSA_THREADEDDOM_PROGID){
+            this.processor.input=sourceDoc;
+            var outDoc=new ActiveXObject(_SARISSA_DOM_PROGID);
+            this.processor.output=outDoc;
+            this.processor.transform();
+            return outDoc;
+        }
+        else{
+            if(!_SARISSA_DOM_XMLWRITER){
+                _SARISSA_DOM_XMLWRITER = Sarissa.pickRecentProgID([&quot;Msxml2.MXXMLWriter.6.0&quot;, &quot;Msxml2.MXXMLWriter.3.0&quot;, &quot;MSXML2.MXXMLWriter&quot;, &quot;MSXML.MXXMLWriter&quot;, &quot;Microsoft.XMLDOM&quot;]);
+            };
+            this.processor.input = sourceDoc;
+            var outDoc = new ActiveXObject(_SARISSA_DOM_XMLWRITER);
+            this.processor.output = outDoc; 
+            this.processor.transform();
+            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+            oDoc.loadXML(outDoc.output+&quot;&quot;);
+            return oDoc;
+        };
+    };
+    
+    /**
+     * Transform the given XML DOM and return the transformation result as a new DOM fragment.
+     * &lt;b&gt;Note&lt;/b&gt;: The xsl:output method must match the nature of the owner document (XML/HTML).
+     * @argument sourceDoc The XML DOMDocument to transform
+     * @argument ownerDoc The owner of the result fragment
+     * @return The transformation result as a DOM Document
+     */
+    XSLTProcessor.prototype.transformToFragment = function (sourceDoc, ownerDoc) {
+        this.processor.input = sourceDoc;
+        this.processor.transform();
+        var s = this.processor.output;
+        var f = ownerDoc.createDocumentFragment();
+        if (this.outputMethod == 'text') {
+            f.appendChild(ownerDoc.createTextNode(s));
+        } else if (ownerDoc.body &amp;&amp; ownerDoc.body.innerHTML) {
+            var container = ownerDoc.createElement('div');
+            container.innerHTML = s;
+            while (container.hasChildNodes()) {
+                f.appendChild(container.firstChild);
+            }
+        }
+        else {
+            var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
+            if (s.substring(0, 5) == '&lt;?xml') {
+                s = s.substring(s.indexOf('?&gt;') + 2);
+            }
+            var xml = ''.concat('&lt;my&gt;', s, '&lt;/my&gt;');
+            oDoc.loadXML(xml);
+            var container = oDoc.documentElement;
+            while (container.hasChildNodes()) {
+                f.appendChild(container.firstChild);
+            }
+        }
+        return f;
+    };
+    
+    /**
+     * Set global XSLT parameter of the imported stylesheet
+     * @argument nsURI The parameter namespace URI
+     * @argument name The parameter base name
+     * @argument value The new parameter value
+     */
+    XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
+        // nsURI is optional but cannot be null 
+        if(nsURI){
+            this.processor.addParameter(name, value, nsURI);
+        }else{
+            this.processor.addParameter(name, value);
+        };
+        // update updated params for getParameter 
+        if(!this.paramsSet[&quot;&quot;+nsURI]){
+            this.paramsSet[&quot;&quot;+nsURI] = new Array();
+        };
+        this.paramsSet[&quot;&quot;+nsURI][name] = value;
+    };
+    /**
+     * Gets a parameter if previously set by setParameter. Returns null
+     * otherwise
+     * @argument name The parameter base name
+     * @argument value The new parameter value
+     * @return The parameter value if reviously set by setParameter, null otherwise
+     */
+    XSLTProcessor.prototype.getParameter = function(nsURI, name){
+        nsURI = nsURI || &quot;&quot;;
+        if(this.paramsSet[nsURI] &amp;&amp; this.paramsSet[nsURI][name]){
+            return this.paramsSet[nsURI][name];
+        }else{
+            return null;
+        };
+    };
+    /**
+     * Clear parameters (set them to default values as defined in the stylesheet itself)
+     */
+    XSLTProcessor.prototype.clearParameters = function(){
+        for(var nsURI in this.paramsSet){
+            for(var name in this.paramsSet[nsURI]){
+                if(nsURI){
+                    this.processor.addParameter(name, null, nsURI);
+                }else{
+                    this.processor.addParameter(name, null);
+                };
+            };
+        };
+        this.paramsSet = new Array();
+    };
+}else{ /* end IE initialization, try to deal with real browsers now ;-) */
+    if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
+        /**
+         * &lt;p&gt;Ensures the document was loaded correctly, otherwise sets the
+         * parseError to -1 to indicate something went wrong. Internal use&lt;/p&gt;
+         * @private
+         */
+        Sarissa.__handleLoad__ = function(oDoc){
+            Sarissa.__setReadyState__(oDoc, 4);
+        };
+        /**
+        * &lt;p&gt;Attached by an event handler to the load event. Internal use.&lt;/p&gt;
+        * @private
+        */
+        _sarissa_XMLDocument_onload = function(){
+            Sarissa.__handleLoad__(this);
+        };
+        /**
+         * &lt;p&gt;Sets the readyState property of the given DOM Document object.
+         * Internal use.&lt;/p&gt;
+         * @private
+         * @argument oDoc the DOM Document object to fire the
+         *          readystatechange event
+         * @argument iReadyState the number to change the readystate property to
+         */
+        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
+            oDoc.readyState = iReadyState;
+            oDoc.readystate = iReadyState;
+            if (oDoc.onreadystatechange != null &amp;&amp; typeof oDoc.onreadystatechange == &quot;function&quot;)
+                oDoc.onreadystatechange();
+        };
+        Sarissa.getDomDocument = function(sUri, sName){
+            var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+            if(!oDoc.onreadystatechange){
+            
+                /**
+                * &lt;p&gt;Emulate IE's onreadystatechange attribute&lt;/p&gt;
+                */
+                oDoc.onreadystatechange = null;
+            };
+            if(!oDoc.readyState){
+                /**
+                * &lt;p&gt;Emulates IE's readyState property, which always gives an integer from 0 to 4:&lt;/p&gt;
+                * &lt;ul&gt;&lt;li&gt;1 == LOADING,&lt;/li&gt;
+                * &lt;li&gt;2 == LOADED,&lt;/li&gt;
+                * &lt;li&gt;3 == INTERACTIVE,&lt;/li&gt;
+                * &lt;li&gt;4 == COMPLETED&lt;/li&gt;&lt;/ul&gt;
+                */
+                oDoc.readyState = 0;
+            };
+            oDoc.addEventListener(&quot;load&quot;, _sarissa_XMLDocument_onload, false);
+            return oDoc;
+        };
+        if(window.XMLDocument){
+            // do nothing
+        }// TODO: check if the new document has content before trying to copynodes, check  for error handling in DOM 3 LS
+        else if(_SARISSA_HAS_DOM_FEATURE &amp;&amp; window.Document &amp;&amp; !Document.prototype.load &amp;&amp; document.implementation.hasFeature('LS', '3.0')){
+            //Opera 9 may get the XPath branch which gives creates XMLDocument, therefore it doesn't reach here which is good
+            /**
+            * &lt;p&gt;Factory method to obtain a new DOM Document object&lt;/p&gt;
+            * @argument sUri the namespace of the root node (if any)
+            * @argument sUri the local name of the root node (if any)
+            * @returns a new DOM Document
+            */
+            Sarissa.getDomDocument = function(sUri, sName){
+                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+                return oDoc;
+            };
+        }
+        else {
+            Sarissa.getDomDocument = function(sUri, sName){
+                var oDoc = document.implementation.createDocument(sUri?sUri:null, sName?sName:null, null);
+                // looks like safari does not create the root element for some unknown reason
+                if(oDoc &amp;&amp; (sUri || sName) &amp;&amp; !oDoc.documentElement){
+                    oDoc.appendChild(oDoc.createElementNS(sUri, sName));
+                };
+                return oDoc;
+            };
+        };
+    };//if(_SARISSA_HAS_DOM_CREATE_DOCUMENT)
+};
+//==========================================
+// Common stuff
+//==========================================
+if(!window.DOMParser){
+    if(_SARISSA_IS_SAFARI){
+        /*
+         * DOMParser is a utility class, used to construct DOMDocuments from XML strings
+         * @constructor
+         */
+        DOMParser = function() { };
+        /** 
+        * Construct a new DOM Document from the given XMLstring
+        * @param sXml the given XML string
+        * @param contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml). 
+        * @return a new DOM Document from the given XML string
+        */
+        DOMParser.prototype.parseFromString = function(sXml, contentType){
+            var xmlhttp = new XMLHttpRequest();
+            xmlhttp.open(&quot;GET&quot;, &quot;data:text/xml;charset=utf-8,&quot; + encodeURIComponent(sXml), false);
+            xmlhttp.send(null);
+            return xmlhttp.responseXML;
+        };
+    }else if(Sarissa.getDomDocument &amp;&amp; Sarissa.getDomDocument() &amp;&amp; Sarissa.getDomDocument(null, &quot;bar&quot;).xml){
+        DOMParser = function() { };
+        DOMParser.prototype.parseFromString = function(sXml, contentType){
+            var doc = Sarissa.getDomDocument();
+            doc.loadXML(sXml);
+            return doc;
+        };
+    };
+};
+
+if((typeof(document.importNode) == &quot;undefined&quot;) &amp;&amp; _SARISSA_IS_IE){
+    try{
+        /**
+        * Implementation of importNode for the context window document in IE
+        * @param oNode the Node to import
+        * @param bChildren whether to include the children of oNode
+        * @returns the imported node for further use
+        */
+        document.importNode = function(oNode, bChildren){
+            var tmp;
+            if(oNode.nodeName == &quot;tbody&quot; || oNode.nodeName == &quot;tr&quot;){
+                tmp = document.createElement(&quot;table&quot;);
+            }
+            else if(oNode.nodeName == &quot;td&quot;){
+                tmp = document.createElement(&quot;tr&quot;);
+            }
+            else if(oNode.nodeName == &quot;option&quot;){
+                tmp = document.createElement(&quot;select&quot;);
+            }
+            else{
+                tmp = document.createElement(&quot;div&quot;);
+            };
+            if(bChildren){
+                tmp.innerHTML = oNode.xml ? oNode.xml : oNode.outerHTML;
+            }else{
+                tmp.innerHTML = oNode.xml ? oNode.cloneNode(false).xml : oNode.cloneNode(false).outerHTML;
+            };
+            return tmp.getElementsByTagName(&quot;*&quot;)[0];
+        };
+    }catch(e){ };
+};
+if(!Sarissa.getParseErrorText){
+    /**
+     * &lt;p&gt;Returns a human readable description of the parsing error. Usefull
+     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
+     * element if you want to render it.&lt;/p&gt;
+     * &lt;p&gt;Many thanks to Christian Stocker for the initial patch.&lt;/p&gt;
+     * @argument oDoc The target DOM document
+     * @returns The parsing error description of the target Document in
+     *          human readable form (preformated text)
+     */
+    Sarissa.getParseErrorText = function (oDoc){
+        var parseErrorText = Sarissa.PARSED_OK;
+        if(!oDoc.documentElement){
+            parseErrorText = Sarissa.PARSED_EMPTY;
+        } else if(oDoc.documentElement.tagName == &quot;parsererror&quot;){
+            parseErrorText = oDoc.documentElement.firstChild.data;
+            parseErrorText += &quot;\n&quot; +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
+        } else if(oDoc.getElementsByTagName(&quot;parsererror&quot;).length &gt; 0){
+            var parsererror = oDoc.getElementsByTagName(&quot;parsererror&quot;)[0];
+            parseErrorText = Sarissa.getText(parsererror, true)+&quot;\n&quot;;
+        } else if(oDoc.parseError &amp;&amp; oDoc.parseError.errorCode != 0){
+            parseErrorText = Sarissa.PARSED_UNKNOWN_ERROR;
+        };
+        return parseErrorText;
+    };
+};
+Sarissa.getText = function(oNode, deep){
+    var s = &quot;&quot;;
+    var nodes = oNode.childNodes;
+    for(var i=0; i &lt; nodes.length; i++){
+        var node = nodes[i];
+        var nodeType = node.nodeType;
+        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
+            s += node.data;
+        } else if(deep == true
+                    &amp;&amp; (nodeType == Node.ELEMENT_NODE
+                        || nodeType == Node.DOCUMENT_NODE
+                        || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
+            s += Sarissa.getText(node, true);
+        };
+    };
+    return s;
+};
+if(!window.XMLSerializer 
+    &amp;&amp; Sarissa.getDomDocument 
+    &amp;&amp; Sarissa.getDomDocument(&quot;&quot;,&quot;foo&quot;, null).xml){
+    /**
+     * Utility class to serialize DOM Node objects to XML strings
+     * @constructor
+     */
+    XMLSerializer = function(){};
+    /**
+     * Serialize the given DOM Node to an XML string
+     * @param oNode the DOM Node to serialize
+     */
+    XMLSerializer.prototype.serializeToString = function(oNode) {
+        return oNode.xml;
+    };
+};
+
+/**
+ * strips tags from a markup string
+ */
+Sarissa.stripTags = function (s) {
+    return s.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;);
+};
+/**
+ * &lt;p&gt;Deletes all child nodes of the given node&lt;/p&gt;
+ * @argument oNode the Node to empty
+ */
+Sarissa.clearChildNodes = function(oNode) {
+    // need to check for firstChild due to opera 8 bug with hasChildNodes
+    while(oNode.firstChild) {
+        oNode.removeChild(oNode.firstChild);
+    };
+};
+/**
+ * &lt;p&gt; Copies the childNodes of nodeFrom to nodeTo&lt;/p&gt;
+ * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
+ * the copy operation, unless you supply a true third parameter&lt;/p&gt;
+ * @argument nodeFrom the Node to copy the childNodes from
+ * @argument nodeTo the Node to copy the childNodes to
+ * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is false
+ */
+Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
+    if((!nodeFrom) || (!nodeTo)){
+        throw &quot;Both source and destination nodes must be provided&quot;;
+    };
+    if(!bPreserveExisting){
+        Sarissa.clearChildNodes(nodeTo);
+    };
+    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
+    var nodes = nodeFrom.childNodes;
+    if(typeof(ownerDoc.importNode) != &quot;undefined&quot;)  {
+        for(var i=0;i &lt; nodes.length;i++) {
+            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
+        };
+    } else {
+        for(var i=0;i &lt; nodes.length;i++) {
+            nodeTo.appendChild(nodes[i].cloneNode(true));
+        };
+    };
+};
+
+/**
+ * &lt;p&gt; Moves the childNodes of nodeFrom to nodeTo&lt;/p&gt;
+ * &lt;p&gt; &lt;b&gt;Note:&lt;/b&gt; The second object's original content is deleted before 
+ * the move operation, unless you supply a true third parameter&lt;/p&gt;
+ * @argument nodeFrom the Node to copy the childNodes from
+ * @argument nodeTo the Node to copy the childNodes to
+ * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is
+ */ 
+Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
+    if((!nodeFrom) || (!nodeTo)){
+        throw &quot;Both source and destination nodes must be provided&quot;;
+    };
+    if(!bPreserveExisting){
+        Sarissa.clearChildNodes(nodeTo);
+    };
+    var nodes = nodeFrom.childNodes;
+    // if within the same doc, just move, else copy and delete
+    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
+        while(nodeFrom.firstChild){
+            nodeTo.appendChild(nodeFrom.firstChild);
+        };
+    } else {
+        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
+        if(typeof(ownerDoc.importNode) != &quot;undefined&quot;) {
+           for(var i=0;i &lt; nodes.length;i++) {
+               nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
+           };
+        }else{
+           for(var i=0;i &lt; nodes.length;i++) {
+               nodeTo.appendChild(nodes[i].cloneNode(true));
+           };
+        };
+        Sarissa.clearChildNodes(nodeFrom);
+    };
+};
+
+/** 
+ * &lt;p&gt;Serialize any object to an XML string. All properties are serialized using the property name
+ * as the XML element name. Array elements are rendered as &lt;code&gt;array-item&lt;/code&gt; elements, 
+ * using their index/key as the value of the &lt;code&gt;key&lt;/code&gt; attribute.&lt;/p&gt;
+ * @argument anyObject the object to serialize
+ * @argument objectName a name for that object
+ * @return the XML serializationj of the given object as a string
+ */
+Sarissa.xmlize = function(anyObject, objectName, indentSpace){
+    indentSpace = indentSpace?indentSpace:'';
+    var s = indentSpace  + '&lt;' + objectName + '&gt;';
+    var isLeaf = false;
+    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String 
+        || anyObject instanceof Boolean || anyObject instanceof Date){
+        s += Sarissa.escape(&quot;&quot;+anyObject);
+        isLeaf = true;
+    }else{
+        s += &quot;\n&quot;;
+        var itemKey = '';
+        var isArrayItem = anyObject instanceof Array;
+        for(var name in anyObject){
+            s += Sarissa.xmlize(anyObject[name], (isArrayItem?&quot;array-item key=\&quot;&quot;+name+&quot;\&quot;&quot;:name), indentSpace + &quot;   &quot;);
+        };
+        s += indentSpace;
+    };
+    return s += (objectName.indexOf(' ')!=-1?&quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot; + objectName + &quot;&gt;\n&quot;);
+};
+
+/** 
+ * Escape the given string chacters that correspond to the five predefined XML entities
+ * @param sXml the string to escape
+ */
+Sarissa.escape = function(sXml){
+    return sXml.replace(/&amp;/g, &quot;&amp;&quot;)
+        .replace(/&lt;/g, &quot;&lt;&quot;)
+        .replace(/&gt;/g, &quot;&gt;&quot;)
+        .replace(/&quot;/g, &quot;&quot;&quot;)
+        .replace(/'/g, &quot;&apos;&quot;);
+};
+
+/** 
+ * Unescape the given string. This turns the occurences of the predefined XML 
+ * entities to become the characters they represent correspond to the five predefined XML entities
+ * @param sXml the string to unescape
+ */
+Sarissa.unescape = function(sXml){
+    return sXml.replace(/&apos;/g,&quot;'&quot;)
+        .replace(/&quot;/g,&quot;\&quot;&quot;)
+        .replace(/&gt;/g,&quot;&gt;&quot;)
+        .replace(/&lt;/g,&quot;&lt;&quot;)
+        .replace(/&amp;/g,&quot;&amp;&quot;);
+};
+/*
+ * Sarissa's IE XPath Emulation 
+ */
+/**
+ * ====================================================================
+ * About
+ * ====================================================================
+ * Sarissa cross browser XML library - IE XPath Emulation 
+ * @version 0.9.7.6
+ * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
+ *
+ * This script emulates Internet Explorer's selectNodes and selectSingleNode
+ * for Mozilla. Associating namespace prefixes with URIs for your XPath queries
+ * is easy with IE's setProperty. 
+ * USers may also map a namespace prefix to a default (unprefixed) namespace in the
+ * source document with Sarissa.setXpathNamespaces
+ *
+ *
+ * ====================================================================
+ * Licence
+ * ====================================================================
+ * Sarissa is free software distributed under the GNU GPL version 2 (see &lt;a href=&quot;gpl.txt&quot;&gt;gpl.txt&lt;/a&gt;) or higher, 
+ * GNU LGPL version 2.1 (see &lt;a href=&quot;lgpl.txt&quot;&gt;lgpl.txt&lt;/a&gt;) or higher and Apache Software License 2.0 or higher 
+ * (see &lt;a href=&quot;asl.txt&quot;&gt;asl.txt&lt;/a&gt;). This means you can choose one of the three and use that if you like. If 
+ * you make modifications under the ASL, i would appreciate it if you submitted those.
+ * In case your copy of Sarissa does not include the license texts, you may find
+ * them online in various formats at &lt;a href=&quot;<A HREF="http://www.gnu.org">http://www.gnu.org</A>&quot;&gt;<A HREF="http://www.gnu.org&lt;/a">http://www.gnu.org&lt;/a</A>&gt; and 
+ * &lt;a href=&quot;<A HREF="http://www.apache.org">http://www.apache.org</A>&quot;&gt;<A HREF="http://www.apache.org&lt;/a">http://www.apache.org&lt;/a</A>&gt;.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY 
+ * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
+ * WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE 
+ * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+if(_SARISSA_HAS_DOM_FEATURE &amp;&amp; document.implementation.hasFeature(&quot;XPath&quot;, &quot;3.0&quot;)){
+    /**
+    * &lt;p&gt;SarissaNodeList behaves as a NodeList but is only used as a result to &lt;code&gt;selectNodes&lt;/code&gt;,
+    * so it also has some properties IEs proprietery object features.&lt;/p&gt;
+    * @private
+    * @constructor
+    * @argument i the (initial) list size
+    */
+    function SarissaNodeList(i){
+        this.length = i;
+    };
+    /** &lt;p&gt;Set an Array as the prototype object&lt;/p&gt; */
+    SarissaNodeList.prototype = new Array(0);
+    /** &lt;p&gt;Inherit the Array constructor &lt;/p&gt; */
+    SarissaNodeList.prototype.constructor = Array;
+    /**
+    * &lt;p&gt;Returns the node at the specified index or null if the given index
+    * is greater than the list size or less than zero &lt;/p&gt;
+    * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt; that in ECMAScript you can also use the square-bracket
+    * array notation instead of calling &lt;code&gt;item&lt;/code&gt;
+    * @argument i the index of the member to return
+    * @returns the member corresponding to the given index
+    */
+    SarissaNodeList.prototype.item = function(i) {
+        return (i &lt; 0 || i &gt;= this.length)?null:this[i];
+    };
+    /**
+    * &lt;p&gt;Emulate IE's expr property
+    * (Here the SarissaNodeList object is given as the result of selectNodes).&lt;/p&gt;
+    * @returns the XPath expression passed to selectNodes that resulted in
+    *          this SarissaNodeList
+    */
+    SarissaNodeList.prototype.expr = &quot;&quot;;
+    /** dummy, used to accept IE's stuff without throwing errors */
+    if(window.XMLDocument &amp;&amp; (!XMLDocument.prototype.setProperty)){
+        XMLDocument.prototype.setProperty  = function(x,y){};
+    };
+    /**
+    * &lt;p&gt;Programmatically control namespace URI/prefix mappings for XPath
+    * queries.&lt;/p&gt;
+    * &lt;p&gt;This method comes especially handy when used to apply XPath queries
+    * on XML documents with a default namespace, as there is no other way
+    * of mapping that to a prefix.&lt;/p&gt;
+    * &lt;p&gt;Using no namespace prefix in DOM Level 3 XPath queries, implies you
+    * are looking for elements in the null namespace. If you need to look
+    * for nodes in the default namespace, you need to map a prefix to it
+    * first like:&lt;/p&gt;
+    * &lt;pre&gt;Sarissa.setXpathNamespaces(oDoc, &quot;xmlns:myprefix=&amp;<A HREF="aposhttp://mynsURI&amp;amp;apos&amp;quot;">aposhttp://mynsURI&amp;apos&quot;</A>);&lt;/pre&gt;
+    * &lt;p&gt;&lt;b&gt;Note 1 &lt;/b&gt;: Use this method only if the source document features
+    * a default namespace (without a prefix), otherwise just use IE's setProperty
+    * (moz will rezolve non-default namespaces by itself). You will need to map that
+    * namespace to a prefix for queries to work.&lt;/p&gt;
+    * &lt;p&gt;&lt;b&gt;Note 2 &lt;/b&gt;: This method calls IE's setProperty method to set the
+    * appropriate namespace-prefix mappings, so you dont have to do that.&lt;/p&gt;
+    * @param oDoc The target XMLDocument to set the namespace mappings for.
+    * @param sNsSet A whilespace-seperated list of namespace declarations as
+    *            those would appear in an XML document. E.g.:
+    *            &lt;code&gt;&quot;xmlns:xhtml=&apos;<A HREF="http://www.w3.org/1999/xhtml&amp;apos;">http://www.w3.org/1999/xhtml&apos;</A>
+    * xmlns:&apos;<A HREF="http://www.w3.org/1999/XSL/Transform&amp;apos;&amp;quot;&lt;/code">http://www.w3.org/1999/XSL/Transform&apos;&quot;&lt;/code</A>&gt;
+    * @throws An error if the format of the given namespace declarations is bad.
+    */
+    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
+        //oDoc._sarissa_setXpathNamespaces(sNsSet);
+        oDoc._sarissa_useCustomResolver = true;
+        var namespaces = sNsSet.indexOf(&quot; &quot;)&gt;-1?sNsSet.split(&quot; &quot;):new Array(sNsSet);
+        oDoc._sarissa_xpathNamespaces = new Array(namespaces.length);
+        for(var i=0;i &lt; namespaces.length;i++){
+            var ns = namespaces[i];
+            var colonPos = ns.indexOf(&quot;:&quot;);
+            var assignPos = ns.indexOf(&quot;=&quot;);
+            if(colonPos &gt; 0 &amp;&amp; assignPos &gt; colonPos+1){
+                var prefix = ns.substring(colonPos+1, assignPos);
+                var uri = ns.substring(assignPos+2, ns.length-1);
+                oDoc._sarissa_xpathNamespaces[prefix] = uri;
+            }else{
+                throw &quot;Bad format on namespace declaration(s) given&quot;;
+            };
+        };
+    };
+    /**
+    * @private Flag to control whether a custom namespace resolver should
+    *          be used, set to true by Sarissa.setXpathNamespaces
+    */
+    XMLDocument.prototype._sarissa_useCustomResolver = false;
+    /** @private */
+    XMLDocument.prototype._sarissa_xpathNamespaces = new Array();
+    /**
+    * &lt;p&gt;Extends the XMLDocument to emulate IE's selectNodes.&lt;/p&gt;
+    * @argument sExpr the XPath expression to use
+    * @argument contextNode this is for internal use only by the same
+    *           method when called on Elements
+    * @returns the result of the XPath search as a SarissaNodeList
+    * @throws An error if no namespace URI is found for the given prefix.
+    */
+    XMLDocument.prototype.selectNodes = function(sExpr, contextNode, returnSingle){
+        var nsDoc = this;
+        var nsresolver = this._sarissa_useCustomResolver
+        ? function(prefix){
+            var s = nsDoc._sarissa_xpathNamespaces[prefix];
+            if(s)return s;
+            else throw &quot;No namespace URI found for prefix: '&quot; + prefix+&quot;'&quot;;
+            }
+        : this.createNSResolver(this.documentElement);
+        var result = null;
+        if(!returnSingle){
+            var oResult = this.evaluate(sExpr,
+                (contextNode?contextNode:this),
+                nsresolver,
+                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
+            var nodeList = new SarissaNodeList(oResult.snapshotLength);
+            nodeList.expr = sExpr;
+            for(var i=0;i&lt;nodeList.length;i++)
+                nodeList[i] = oResult.snapshotItem(i);
+            result = nodeList;
+        }
+        else {
+            result = oResult = this.evaluate(sExpr,
+                (contextNode?contextNode:this),
+                nsresolver,
+                XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
+        };
+        return result;      
+    };
+    /**
+    * &lt;p&gt;Extends the Element to emulate IE's selectNodes&lt;/p&gt;
+    * @argument sExpr the XPath expression to use
+    * @returns the result of the XPath search as an (Sarissa)NodeList
+    * @throws An
+    *             error if invoked on an HTML Element as this is only be
+    *             available to XML Elements.
+    */
+    Element.prototype.selectNodes = function(sExpr){
+        var doc = this.ownerDocument;
+        if(doc.selectNodes)
+            return doc.selectNodes(sExpr, this);
+        else
+            throw &quot;Method selectNodes is only supported by XML Elements&quot;;
+    };
+    /**
+    * &lt;p&gt;Extends the XMLDocument to emulate IE's selectSingleNode.&lt;/p&gt;
+    * @argument sExpr the XPath expression to use
+    * @argument contextNode this is for internal use only by the same
+    *           method when called on Elements
+    * @returns the result of the XPath search as an (Sarissa)NodeList
+    */
+    XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
+        var ctx = contextNode?contextNode:null;
+        return this.selectNodes(sExpr, ctx, true);
+    };
+    /**
+    * &lt;p&gt;Extends the Element to emulate IE's selectSingleNode.&lt;/p&gt;
+    * @argument sExpr the XPath expression to use
+    * @returns the result of the XPath search as an (Sarissa)NodeList
+    * @throws An error if invoked on an HTML Element as this is only be
+    *             available to XML Elements.
+    */
+    Element.prototype.selectSingleNode = function(sExpr){
+        var doc = this.ownerDocument;
+        if(doc.selectSingleNode)
+            return doc.selectSingleNode(sExpr, this);
+        else
+            throw &quot;Method selectNodes is only supported by XML Elements&quot;;
+    };
+    Sarissa.IS_ENABLED_SELECT_NODES = true;
+};
+if(_SARISSA_IS_IE)
+	 Sarissa.IS_ENABLED_SELECT_NODES = true;
+
+
+/**
   * Freja._aux
   * wrapper for external dependencies (frameworks).
   *
   * This is the minimal auxiliary adapter. It contains self-sufficient
   * implementations of all dependencies.
-  *
+  * 
   */
 if (typeof(Freja) == &quot;undefined&quot;) {
 	Freja = {};
@@ -29,11 +889,10 @@
     func.im_func = im_func;
     func.im_self = self;
 	return func;
-
 };
 /** formContents(elem) : Array */
 Freja._aux.formContents = function(elem) {
-	if (!elem) v = document;
+	if (!elem) elem = document;
 	var names = [];
 	var values = [];
 	var inputs = elem.getElementsByTagName(&quot;INPUT&quot;);
@@ -120,6 +979,11 @@
 	if (!src._signals[signal]) {
 		src._signals[signal] = [];
 	}
+	// checks if the callback has already been registered with the same function  (Thx to Chris D)
+	for(var item=0; item &lt; src._signals[signal].length;item++) {
+        if(src._signals[signal][item].toString() == fnc.toString()) return;
+    } 
+    
 	src._signals[signal].push(fnc);
 };
 /** signal(src, signal, ...) : void */
@@ -144,12 +1008,7 @@
 };
 /** openXMLHttpRequest(method, url, async, user, pass) : XMLHttpRequest */
 Freja._aux.openXMLHttpRequest = function(method, url, async, user, pass) {
-	var req;
-	method = method.toUpperCase();
-	try { req = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); }
-	catch (e) { try { req = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }
-	catch (e) { req = new XMLHttpRequest(); }}
-	if (!req) throw new Error(&quot;Can't create XMLHttpRequest&quot;);
+	var req = new XMLHttpRequest();
 	if (user &amp;&amp; pass) {
 		req.open(method, url, async, user, pass);
 	} else {
@@ -158,6 +1017,8 @@
 	if (method == &quot;POST&quot; || method == &quot;PUT&quot;) {
 		req.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
 	}
+	// RoR/cakePHP Ajax request detection compatibility:
+	req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');	
 	return req;
 };
 /** sendXMLHttpRequest(req, sendContent) : Deferred */
@@ -179,32 +1040,8 @@
 	return d;
 };
 /** xmlize(anyObject, objectName) : string */
-Freja._aux.xmlize = function(anyObject, objectName, indentSpace) {
-	var escape = function(sXml) {
-		return sXml.replace(/&amp;/g, &quot;&amp;&quot;)
-			.replace(/&lt;/g, &quot;&lt;&quot;)
-			.replace(/&gt;/g, &quot;&gt;&quot;)
-			.replace(/&quot;/g, &quot;&quot;&quot;)
-			.replace(/'/g, &quot;&apos;&quot;);
-	};
-	indentSpace = indentSpace ? indentSpace : '';
-	var s = indentSpace  + '&lt;' + objectName + '&gt;';
-	var isLeaf = false;
-	if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String
-	|| anyObject instanceof Boolean || anyObject instanceof Date){
-		s += escape(&quot;&quot;+anyObject);
-		isLeaf = true;
-	} else {
-		s += &quot;\n&quot;;
-		var itemKey = '';
-		var isArrayItem = anyObject instanceof Array;
-		for (var name in anyObject) {
-			s += Freja._aux.xmlize(anyObject[name], (isArrayItem ? &quot;array-item key=\&quot;&quot;+name+&quot;\&quot;&quot; : name), indentSpace + &quot;   &quot;);
-		};
-		s += indentSpace;
-	};
-	return s += (objectName.indexOf(' ') != -1 ? &quot;&lt;/array-item&gt;\n&quot;:&quot;&lt;/&quot; + objectName + &quot;&gt;\n&quot;);
-};
+Freja._aux.xmlize = Sarissa.xmlize;
+
 /** serializeXML(node) : string */
 Freja._aux.serializeXML = function(node) {
 	if (node.xml) return node.xml;
@@ -212,44 +1049,19 @@
 };
 /** loadXML(string) : XMLDocument */
 Freja._aux.loadXML = function(text) {
-	if (window.ActiveXObject) {
-		var xmlDoc = new ActiveXObject(&quot;Msxml2.DOMDocument&quot;);
-		xmlDoc.loadXML(text);
-		xmlDoc.setProperty(&quot;SelectionLanguage&quot;, &quot;XPath&quot;);
-		return xmlDoc;
-	}
 	return (new DOMParser()).parseFromString(text, &quot;text/xml&quot;);
 };
 /** transformXSL(XMLDocument, XSLDocument) : string */
 Freja._aux.transformXSL = function(xml, xsl, xslParameters) {
-	if (typeof(xml.transformNode) != &quot;undefined&quot;) {
-		// set the parameters
+	var processor = new XSLTProcessor();
+	processor.importStylesheet(xsl);
+	if(xslParameters) {
 		for (var paramName in xslParameters) {
-			xsl.setProperty (&quot;SelectionNamespaces&quot;, &quot;xmlns:xsl='<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>'&quot;);
-			var paramNode = xsl.selectSingleNode(&quot;//xsl:param[@name='&quot;+ paramName +&quot;']&quot;);
-			paramNode.appendChild(xsl.createTextNode(xslParameters[paramName]));
-			// @TODO: check if we have the 'select' attribute and remove it.
+			processor.setParameter(&quot;&quot;, paramName, xslParameters[paramName]);
 		}
-		var result = xml.transformNode(xsl);
-
-		// clean the stylesheet.
-		for (var paramName in xslParameters) {
-			var paramNode = xsl.selectSingleNode(&quot;//xsl:param[@name='&quot;+ paramName +&quot;']&quot;);
-			while(paramNode.firstChild) {
-				paramNode.removeChild(paramNode.firstChild);
-			}
-		}
-		return result;
-	};
-
-	var processor = new XSLTProcessor();
-	processor.importStylesheet(xsl);
-	for (var paramName in xslParameters) {
-		processor.setParameter(null, paramName, xslParameters[paramName]);
 	}
-	// return Freja._aux.serializeXML(processor.transformToDocument(xml));
-	return processor.transformToDocument(xml);
-
+	 
+	return processor.transformToFragment(xml, window.document);
 };
 /** cloneXMLDocument(document) : XMLDocument */
 Freja._aux.cloneXMLDocument = function(xmlDoc) {
@@ -288,7 +1100,7 @@
 Freja._aux.hasSupportForXSLT = function() { return (typeof(XSLTProcessor) != &quot;undefined&quot;); };
 /** createQueryEngine() : Freja.QueryEngine */
 Freja._aux.createQueryEngine = function() {
-	if (window.ActiveXObject || (document.implementation &amp;&amp; document.implementation.hasFeature(&quot;XPath&quot;, &quot;3.0&quot;))) {
+	if (Sarissa.IS_ENABLED_SELECT_NODES) {
 		return new Freja.QueryEngine.XPath();
 	} else {
 		return new Freja.QueryEngine.SimplePath();
@@ -333,120 +1145,3 @@
 Freja._aux.Deferred.prototype.addErrback = function(fncError) {
 	this.addCallbacks(null, fncError);
 };
-if (document.implementation &amp;&amp; document.implementation.hasFeature(&quot;XPath&quot;, &quot;3.0&quot;)) {
-	// Opera 9 XMLDocument Fix. Thanks to Chris D.
-	if(!XMLDocument) {
-	   var XMLDocument = Document;
-	}	
-
-	XMLDocument.prototype.selectNodes = function(sExpr, contextNode) {
-		var nsDoc = this;
-		var nsresolver = this.createNSResolver(this.documentElement);
-
-		try {
-			var oResult = this.evaluate(sExpr,
-				(contextNode ? contextNode : this),
-				nsresolver,
-				XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
-		} catch(e) {
-			throw new Error(&quot;Can't evaluate expression &quot; + sExpr);
-		}
-		var nodeList = new Array(oResult.snapshotLength);
-		nodeList.item = function(i) {
-			return (i &lt; 0 || i &gt;= this.length) ? null : this[i];
-		};
-		nodeList.expr = sExpr;
-		for (var i = 0;i &lt; nodeList.length; i++) {
-			nodeList[i] = oResult.snapshotItem(i);
-		};
-		return nodeList;
-	    };
-	Element.prototype.selectNodes = function(sExpr) {
-		var doc = this.ownerDocument;
-		if (doc.selectNodes) {
-			return doc.selectNodes(sExpr, this);
-		} else {
-			throw new Error(&quot;Method selectNodes is only supported by XML Elements&quot;);
-		};
-	};
-	XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode) {
-		var ctx = contextNode ? contextNode : null;
-		sExpr = &quot;(&quot;+sExpr+&quot;)[1]&quot;;
-		var nodeList = this.selectNodes(sExpr, ctx);
-		if (nodeList.length &gt; 0) {
-			return nodeList.item(0);
-		} else {
-			return null;
-		}
-	};
-	Element.prototype.selectSingleNode = function(sExpr) {
-		var doc = this.ownerDocument;
-		if (doc.selectSingleNode) {
-			return doc.selectSingleNode(sExpr, this);
-		} else {
-			throw new Error(&quot;Method selectNodes is only supported by XML Elements&quot;);
-		}
-	};
-};
-
-// Adapated From Sarissa
-// * @version 0.9.6.1
-// * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
-
-Freja._aux.pickRecentProgID = function(idList) {
-    var bFound = false;
-    for(var i=0; i &lt; idList.length &amp;&amp; !bFound; i++){
-        try{
-            var oDoc = new ActiveXObject(idList[i]);
-            return idList[i];
-        } catch (objException){ // trap; try next progID
-        };
-    };
-    throw &quot;Could not retrieve a valid progID.&quot;;
-}
-
-if(typeof XSLTProcessor == 'undefined' &amp;&amp; typeof ActiveXObject  != 'undefined') {
-
-    _SARISSA_DOM_PROGID = Freja._aux.pickRecentProgID([&quot;Msxml2.DOMDocument.5.0&quot;, &quot;Msxml2.DOMDocument.4.0&quot;, &quot;Msxml2.DOMDocument.3.0&quot;, &quot;MSXML2.DOMDocument&quot;, &quot;MSXML.DOMDocument&quot;, &quot;Microsoft.XMLDOM&quot;]);
-    _SARISSA_XMLHTTP_PROGID = Freja._aux.pickRecentProgID([&quot;Msxml2.XMLHTTP.5.0&quot;, &quot;Msxml2.XMLHTTP.4.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]);
-    _SARISSA_THREADEDDOM_PROGID = Freja._aux.pickRecentProgID([&quot;Msxml2.FreeThreadedDOMDocument.5.0&quot;, &quot;MSXML2.FreeThreadedDOMDocument.4.0&quot;, &quot;MSXML2.FreeThreadedDOMDocument.3.0&quot;]);
-    _SARISSA_XSLTEMPLATE_PROGID = Freja._aux.pickRecentProgID([&quot;Msxml2.XSLTemplate.5.0&quot;, &quot;Msxml2.XSLTemplate.4.0&quot;, &quot;MSXML2.XSLTemplate.3.0&quot;]);
-
-	XSLTProcessor = function(){
-	    this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
-	    this.processor = null;
-	};
-
-	XSLTProcessor.prototype.importStylesheet = function(xslDoc){
-	    // convert stylesheet to free threaded
-	    var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID);
-	    converted.loadXML(xslDoc.xml);
-	    this.template.stylesheet = converted;
-	    this.processor = this.template.createProcessor();
-	    // (re)set default param values
-	    this.paramsSet = new Array();
-	};
-
-	XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
-	    this.processor.input = sourceDoc;
-	    var outDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
-	    this.processor.output = outDoc;
-	    this.processor.transform();
-	    return outDoc;
-	};
-
-	XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
-	    /* nsURI is optional but cannot be null */
-	    if(nsURI){
-	        this.processor.addParameter(name, value, nsURI);
-	    }else{
-	        this.processor.addParameter(name, value);
-	    };
-	    /* update updated params for getParameter */
-	    if(!this.paramsSet[&quot;&quot;+nsURI]){
-	        this.paramsSet[&quot;&quot;+nsURI] = new Array();
-	    };
-	    this.paramsSet[&quot;&quot;+nsURI][name] = value;
-	};
-
-}

Modified: branch/2.0.1/src/auxiliary/mochi+sarissa.js
===================================================================
--- branch/2.0.1/src/auxiliary/mochi+sarissa.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/src/auxiliary/mochi+sarissa.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -43,7 +43,50 @@
 /** bind(func, self) : function */
 Freja._aux.bind = MochiKit.Base.bind;
 /** formContents(elem) : Array */
-Freja._aux.formContents = MochiKit.DOM.formContents;
+Freja._aux.formContents = function(elem) {
+	if (!elem) elem = document;
+	var names = [];
+	var values = [];
+	var inputs = elem.getElementsByTagName(&quot;INPUT&quot;);
+	for (var i = 0; i &lt; inputs.length; ++i) {
+		var input = inputs[i];
+		if (input.name) {
+			if (input.type == &quot;radio&quot; || input.type == &quot;checkbox&quot;) {
+				if (input.checked) {
+					names.push(input.name);
+					values.push(input.value);
+				} else {
+					names.push(input.name);
+					values.push(&quot;&quot;);
+				}
+			} else {
+				names.push(input.name);
+				values.push(input.value);
+			}
+		}
+	}
+	var textareas = elem.getElementsByTagName(&quot;TEXTAREA&quot;);
+	for (var i = 0; i &lt; textareas.length; ++i) {
+		var input = textareas[i];
+		if (input.name) {
+			names.push(input.name);
+			values.push(input.value);
+		}
+	}
+	var selects = elem.getElementsByTagName(&quot;SELECT&quot;);
+	for (var i = 0; i &lt; selects.length; ++i) {
+		var input = selects[i];
+		if (input.name) {
+			if (input.selectedIndex &gt;= 0) {
+				var opt = input.options[input.selectedIndex];
+				names.push(input.name);
+				values.push((opt.value) ? opt.value : &quot;&quot;);
+			}
+		}
+	}
+	return [names, values];
+};
+
 /** getElement(id) : HTMLElement */
 Freja._aux.getElement = MochiKit.DOM.getElement;
 
@@ -89,7 +132,7 @@
 	processor.importStylesheet(xsl);
 	if(xslParameters) {
 		for (var paramName in xslParameters) {
-			processor.setParameter(null, paramName, xslParameters[paramName]);
+			processor.setParameter(&quot;&quot;, paramName, xslParameters[paramName]);
 		}
 	}
 	 

Modified: branch/2.0.1/tests/test_Freja-Model.html
===================================================================
--- branch/2.0.1/tests/test_Freja-Model.html	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/tests/test_Freja-Model.html	2007-03-19 22:07:30 UTC (rev 82)
@@ -1,11 +1,12 @@
 &lt;html&gt;
 &lt;head&gt;
+	&lt;title&gt;Freja Test Suite&lt;/title&gt;
     &lt;!-- MochiKit is needed by SimpleTest --&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;../lib/MochiKit.js&quot;&gt;&lt;/script&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;SimpleTest/SimpleTest.js&quot;&gt;&lt;/script&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;../lib/Sarissa.js&quot;&gt;&lt;/script&gt;
     &lt;script type=&quot;text/javascript&quot; src=&quot;../lib/Freja.js&quot;&gt;&lt;/script&gt;
-    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;SimpleTest/test.css&quot;&gt;
+    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;SimpleTest/test.css&quot; /&gt;
 &lt;/head&gt;
 &lt;body&gt;
 

Modified: branch/2.0.1/tests/test_View.js
===================================================================
--- branch/2.0.1/tests/test_View.js	2007-03-19 22:04:37 UTC (rev 81)
+++ branch/2.0.1/tests/test_View.js	2007-03-19 22:07:30 UTC (rev 82)
@@ -32,7 +32,7 @@
 	};
 	view.render(pojo, out);
 
-	t.ok(out.innerHTML.toLowerCase().match(&quot;&lt;p&gt;plain old javascript object&lt;/p&gt;&quot;));
+	t.ok(out.innerHTML.toLowerCase().match(&quot;&lt;p&gt;plain old javascript object&lt;/p&gt;&quot;),&quot;The rendered view should contain the text 'plain old javascript object'&quot;);
 
 	// test of form
 	var formView = Freja.AssetManager.getView(&quot;data/form-view.xsl&quot;);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000079.html">[Freja-svn] r81 - branch/2.0.1/src
</A></li>
	<LI>Next message: <A HREF="000081.html">[Freja-svn] r83 - in branch/2.0.1/examples/basecamp_api: . css views
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#80">[ date ]</a>
              <a href="thread.html#80">[ thread ]</a>
              <a href="subject.html#80">[ subject ]</a>
              <a href="author.html#80">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/freja-svn">More information about the Freja-svn
mailing list</a><br>
</body></html>
