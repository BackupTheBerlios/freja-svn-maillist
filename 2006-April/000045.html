<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Freja-svn] r49 - in trunk/examples: . basecamp_api basecamp_api/proxy basecamp_api/proxy/php basecamp_api/views
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/freja-svn/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:freja-svn%40lists.berlios.de?Subject=Re%3A%20%5BFreja-svn%5D%20r49%20-%20in%20trunk/examples%3A%20.%20basecamp_api%20basecamp_api/proxy%20basecamp_api/proxy/php%20basecamp_api/views&In-Reply-To=%3C200604182135.k3ILZ58c011033%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000044.html">
   <LINK REL="Next"  HREF="000046.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Freja-svn] r49 - in trunk/examples: . basecamp_api basecamp_api/proxy basecamp_api/proxy/php basecamp_api/views</H1>
    <B>cedsav at berlios.de</B> 
    <A HREF="mailto:freja-svn%40lists.berlios.de?Subject=Re%3A%20%5BFreja-svn%5D%20r49%20-%20in%20trunk/examples%3A%20.%20basecamp_api%20basecamp_api/proxy%20basecamp_api/proxy/php%20basecamp_api/views&In-Reply-To=%3C200604182135.k3ILZ58c011033%40sheep.berlios.de%3E"
       TITLE="[Freja-svn] r49 - in trunk/examples: . basecamp_api basecamp_api/proxy basecamp_api/proxy/php basecamp_api/views">cedsav at berlios.de
       </A><BR>
    <I>Tue Apr 18 23:35:05 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000044.html">[Freja-svn] r48 - trunk/src
</A></li>
        <LI>Next message: <A HREF="000046.html">[Freja-svn] r50 - trunk/examples/basecamp_api/proxy/php
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: cedsav
Date: 2006-04-18 23:34:47 +0200 (Tue, 18 Apr 2006)
New Revision: 49

Added:
   trunk/examples/basecamp_api/
   trunk/examples/basecamp_api/basecamp.js
   trunk/examples/basecamp_api/index.html
   trunk/examples/basecamp_api/models/
   trunk/examples/basecamp_api/proxy/
   trunk/examples/basecamp_api/proxy/php/
   trunk/examples/basecamp_api/proxy/php/PEAR.php
   trunk/examples/basecamp_api/proxy/php/Request.php
   trunk/examples/basecamp_api/proxy/php/Socket.php
   trunk/examples/basecamp_api/proxy/php/URL.php
   trunk/examples/basecamp_api/proxy/php/proxy.php
   trunk/examples/basecamp_api/views/
   trunk/examples/basecamp_api/views/project.xsl
Log:


Added: trunk/examples/basecamp_api/basecamp.js
===================================================================
--- trunk/examples/basecamp_api/basecamp.js	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/basecamp.js	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,2 @@
+
+

Added: trunk/examples/basecamp_api/index.html
===================================================================
--- trunk/examples/basecamp_api/index.html	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/index.html	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,18 @@
+&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;<A HREF="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</A>&quot;&gt;
+&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot;&gt;
+&lt;head&gt;
+&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
+&lt;title&gt;BaseCamp Remixed with Freja&lt;/title&gt;
+
+&lt;!-- Freja Framework Script --&gt;
+&lt;script type=&quot;text/javascript&quot; src=&quot;../../lib/Freja.js&quot;&gt;&lt;/script&gt;
+
+&lt;!-- Controller Code --&gt;
+&lt;script type=&quot;text/javascript&quot; src=&quot;basecamp.js&quot;&gt;&lt;/script&gt;
+
+&lt;/head&gt;
+
+&lt;body&gt;
+&lt;div id=&quot;content&quot;&gt;&lt;span style=&quot;color:white;background:firebrick&quot;&gt;Loading ...&lt;/span&gt;&lt;/div&gt;
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/examples/basecamp_api/proxy/php/PEAR.php
===================================================================
--- trunk/examples/basecamp_api/proxy/php/PEAR.php	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/proxy/php/PEAR.php	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,1101 @@
+&lt;?php
+/**
+ * PEAR, the PHP Extension and Application Repository
+ *
+ * PEAR class and PEAR_Error class
+ *
+ * PHP versions 4 and 5
+ *
+ * LICENSE: This source file is subject to version 3.0 of the PHP license
+ * that is available through the world-wide-web at the following URI:
+ * <A HREF="http://www.php.net/license/3_0.txt.">http://www.php.net/license/3_0.txt.</A>  If you did not receive a copy of
+ * the PHP License and are unable to obtain it through the web, please
+ * send a note to <A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">license at php.net</A> so we can mail you a copy immediately.
+ *
+ * @category   pear
+ * @package    PEAR
+ * @author     Sterling Hughes &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">sterling at php.net</A>&gt;
+ * @author     Stig Bakken &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">ssb at php.net</A>&gt;
+ * @author     Tomas V.V.Cox &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cox at idecnet.com</A>&gt;
+ * @author     Greg Beaver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cellog at php.net</A>&gt;
+ * @copyright  1997-2006 The PHP Group
+ * @license    <A HREF="http://www.php.net/license/3_0.txt">http://www.php.net/license/3_0.txt</A>  PHP License 3.0
+ * @version    CVS: $Id: PEAR.php,v 1.98 2006/01/23 05:38:05 cellog Exp $
+ * @link       <A HREF="http://pear.php.net/package/PEAR">http://pear.php.net/package/PEAR</A>
+ * @since      File available since Release 0.1
+ */
+
+/**#@+
+ * ERROR constants
+ */
+define('PEAR_ERROR_RETURN',     1);
+define('PEAR_ERROR_PRINT',      2);
+define('PEAR_ERROR_TRIGGER',    4);
+define('PEAR_ERROR_DIE',        8);
+define('PEAR_ERROR_CALLBACK',  16);
+/**
+ * WARNING: obsolete
+ * @deprecated
+ */
+define('PEAR_ERROR_EXCEPTION', 32);
+/**#@-*/
+define('PEAR_ZE2', (function_exists('version_compare') &amp;&amp;
+                    version_compare(zend_version(), &quot;2-dev&quot;, &quot;ge&quot;)));
+
+if (substr(PHP_OS, 0, 3) == 'WIN') {
+    define('OS_WINDOWS', true);
+    define('OS_UNIX',    false);
+    define('PEAR_OS',    'Windows');
+} else {
+    define('OS_WINDOWS', false);
+    define('OS_UNIX',    true);
+    define('PEAR_OS',    'Unix'); // blatant assumption
+}
+
+// instant backwards compatibility
+if (!defined('PATH_SEPARATOR')) {
+    if (OS_WINDOWS) {
+        define('PATH_SEPARATOR', ';');
+    } else {
+        define('PATH_SEPARATOR', ':');
+    }
+}
+
+$GLOBALS['_PEAR_default_error_mode']     = PEAR_ERROR_RETURN;
+$GLOBALS['_PEAR_default_error_options']  = E_USER_NOTICE;
+$GLOBALS['_PEAR_destructor_object_list'] = array();
+$GLOBALS['_PEAR_shutdown_funcs']         = array();
+$GLOBALS['_PEAR_error_handler_stack']    = array();
+
<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">+ at ini_set</A>('track_errors', true);
+
+/**
+ * Base class for other PEAR classes.  Provides rudimentary
+ * emulation of destructors.
+ *
+ * If you want a destructor in your class, inherit PEAR and make a
+ * destructor method called _yourclassname (same name as the
+ * constructor, but with a &quot;_&quot; prefix).  Also, in your constructor you
+ * have to call the PEAR constructor: $this-&gt;PEAR();.
+ * The destructor method will be called without parameters.  Note that
+ * at in some SAPI implementations (such as Apache), any output during
+ * the request shutdown (in which destructors are called) seems to be
+ * discarded.  If you need to get any debug information from your
+ * destructor, use error_log(), syslog() or something similar.
+ *
+ * IMPORTANT! To use the emulated destructors you need to create the
+ * objects by reference: $obj =&amp; new PEAR_child;
+ *
+ * @category   pear
+ * @package    PEAR
+ * @author     Stig Bakken &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">ssb at php.net</A>&gt;
+ * @author     Tomas V.V. Cox &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cox at idecnet.com</A>&gt;
+ * @author     Greg Beaver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cellog at php.net</A>&gt;
+ * @copyright  1997-2006 The PHP Group
+ * @license    <A HREF="http://www.php.net/license/3_0.txt">http://www.php.net/license/3_0.txt</A>  PHP License 3.0
+ * @version    Release: 1.4.9
+ * @link       <A HREF="http://pear.php.net/package/PEAR">http://pear.php.net/package/PEAR</A>
+ * @see        PEAR_Error
+ * @since      Class available since PHP 4.0.2
+ * @link        <A HREF="http://pear.php.net/manual/en/core.pear.php#core.pear.pear">http://pear.php.net/manual/en/core.pear.php#core.pear.pear</A>
+ */
+class PEAR
+{
+    // {{{ properties
+
+    /**
+     * Whether to enable internal debug messages.
+     *
+     * @var     bool
+     * @access  private
+     */
+    var $_debug = false;
+
+    /**
+     * Default error mode for this object.
+     *
+     * @var     int
+     * @access  private
+     */
+    var $_default_error_mode = null;
+
+    /**
+     * Default error options used for this object when error mode
+     * is PEAR_ERROR_TRIGGER.
+     *
+     * @var     int
+     * @access  private
+     */
+    var $_default_error_options = null;
+
+    /**
+     * Default error handler (callback) for this object, if error mode is
+     * PEAR_ERROR_CALLBACK.
+     *
+     * @var     string
+     * @access  private
+     */
+    var $_default_error_handler = '';
+
+    /**
+     * Which class to use for error objects.
+     *
+     * @var     string
+     * @access  private
+     */
+    var $_error_class = 'PEAR_Error';
+
+    /**
+     * An array of expected errors.
+     *
+     * @var     array
+     * @access  private
+     */
+    var $_expected_errors = array();
+
+    // }}}
+
+    // {{{ constructor
+
+    /**
+     * Constructor.  Registers this object in
+     * $_PEAR_destructor_object_list for destructor emulation if a
+     * destructor object exists.
+     *
+     * @param string $error_class  (optional) which class to use for
+     *        error objects, defaults to PEAR_Error.
+     * @access public
+     * @return void
+     */
+    function PEAR($error_class = null)
+    {
+        $classname = strtolower(get_class($this));
+        if ($this-&gt;_debug) {
+            print &quot;PEAR constructor called, class=$classname\n&quot;;
+        }
+        if ($error_class !== null) {
+            $this-&gt;_error_class = $error_class;
+        }
+        while ($classname &amp;&amp; strcasecmp($classname, &quot;pear&quot;)) {
+            $destructor = &quot;_$classname&quot;;
+            if (method_exists($this, $destructor)) {
+                global $_PEAR_destructor_object_list;
+                $_PEAR_destructor_object_list[] = &amp;$this;
+                if (!isset($GLOBALS['_PEAR_SHUTDOWN_REGISTERED'])) {
+                    register_shutdown_function(&quot;_PEAR_call_destructors&quot;);
+                    $GLOBALS['_PEAR_SHUTDOWN_REGISTERED'] = true;
+                }
+                break;
+            } else {
+                $classname = get_parent_class($classname);
+            }
+        }
+    }
+
+    // }}}
+    // {{{ destructor
+
+    /**
+     * Destructor (the emulated type of...).  Does nothing right now,
+     * but is included for forward compatibility, so subclass
+     * destructors should always call it.
+     *
+     * See the note in the class desciption about output from
+     * destructors.
+     *
+     * @access public
+     * @return void
+     */
+    function _PEAR() {
+        if ($this-&gt;_debug) {
+            printf(&quot;PEAR destructor called, class=%s\n&quot;, strtolower(get_class($this)));
+        }
+    }
+
+    // }}}
+    // {{{ getStaticProperty()
+
+    /**
+    * If you have a class that's mostly/entirely static, and you need static
+    * properties, you can use this method to simulate them. Eg. in your method(s)
+    * do this: $myVar = &amp;PEAR::getStaticProperty('myclass', 'myVar');
+    * You MUST use a reference, or they will not persist!
+    *
+    * @access public
+    * @param  string $class  The calling classname, to prevent clashes
+    * @param  string $var    The variable to retrieve.
+    * @return mixed   A reference to the variable. If not set it will be
+    *                 auto initialised to NULL.
+    */
+    function &amp;getStaticProperty($class, $var)
+    {
+        static $properties;
+        return $properties[$class][$var];
+    }
+
+    // }}}
+    // {{{ registerShutdownFunc()
+
+    /**
+    * Use this function to register a shutdown method for static
+    * classes.
+    *
+    * @access public
+    * @param  mixed $func  The function name (or array of class/method) to call
+    * @param  mixed $args  The arguments to pass to the function
+    * @return void
+    */
+    function registerShutdownFunc($func, $args = array())
+    {
+        // if we are called statically, there is a potential
+        // that no shutdown func is registered.  Bug #6445
+        if (!isset($GLOBALS['_PEAR_SHUTDOWN_REGISTERED'])) {
+            register_shutdown_function(&quot;_PEAR_call_destructors&quot;);
+            $GLOBALS['_PEAR_SHUTDOWN_REGISTERED'] = true;
+        }
+        $GLOBALS['_PEAR_shutdown_funcs'][] = array($func, $args);
+    }
+
+    // }}}
+    // {{{ isError()
+
+    /**
+     * Tell whether a value is a PEAR error.
+     *
+     * @param   mixed $data   the value to test
+     * @param   int   $code   if $data is an error object, return true
+     *                        only if $code is a string and
+     *                        $obj-&gt;getMessage() == $code or
+     *                        $code is an integer and $obj-&gt;getCode() == $code
+     * @access  public
+     * @return  bool    true if parameter is an error
+     */
+    function isError($data, $code = null)
+    {
+        if (is_a($data, 'PEAR_Error')) {
+            if (is_null($code)) {
+                return true;
+            } elseif (is_string($code)) {
+                return $data-&gt;getMessage() == $code;
+            } else {
+                return $data-&gt;getCode() == $code;
+            }
+        }
+        return false;
+    }
+
+    // }}}
+    // {{{ setErrorHandling()
+
+    /**
+     * Sets how errors generated by this object should be handled.
+     * Can be invoked both in objects and statically.  If called
+     * statically, setErrorHandling sets the default behaviour for all
+     * PEAR objects.  If called in an object, setErrorHandling sets
+     * the default behaviour for that object.
+     *
+     * @param int $mode
+     *        One of PEAR_ERROR_RETURN, PEAR_ERROR_PRINT,
+     *        PEAR_ERROR_TRIGGER, PEAR_ERROR_DIE,
+     *        PEAR_ERROR_CALLBACK or PEAR_ERROR_EXCEPTION.
+     *
+     * @param mixed $options
+     *        When $mode is PEAR_ERROR_TRIGGER, this is the error level (one
+     *        of E_USER_NOTICE, E_USER_WARNING or E_USER_ERROR).
+     *
+     *        When $mode is PEAR_ERROR_CALLBACK, this parameter is expected
+     *        to be the callback function or method.  A callback
+     *        function is a string with the name of the function, a
+     *        callback method is an array of two elements: the element
+     *        at index 0 is the object, and the element at index 1 is
+     *        the name of the method to call in the object.
+     *
+     *        When $mode is PEAR_ERROR_PRINT or PEAR_ERROR_DIE, this is
+     *        a printf format string used when printing the error
+     *        message.
+     *
+     * @access public
+     * @return void
+     * @see PEAR_ERROR_RETURN
+     * @see PEAR_ERROR_PRINT
+     * @see PEAR_ERROR_TRIGGER
+     * @see PEAR_ERROR_DIE
+     * @see PEAR_ERROR_CALLBACK
+     * @see PEAR_ERROR_EXCEPTION
+     *
+     * @since PHP 4.0.5
+     */
+
+    function setErrorHandling($mode = null, $options = null)
+    {
+        if (isset($this) &amp;&amp; is_a($this, 'PEAR')) {
+            $setmode     = &amp;$this-&gt;_default_error_mode;
+            $setoptions  = &amp;$this-&gt;_default_error_options;
+        } else {
+            $setmode     = &amp;$GLOBALS['_PEAR_default_error_mode'];
+            $setoptions  = &amp;$GLOBALS['_PEAR_default_error_options'];
+        }
+
+        switch ($mode) {
+            case PEAR_ERROR_EXCEPTION:
+            case PEAR_ERROR_RETURN:
+            case PEAR_ERROR_PRINT:
+            case PEAR_ERROR_TRIGGER:
+            case PEAR_ERROR_DIE:
+            case null:
+                $setmode = $mode;
+                $setoptions = $options;
+                break;
+
+            case PEAR_ERROR_CALLBACK:
+                $setmode = $mode;
+                // class/object method callback
+                if (is_callable($options)) {
+                    $setoptions = $options;
+                } else {
+                    trigger_error(&quot;invalid error callback&quot;, E_USER_WARNING);
+                }
+                break;
+
+            default:
+                trigger_error(&quot;invalid error mode&quot;, E_USER_WARNING);
+                break;
+        }
+    }
+
+    // }}}
+    // {{{ expectError()
+
+    /**
+     * This method is used to tell which errors you expect to get.
+     * Expected errors are always returned with error mode
+     * PEAR_ERROR_RETURN.  Expected error codes are stored in a stack,
+     * and this method pushes a new element onto it.  The list of
+     * expected errors are in effect until they are popped off the
+     * stack with the popExpect() method.
+     *
+     * Note that this method can not be called statically
+     *
+     * @param mixed $code a single error code or an array of error codes to expect
+     *
+     * @return int     the new depth of the &quot;expected errors&quot; stack
+     * @access public
+     */
+    function expectError($code = '*')
+    {
+        if (is_array($code)) {
+            array_push($this-&gt;_expected_errors, $code);
+        } else {
+            array_push($this-&gt;_expected_errors, array($code));
+        }
+        return sizeof($this-&gt;_expected_errors);
+    }
+
+    // }}}
+    // {{{ popExpect()
+
+    /**
+     * This method pops one element off the expected error codes
+     * stack.
+     *
+     * @return array   the list of error codes that were popped
+     */
+    function popExpect()
+    {
+        return array_pop($this-&gt;_expected_errors);
+    }
+
+    // }}}
+    // {{{ _checkDelExpect()
+
+    /**
+     * This method checks unsets an error code if available
+     *
+     * @param mixed error code
+     * @return bool true if the error code was unset, false otherwise
+     * @access private
+     * @since PHP 4.3.0
+     */
+    function _checkDelExpect($error_code)
+    {
+        $deleted = false;
+
+        foreach ($this-&gt;_expected_errors AS $key =&gt; $error_array) {
+            if (in_array($error_code, $error_array)) {
+                unset($this-&gt;_expected_errors[$key][array_search($error_code, $error_array)]);
+                $deleted = true;
+            }
+
+            // clean up empty arrays
+            if (0 == count($this-&gt;_expected_errors[$key])) {
+                unset($this-&gt;_expected_errors[$key]);
+            }
+        }
+        return $deleted;
+    }
+
+    // }}}
+    // {{{ delExpect()
+
+    /**
+     * This method deletes all occurences of the specified element from
+     * the expected error codes stack.
+     *
+     * @param  mixed $error_code error code that should be deleted
+     * @return mixed list of error codes that were deleted or error
+     * @access public
+     * @since PHP 4.3.0
+     */
+    function delExpect($error_code)
+    {
+        $deleted = false;
+
+        if ((is_array($error_code) &amp;&amp; (0 != count($error_code)))) {
+            // $error_code is a non-empty array here;
+            // we walk through it trying to unset all
+            // values
+            foreach($error_code as $key =&gt; $error) {
+                if ($this-&gt;_checkDelExpect($error)) {
+                    $deleted =  true;
+                } else {
+                    $deleted = false;
+                }
+            }
+            return $deleted ? true : PEAR::raiseError(&quot;The expected error you submitted does not exist&quot;); // IMPROVE ME
+        } elseif (!empty($error_code)) {
+            // $error_code comes alone, trying to unset it
+            if ($this-&gt;_checkDelExpect($error_code)) {
+                return true;
+            } else {
+                return PEAR::raiseError(&quot;The expected error you submitted does not exist&quot;); // IMPROVE ME
+            }
+        } else {
+            // $error_code is empty
+            return PEAR::raiseError(&quot;The expected error you submitted is empty&quot;); // IMPROVE ME
+        }
+    }
+
+    // }}}
+    // {{{ raiseError()
+
+    /**
+     * This method is a wrapper that returns an instance of the
+     * configured error class with this object's default error
+     * handling applied.  If the $mode and $options parameters are not
+     * specified, the object's defaults are used.
+     *
+     * @param mixed $message a text error message or a PEAR error object
+     *
+     * @param int $code      a numeric error code (it is up to your class
+     *                  to define these if you want to use codes)
+     *
+     * @param int $mode      One of PEAR_ERROR_RETURN, PEAR_ERROR_PRINT,
+     *                  PEAR_ERROR_TRIGGER, PEAR_ERROR_DIE,
+     *                  PEAR_ERROR_CALLBACK, PEAR_ERROR_EXCEPTION.
+     *
+     * @param mixed $options If $mode is PEAR_ERROR_TRIGGER, this parameter
+     *                  specifies the PHP-internal error level (one of
+     *                  E_USER_NOTICE, E_USER_WARNING or E_USER_ERROR).
+     *                  If $mode is PEAR_ERROR_CALLBACK, this
+     *                  parameter specifies the callback function or
+     *                  method.  In other error modes this parameter
+     *                  is ignored.
+     *
+     * @param string $userinfo If you need to pass along for example debug
+     *                  information, this parameter is meant for that.
+     *
+     * @param string $error_class The returned error object will be
+     *                  instantiated from this class, if specified.
+     *
+     * @param bool $skipmsg If true, raiseError will only pass error codes,
+     *                  the error message parameter will be dropped.
+     *
+     * @access public
+     * @return object   a PEAR error object
+     * @see PEAR::setErrorHandling
+     * @since PHP 4.0.5
+     */
+    function &amp;raiseError($message = null,
+                         $code = null,
+                         $mode = null,
+                         $options = null,
+                         $userinfo = null,
+                         $error_class = null,
+                         $skipmsg = false)
+    {
+        // The error is yet a PEAR error object
+        if (is_object($message)) {
+            $code        = $message-&gt;getCode();
+            $userinfo    = $message-&gt;getUserInfo();
+            $error_class = $message-&gt;getType();
+            $message-&gt;error_message_prefix = '';
+            $message     = $message-&gt;getMessage();
+        }
+
+        if (isset($this) &amp;&amp; isset($this-&gt;_expected_errors) &amp;&amp; sizeof($this-&gt;_expected_errors) &gt; 0 &amp;&amp; sizeof($exp = end($this-&gt;_expected_errors))) {
+            if ($exp[0] == &quot;*&quot; ||
+                (is_int(reset($exp)) &amp;&amp; in_array($code, $exp)) ||
+                (is_string(reset($exp)) &amp;&amp; in_array($message, $exp))) {
+                $mode = PEAR_ERROR_RETURN;
+            }
+        }
+        // No mode given, try global ones
+        if ($mode === null) {
+            // Class error handler
+            if (isset($this) &amp;&amp; isset($this-&gt;_default_error_mode)) {
+                $mode    = $this-&gt;_default_error_mode;
+                $options = $this-&gt;_default_error_options;
+            // Global error handler
+            } elseif (isset($GLOBALS['_PEAR_default_error_mode'])) {
+                $mode    = $GLOBALS['_PEAR_default_error_mode'];
+                $options = $GLOBALS['_PEAR_default_error_options'];
+            }
+        }
+
+        if ($error_class !== null) {
+            $ec = $error_class;
+        } elseif (isset($this) &amp;&amp; isset($this-&gt;_error_class)) {
+            $ec = $this-&gt;_error_class;
+        } else {
+            $ec = 'PEAR_Error';
+        }
+        if ($skipmsg) {
+            $a = &amp;new $ec($code, $mode, $options, $userinfo);
+            return $a;
+        } else {
+            $a = &amp;new $ec($message, $code, $mode, $options, $userinfo);
+            return $a;
+        }
+    }
+
+    // }}}
+    // {{{ throwError()
+
+    /**
+     * Simpler form of raiseError with fewer options.  In most cases
+     * message, code and userinfo are enough.
+     *
+     * @param string $message
+     *
+     */
+    function &amp;throwError($message = null,
+                         $code = null,
+                         $userinfo = null)
+    {
+        if (isset($this) &amp;&amp; is_a($this, 'PEAR')) {
+            $a = &amp;$this-&gt;raiseError($message, $code, null, null, $userinfo);
+            return $a;
+        } else {
+            $a = &amp;PEAR::raiseError($message, $code, null, null, $userinfo);
+            return $a;
+        }
+    }
+
+    // }}}
+    function staticPushErrorHandling($mode, $options = null)
+    {
+        $stack = &amp;$GLOBALS['_PEAR_error_handler_stack'];
+        $def_mode    = &amp;$GLOBALS['_PEAR_default_error_mode'];
+        $def_options = &amp;$GLOBALS['_PEAR_default_error_options'];
+        $stack[] = array($def_mode, $def_options);
+        switch ($mode) {
+            case PEAR_ERROR_EXCEPTION:
+            case PEAR_ERROR_RETURN:
+            case PEAR_ERROR_PRINT:
+            case PEAR_ERROR_TRIGGER:
+            case PEAR_ERROR_DIE:
+            case null:
+                $def_mode = $mode;
+                $def_options = $options;
+                break;
+
+            case PEAR_ERROR_CALLBACK:
+                $def_mode = $mode;
+                // class/object method callback
+                if (is_callable($options)) {
+                    $def_options = $options;
+                } else {
+                    trigger_error(&quot;invalid error callback&quot;, E_USER_WARNING);
+                }
+                break;
+
+            default:
+                trigger_error(&quot;invalid error mode&quot;, E_USER_WARNING);
+                break;
+        }
+        $stack[] = array($mode, $options);
+        return true;
+    }
+
+    function staticPopErrorHandling()
+    {
+        $stack = &amp;$GLOBALS['_PEAR_error_handler_stack'];
+        $setmode     = &amp;$GLOBALS['_PEAR_default_error_mode'];
+        $setoptions  = &amp;$GLOBALS['_PEAR_default_error_options'];
+        array_pop($stack);
+        list($mode, $options) = $stack[sizeof($stack) - 1];
+        array_pop($stack);
+        switch ($mode) {
+            case PEAR_ERROR_EXCEPTION:
+            case PEAR_ERROR_RETURN:
+            case PEAR_ERROR_PRINT:
+            case PEAR_ERROR_TRIGGER:
+            case PEAR_ERROR_DIE:
+            case null:
+                $setmode = $mode;
+                $setoptions = $options;
+                break;
+
+            case PEAR_ERROR_CALLBACK:
+                $setmode = $mode;
+                // class/object method callback
+                if (is_callable($options)) {
+                    $setoptions = $options;
+                } else {
+                    trigger_error(&quot;invalid error callback&quot;, E_USER_WARNING);
+                }
+                break;
+
+            default:
+                trigger_error(&quot;invalid error mode&quot;, E_USER_WARNING);
+                break;
+        }
+        return true;
+    }
+
+    // {{{ pushErrorHandling()
+
+    /**
+     * Push a new error handler on top of the error handler options stack. With this
+     * you can easily override the actual error handler for some code and restore
+     * it later with popErrorHandling.
+     *
+     * @param mixed $mode (same as setErrorHandling)
+     * @param mixed $options (same as setErrorHandling)
+     *
+     * @return bool Always true
+     *
+     * @see PEAR::setErrorHandling
+     */
+    function pushErrorHandling($mode, $options = null)
+    {
+        $stack = &amp;$GLOBALS['_PEAR_error_handler_stack'];
+        if (isset($this) &amp;&amp; is_a($this, 'PEAR')) {
+            $def_mode    = &amp;$this-&gt;_default_error_mode;
+            $def_options = &amp;$this-&gt;_default_error_options;
+        } else {
+            $def_mode    = &amp;$GLOBALS['_PEAR_default_error_mode'];
+            $def_options = &amp;$GLOBALS['_PEAR_default_error_options'];
+        }
+        $stack[] = array($def_mode, $def_options);
+
+        if (isset($this) &amp;&amp; is_a($this, 'PEAR')) {
+            $this-&gt;setErrorHandling($mode, $options);
+        } else {
+            PEAR::setErrorHandling($mode, $options);
+        }
+        $stack[] = array($mode, $options);
+        return true;
+    }
+
+    // }}}
+    // {{{ popErrorHandling()
+
+    /**
+    * Pop the last error handler used
+    *
+    * @return bool Always true
+    *
+    * @see PEAR::pushErrorHandling
+    */
+    function popErrorHandling()
+    {
+        $stack = &amp;$GLOBALS['_PEAR_error_handler_stack'];
+        array_pop($stack);
+        list($mode, $options) = $stack[sizeof($stack) - 1];
+        array_pop($stack);
+        if (isset($this) &amp;&amp; is_a($this, 'PEAR')) {
+            $this-&gt;setErrorHandling($mode, $options);
+        } else {
+            PEAR::setErrorHandling($mode, $options);
+        }
+        return true;
+    }
+
+    // }}}
+    // {{{ loadExtension()
+
+    /**
+    * OS independant PHP extension load. Remember to take care
+    * on the correct extension name for case sensitive OSes.
+    *
+    * @param string $ext The extension name
+    * @return bool Success or not on the dl() call
+    */
+    function loadExtension($ext)
+    {
+        if (!extension_loaded($ext)) {
+            // if either returns true dl() will produce a FATAL error, stop that
+            if ((ini_get('enable_dl') != 1) || (ini_get('safe_mode') == 1)) {
+                return false;
+            }
+            if (OS_WINDOWS) {
+                $suffix = '.dll';
+            } elseif (PHP_OS == 'HP-UX') {
+                $suffix = '.sl';
+            } elseif (PHP_OS == 'AIX') {
+                $suffix = '.a';
+            } elseif (PHP_OS == 'OSX') {
+                $suffix = '.bundle';
+            } else {
+                $suffix = '.so';
+            }
+            return @dl('php_'.$ext.$suffix) || @dl($ext.$suffix);
+        }
+        return true;
+    }
+
+    // }}}
+}
+
+// {{{ _PEAR_call_destructors()
+
+function _PEAR_call_destructors()
+{
+    global $_PEAR_destructor_object_list;
+    if (is_array($_PEAR_destructor_object_list) &amp;&amp;
+        sizeof($_PEAR_destructor_object_list))
+    {
+        reset($_PEAR_destructor_object_list);
+        if (@PEAR::getStaticProperty('PEAR', 'destructlifo')) {
+            $_PEAR_destructor_object_list = array_reverse($_PEAR_destructor_object_list);
+        }
+        while (list($k, $objref) = each($_PEAR_destructor_object_list)) {
+            $classname = get_class($objref);
+            while ($classname) {
+                $destructor = &quot;_$classname&quot;;
+                if (method_exists($objref, $destructor)) {
+                    $objref-&gt;$destructor();
+                    break;
+                } else {
+                    $classname = get_parent_class($classname);
+                }
+            }
+        }
+        // Empty the object list to ensure that destructors are
+        // not called more than once.
+        $_PEAR_destructor_object_list = array();
+    }
+
+    // Now call the shutdown functions
+    if (is_array($GLOBALS['_PEAR_shutdown_funcs']) AND !empty($GLOBALS['_PEAR_shutdown_funcs'])) {
+        foreach ($GLOBALS['_PEAR_shutdown_funcs'] as $value) {
+            call_user_func_array($value[0], $value[1]);
+        }
+    }
+}
+
+// }}}
+/**
+ * Standard PEAR error class for PHP 4
+ *
+ * This class is supserseded by {@link PEAR_Exception} in PHP 5
+ *
+ * @category   pear
+ * @package    PEAR
+ * @author     Stig Bakken &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">ssb at php.net</A>&gt;
+ * @author     Tomas V.V. Cox &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cox at idecnet.com</A>&gt;
+ * @author     Gregory Beaver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">cellog at php.net</A>&gt;
+ * @copyright  1997-2006 The PHP Group
+ * @license    <A HREF="http://www.php.net/license/3_0.txt">http://www.php.net/license/3_0.txt</A>  PHP License 3.0
+ * @version    Release: 1.4.9
+ * @link       <A HREF="http://pear.php.net/manual/en/core.pear.pear-error.php">http://pear.php.net/manual/en/core.pear.pear-error.php</A>
+ * @see        PEAR::raiseError(), PEAR::throwError()
+ * @since      Class available since PHP 4.0.2
+ */
+class PEAR_Error
+{
+    // {{{ properties
+
+    var $error_message_prefix = '';
+    var $mode                 = PEAR_ERROR_RETURN;
+    var $level                = E_USER_NOTICE;
+    var $code                 = -1;
+    var $message              = '';
+    var $userinfo             = '';
+    var $backtrace            = null;
+
+    // }}}
+    // {{{ constructor
+
+    /**
+     * PEAR_Error constructor
+     *
+     * @param string $message  message
+     *
+     * @param int $code     (optional) error code
+     *
+     * @param int $mode     (optional) error mode, one of: PEAR_ERROR_RETURN,
+     * PEAR_ERROR_PRINT, PEAR_ERROR_DIE, PEAR_ERROR_TRIGGER,
+     * PEAR_ERROR_CALLBACK or PEAR_ERROR_EXCEPTION
+     *
+     * @param mixed $options   (optional) error level, _OR_ in the case of
+     * PEAR_ERROR_CALLBACK, the callback function or object/method
+     * tuple.
+     *
+     * @param string $userinfo (optional) additional user/debug info
+     *
+     * @access public
+     *
+     */
+    function PEAR_Error($message = 'unknown error', $code = null,
+                        $mode = null, $options = null, $userinfo = null)
+    {
+        if ($mode === null) {
+            $mode = PEAR_ERROR_RETURN;
+        }
+        $this-&gt;message   = $message;
+        $this-&gt;code      = $code;
+        $this-&gt;mode      = $mode;
+        $this-&gt;userinfo  = $userinfo;
+        if (function_exists(&quot;debug_backtrace&quot;)) {
+            if (@!PEAR::getStaticProperty('PEAR_Error', 'skiptrace')) {
+                $this-&gt;backtrace = debug_backtrace();
+            }
+        }
+        if ($mode &amp; PEAR_ERROR_CALLBACK) {
+            $this-&gt;level = E_USER_NOTICE;
+            $this-&gt;callback = $options;
+        } else {
+            if ($options === null) {
+                $options = E_USER_NOTICE;
+            }
+            $this-&gt;level = $options;
+            $this-&gt;callback = null;
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_PRINT) {
+            if (is_null($options) || is_int($options)) {
+                $format = &quot;%s&quot;;
+            } else {
+                $format = $options;
+            }
+            printf($format, $this-&gt;getMessage());
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_TRIGGER) {
+            trigger_error($this-&gt;getMessage(), $this-&gt;level);
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_DIE) {
+            $msg = $this-&gt;getMessage();
+            if (is_null($options) || is_int($options)) {
+                $format = &quot;%s&quot;;
+                if (substr($msg, -1) != &quot;\n&quot;) {
+                    $msg .= &quot;\n&quot;;
+                }
+            } else {
+                $format = $options;
+            }
+            die(sprintf($format, $msg));
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_CALLBACK) {
+            if (is_callable($this-&gt;callback)) {
+                call_user_func($this-&gt;callback, $this);
+            }
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_EXCEPTION) {
+            trigger_error(&quot;PEAR_ERROR_EXCEPTION is obsolete, use class PEAR_Exception for exceptions&quot;, E_USER_WARNING);
+            eval('$e = new Exception($this-&gt;message, $this-&gt;code);throw($e);');
+        }
+    }
+
+    // }}}
+    // {{{ getMode()
+
+    /**
+     * Get the error mode from an error object.
+     *
+     * @return int error mode
+     * @access public
+     */
+    function getMode() {
+        return $this-&gt;mode;
+    }
+
+    // }}}
+    // {{{ getCallback()
+
+    /**
+     * Get the callback function/method from an error object.
+     *
+     * @return mixed callback function or object/method array
+     * @access public
+     */
+    function getCallback() {
+        return $this-&gt;callback;
+    }
+
+    // }}}
+    // {{{ getMessage()
+
+
+    /**
+     * Get the error message from an error object.
+     *
+     * @return  string  full error message
+     * @access public
+     */
+    function getMessage()
+    {
+        return ($this-&gt;error_message_prefix . $this-&gt;message);
+    }
+
+
+    // }}}
+    // {{{ getCode()
+
+    /**
+     * Get error code from an error object
+     *
+     * @return int error code
+     * @access public
+     */
+     function getCode()
+     {
+        return $this-&gt;code;
+     }
+
+    // }}}
+    // {{{ getType()
+
+    /**
+     * Get the name of this error/exception.
+     *
+     * @return string error/exception name (type)
+     * @access public
+     */
+    function getType()
+    {
+        return get_class($this);
+    }
+
+    // }}}
+    // {{{ getUserInfo()
+
+    /**
+     * Get additional user-supplied information.
+     *
+     * @return string user-supplied information
+     * @access public
+     */
+    function getUserInfo()
+    {
+        return $this-&gt;userinfo;
+    }
+
+    // }}}
+    // {{{ getDebugInfo()
+
+    /**
+     * Get additional debug information supplied by the application.
+     *
+     * @return string debug information
+     * @access public
+     */
+    function getDebugInfo()
+    {
+        return $this-&gt;getUserInfo();
+    }
+
+    // }}}
+    // {{{ getBacktrace()
+
+    /**
+     * Get the call backtrace from where the error was generated.
+     * Supported with PHP 4.3.0 or newer.
+     *
+     * @param int $frame (optional) what frame to fetch
+     * @return array Backtrace, or NULL if not available.
+     * @access public
+     */
+    function getBacktrace($frame = null)
+    {
+        if (defined('PEAR_IGNORE_BACKTRACE')) {
+            return null;
+        }
+        if ($frame === null) {
+            return $this-&gt;backtrace;
+        }
+        return $this-&gt;backtrace[$frame];
+    }
+
+    // }}}
+    // {{{ addUserInfo()
+
+    function addUserInfo($info)
+    {
+        if (empty($this-&gt;userinfo)) {
+            $this-&gt;userinfo = $info;
+        } else {
+            $this-&gt;userinfo .= &quot; ** $info&quot;;
+        }
+    }
+
+    // }}}
+    // {{{ toString()
+
+    /**
+     * Make a string representation of this object.
+     *
+     * @return string a string with an object summary
+     * @access public
+     */
+    function toString() {
+        $modes = array();
+        $levels = array(E_USER_NOTICE  =&gt; 'notice',
+                        E_USER_WARNING =&gt; 'warning',
+                        E_USER_ERROR   =&gt; 'error');
+        if ($this-&gt;mode &amp; PEAR_ERROR_CALLBACK) {
+            if (is_array($this-&gt;callback)) {
+                $callback = (is_object($this-&gt;callback[0]) ?
+                    strtolower(get_class($this-&gt;callback[0])) :
+                    $this-&gt;callback[0]) . '::' .
+                    $this-&gt;callback[1];
+            } else {
+                $callback = $this-&gt;callback;
+            }
+            return sprintf('[%s: message=&quot;%s&quot; code=%d mode=callback '.
+                           'callback=%s prefix=&quot;%s&quot; info=&quot;%s&quot;]',
+                           strtolower(get_class($this)), $this-&gt;message, $this-&gt;code,
+                           $callback, $this-&gt;error_message_prefix,
+                           $this-&gt;userinfo);
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_PRINT) {
+            $modes[] = 'print';
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_TRIGGER) {
+            $modes[] = 'trigger';
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_DIE) {
+            $modes[] = 'die';
+        }
+        if ($this-&gt;mode &amp; PEAR_ERROR_RETURN) {
+            $modes[] = 'return';
+        }
+        return sprintf('[%s: message=&quot;%s&quot; code=%d mode=%s level=%s '.
+                       'prefix=&quot;%s&quot; info=&quot;%s&quot;]',
+                       strtolower(get_class($this)), $this-&gt;message, $this-&gt;code,
+                       implode(&quot;|&quot;, $modes), $levels[$this-&gt;level],
+                       $this-&gt;error_message_prefix,
+                       $this-&gt;userinfo);
+    }
+
+    // }}}
+}
+
+/*
+ * Local Variables:
+ * mode: php
+ * tab-width: 4
+ * c-basic-offset: 4
+ * End:
+ */
+?&gt;

Added: trunk/examples/basecamp_api/proxy/php/Request.php
===================================================================
--- trunk/examples/basecamp_api/proxy/php/Request.php	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/proxy/php/Request.php	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,1192 @@
+&lt;?php
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2003, Richard Heyes                                |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">richard at phpguru.org</A>&gt;                           |
+// +-----------------------------------------------------------------------+
+//
+// $Id: Request.php,v 1.43 2005/11/06 18:29:14 avb Exp $
+//
+// HTTP_Request Class
+//
+// Simple example, (Fetches yahoo.com and displays it):
+//
+// $a = &amp;new HTTP_Request('<A HREF="http://www.yahoo.com/">http://www.yahoo.com/</A>');
+// $a-&gt;sendRequest();
+// echo $a-&gt;getResponseBody();
+//
+
+require_once 'PEAR.php';  // from <A HREF="http://pear.php.net/package/PEAR">http://pear.php.net/package/PEAR</A>
+require_once 'Socket.php'; // from <A HREF="http://pear.php.net/package/Net_Socket">http://pear.php.net/package/Net_Socket</A>
+require_once 'URL.php'; // from <A HREF="http://pear.php.net/package/Net_URL">http://pear.php.net/package/Net_URL</A>
+
+define('HTTP_REQUEST_METHOD_GET',     'GET',     true);
+define('HTTP_REQUEST_METHOD_HEAD',    'HEAD',    true);
+define('HTTP_REQUEST_METHOD_POST',    'POST',    true);
+define('HTTP_REQUEST_METHOD_PUT',     'PUT',     true);
+define('HTTP_REQUEST_METHOD_DELETE',  'DELETE',  true);
+define('HTTP_REQUEST_METHOD_OPTIONS', 'OPTIONS', true);
+define('HTTP_REQUEST_METHOD_TRACE',   'TRACE',   true);
+
+define('HTTP_REQUEST_HTTP_VER_1_0', '1.0', true);
+define('HTTP_REQUEST_HTTP_VER_1_1', '1.1', true);
+
+class HTTP_Request {
+
+    /**
+    * Instance of Net_URL
+    * @var object Net_URL
+    */
+    var $_url;
+
+    /**
+    * Type of request
+    * @var string
+    */
+    var $_method;
+
+    /**
+    * HTTP Version
+    * @var string
+    */
+    var $_http;
+
+    /**
+    * Request headers
+    * @var array
+    */
+    var $_requestHeaders;
+
+    /**
+    * Basic Auth Username
+    * @var string
+    */
+    var $_user;
+    
+    /**
+    * Basic Auth Password
+    * @var string
+    */
+    var $_pass;
+
+    /**
+    * Socket object
+    * @var object Net_Socket
+    */
+    var $_sock;
+    
+    /**
+    * Proxy server
+    * @var string
+    */
+    var $_proxy_host;
+    
+    /**
+    * Proxy port
+    * @var integer
+    */
+    var $_proxy_port;
+    
+    /**
+    * Proxy username
+    * @var string
+    */
+    var $_proxy_user;
+    
+    /**
+    * Proxy password
+    * @var string
+    */
+    var $_proxy_pass;
+
+    /**
+    * Post data
+    * @var array
+    */
+    var $_postData;
+
+   /**
+    * Request body  
+    * @var string
+    */
+    var $_body;
+
+   /**
+    * A list of methods that MUST NOT have a request body, per RFC 2616
+    * @var array
+    */
+    var $_bodyDisallowed = array('TRACE');
+
+   /**
+    * Files to post 
+    * @var array
+    */
+    var $_postFiles = array();
+
+    /**
+    * Connection timeout.
+    * @var float
+    */
+    var $_timeout;
+    
+    /**
+    * HTTP_Response object
+    * @var object HTTP_Response
+    */
+    var $_response;
+    
+    /**
+    * Whether to allow redirects
+    * @var boolean
+    */
+    var $_allowRedirects;
+    
+    /**
+    * Maximum redirects allowed
+    * @var integer
+    */
+    var $_maxRedirects;
+    
+    /**
+    * Current number of redirects
+    * @var integer
+    */
+    var $_redirects;
+
+   /**
+    * Whether to append brackets [] to array variables
+    * @var bool
+    */
+    var $_useBrackets = true;
+
+   /**
+    * Attached listeners
+    * @var array
+    */
+    var $_listeners = array();
+
+   /**
+    * Whether to save response body in response object property  
+    * @var bool
+    */
+    var $_saveBody = true;
+
+   /**
+    * Timeout for reading from socket (array(seconds, microseconds))
+    * @var array
+    */
+    var $_readTimeout = null;
+
+   /**
+    * Options to pass to Net_Socket::connect. See stream_context_create
+    * @var array
+    */
+    var $_socketOptions = null;
+
+    /**
+    * Constructor
+    *
+    * Sets up the object
+    * @param    string  The url to fetch/access
+    * @param    array   Associative array of parameters which can have the following keys:
+    * &lt;ul&gt;
+    *   &lt;li&gt;method         - Method to use, GET, POST etc (string)&lt;/li&gt;
+    *   &lt;li&gt;http           - HTTP Version to use, 1.0 or 1.1 (string)&lt;/li&gt;
+    *   &lt;li&gt;user           - Basic Auth username (string)&lt;/li&gt;
+    *   &lt;li&gt;pass           - Basic Auth password (string)&lt;/li&gt;
+    *   &lt;li&gt;proxy_host     - Proxy server host (string)&lt;/li&gt;
+    *   &lt;li&gt;proxy_port     - Proxy server port (integer)&lt;/li&gt;
+    *   &lt;li&gt;proxy_user     - Proxy auth username (string)&lt;/li&gt;
+    *   &lt;li&gt;proxy_pass     - Proxy auth password (string)&lt;/li&gt;
+    *   &lt;li&gt;timeout        - Connection timeout in seconds (float)&lt;/li&gt;
+    *   &lt;li&gt;allowRedirects - Whether to follow redirects or not (bool)&lt;/li&gt;
+    *   &lt;li&gt;maxRedirects   - Max number of redirects to follow (integer)&lt;/li&gt;
+    *   &lt;li&gt;useBrackets    - Whether to append [] to array variable names (bool)&lt;/li&gt;
+    *   &lt;li&gt;saveBody       - Whether to save response body in response object property (bool)&lt;/li&gt;
+    *   &lt;li&gt;readTimeout    - Timeout for reading / writing data over the socket (array (seconds, microseconds))&lt;/li&gt;
+    *   &lt;li&gt;socketOptions  - Options to pass to Net_Socket object (array)&lt;/li&gt;
+    * &lt;/ul&gt;
+    * @access public
+    */
+    function HTTP_Request($url = '', $params = array())
+    {
+        $this-&gt;_sock           = &amp;new Net_Socket();
+        $this-&gt;_method         =  HTTP_REQUEST_METHOD_GET;
+        $this-&gt;_http           =  HTTP_REQUEST_HTTP_VER_1_1;
+        $this-&gt;_requestHeaders = array();
+        $this-&gt;_postData       = array();
+        $this-&gt;_body           = null;
+
+        $this-&gt;_user = null;
+        $this-&gt;_pass = null;
+
+        $this-&gt;_proxy_host = null;
+        $this-&gt;_proxy_port = null;
+        $this-&gt;_proxy_user = null;
+        $this-&gt;_proxy_pass = null;
+
+        $this-&gt;_allowRedirects = false;
+        $this-&gt;_maxRedirects   = 3;
+        $this-&gt;_redirects      = 0;
+
+        $this-&gt;_timeout  = null;
+        $this-&gt;_response = null;
+
+        foreach ($params as $key =&gt; $value) {
+            $this-&gt;{'_' . $key} = $value;
+        }
+
+        if (!empty($url)) {
+            $this-&gt;setURL($url);
+        }
+
+        // Default useragent
+        $this-&gt;addHeader('User-Agent', 'PEAR HTTP_Request class ( <A HREF="http://pear.php.net/">http://pear.php.net/</A> )');
+
+        // Make sure keepalives dont knobble us
+        $this-&gt;addHeader('Connection', 'close');
+
+        // Basic authentication
+        if (!empty($this-&gt;_user)) {
+            $this-&gt;addHeader('Authorization', 'Basic ' . base64_encode($this-&gt;_user . ':' . $this-&gt;_pass));
+        }
+
+        // Use gzip encoding if possible
+        // Avoid gzip encoding if using multibyte functions (see #1781)
+        if (HTTP_REQUEST_HTTP_VER_1_1 == $this-&gt;_http &amp;&amp; extension_loaded('zlib') &amp;&amp;
+            0 == (2 &amp; ini_get('mbstring.func_overload'))) {
+
+            $this-&gt;addHeader('Accept-Encoding', 'gzip');
+        }
+    }
+    
+    /**
+    * Generates a Host header for HTTP/1.1 requests
+    *
+    * @access private
+    * @return string
+    */
+    function _generateHostHeader()
+    {
+        if ($this-&gt;_url-&gt;port != 80 AND strcasecmp($this-&gt;_url-&gt;protocol, 'http') == 0) {
+            $host = $this-&gt;_url-&gt;host . ':' . $this-&gt;_url-&gt;port;
+
+        } elseif ($this-&gt;_url-&gt;port != 443 AND strcasecmp($this-&gt;_url-&gt;protocol, 'https') == 0) {
+            $host = $this-&gt;_url-&gt;host . ':' . $this-&gt;_url-&gt;port;
+
+        } elseif ($this-&gt;_url-&gt;port == 443 AND strcasecmp($this-&gt;_url-&gt;protocol, 'https') == 0 AND strpos($this-&gt;_url-&gt;url, ':443') !== false) {
+            $host = $this-&gt;_url-&gt;host . ':' . $this-&gt;_url-&gt;port;
+        
+        } else {
+            $host = $this-&gt;_url-&gt;host;
+        }
+
+        return $host;
+    }
+    
+    /**
+    * Resets the object to its initial state (DEPRECATED).
+    * Takes the same parameters as the constructor.
+    *
+    * @param  string $url    The url to be requested
+    * @param  array  $params Associative array of parameters
+    *                        (see constructor for details)
+    * @access public
+    * @deprecated deprecated since 1.2, call the constructor if this is necessary
+    */
+    function reset($url, $params = array())
+    {
+        $this-&gt;HTTP_Request($url, $params);
+    }
+
+    /**
+    * Sets the URL to be requested
+    *
+    * @param  string The url to be requested
+    * @access public
+    */
+    function setURL($url)
+    {
+        $this-&gt;_url = &amp;new Net_URL($url, $this-&gt;_useBrackets);
+
+        if (!empty($this-&gt;_url-&gt;user) || !empty($this-&gt;_url-&gt;pass)) {
+            $this-&gt;setBasicAuth($this-&gt;_url-&gt;user, $this-&gt;_url-&gt;pass);
+        }
+
+        if (HTTP_REQUEST_HTTP_VER_1_1 == $this-&gt;_http) {
+            $this-&gt;addHeader('Host', $this-&gt;_generateHostHeader());
+        }
+    }
+    
+    /**
+    * Sets a proxy to be used
+    *
+    * @param string     Proxy host
+    * @param int        Proxy port
+    * @param string     Proxy username
+    * @param string     Proxy password
+    * @access public
+    */
+    function setProxy($host, $port = 8080, $user = null, $pass = null)
+    {
+        $this-&gt;_proxy_host = $host;
+        $this-&gt;_proxy_port = $port;
+        $this-&gt;_proxy_user = $user;
+        $this-&gt;_proxy_pass = $pass;
+
+        if (!empty($user)) {
+            $this-&gt;addHeader('Proxy-Authorization', 'Basic ' . base64_encode($user . ':' . $pass));
+        }
+    }
+
+    /**
+    * Sets basic authentication parameters
+    *
+    * @param string     Username
+    * @param string     Password
+    */
+    function setBasicAuth($user, $pass)
+    {
+        $this-&gt;_user = $user;
+        $this-&gt;_pass = $pass;
+
+        $this-&gt;addHeader('Authorization', 'Basic ' . base64_encode($user . ':' . $pass));
+    }
+
+    /**
+    * Sets the method to be used, GET, POST etc.
+    *
+    * @param string     Method to use. Use the defined constants for this
+    * @access public
+    */
+    function setMethod($method)
+    {
+        $this-&gt;_method = $method;
+    }
+
+    /**
+    * Sets the HTTP version to use, 1.0 or 1.1
+    *
+    * @param string     Version to use. Use the defined constants for this
+    * @access public
+    */
+    function setHttpVer($http)
+    {
+        $this-&gt;_http = $http;
+    }
+
+    /**
+    * Adds a request header
+    *
+    * @param string     Header name
+    * @param string     Header value
+    * @access public
+    */
+    function addHeader($name, $value)
+    {
+        $this-&gt;_requestHeaders[strtolower($name)] = $value;
+    }
+
+    /**
+    * Removes a request header
+    *
+    * @param string     Header name to remove
+    * @access public
+    */
+    function removeHeader($name)
+    {
+        if (isset($this-&gt;_requestHeaders[strtolower($name)])) {
+            unset($this-&gt;_requestHeaders[strtolower($name)]);
+        }
+    }
+
+    /**
+    * Adds a querystring parameter
+    *
+    * @param string     Querystring parameter name
+    * @param string     Querystring parameter value
+    * @param bool       Whether the value is already urlencoded or not, default = not
+    * @access public
+    */
+    function addQueryString($name, $value, $preencoded = false)
+    {
+        $this-&gt;_url-&gt;addQueryString($name, $value, $preencoded);
+    }    
+    
+    /**
+    * Sets the querystring to literally what you supply
+    *
+    * @param string     The querystring data. Should be of the format foo=bar&amp;x=y etc
+    * @param bool       Whether data is already urlencoded or not, default = already encoded
+    * @access public
+    */
+    function addRawQueryString($querystring, $preencoded = true)
+    {
+        $this-&gt;_url-&gt;addRawQueryString($querystring, $preencoded);
+    }
+
+    /**
+    * Adds postdata items
+    *
+    * @param string     Post data name
+    * @param string     Post data value
+    * @param bool       Whether data is already urlencoded or not, default = not
+    * @access public
+    */
+    function addPostData($name, $value, $preencoded = false)
+    {
+        if ($preencoded) {
+            $this-&gt;_postData[$name] = $value;
+        } else {
+            $this-&gt;_postData[$name] = $this-&gt;_arrayMapRecursive('urlencode', $value);
+        }
+    }
+
+   /**
+    * Recursively applies the callback function to the value
+    * 
+    * @param    mixed   Callback function
+    * @param    mixed   Value to process
+    * @access   private
+    * @return   mixed   Processed value
+    */
+    function _arrayMapRecursive($callback, $value)
+    {
+        if (!is_array($value)) {
+            return call_user_func($callback, $value);
+        } else {
+            $map = array();
+            foreach ($value as $k =&gt; $v) {
+                $map[$k] = $this-&gt;_arrayMapRecursive($callback, $v);
+            }
+            return $map;
+        }
+    }
+
+   /**
+    * Adds a file to upload
+    * 
+    * This also changes content-type to 'multipart/form-data' for proper upload
+    * 
+    * @access public
+    * @param  string    name of file-upload field
+    * @param  mixed     file name(s)
+    * @param  mixed     content-type(s) of file(s) being uploaded
+    * @return bool      true on success
+    * @throws PEAR_Error
+    */
+    function addFile($inputName, $fileName, $contentType = 'application/octet-stream')
+    {
+        if (!is_array($fileName) &amp;&amp; !is_readable($fileName)) {
+            return PEAR::raiseError(&quot;File '{$fileName}' is not readable&quot;);
+        } elseif (is_array($fileName)) {
+            foreach ($fileName as $name) {
+                if (!is_readable($name)) {
+                    return PEAR::raiseError(&quot;File '{$name}' is not readable&quot;);
+                }
+            }
+        }
+        $this-&gt;addHeader('Content-Type', 'multipart/form-data');
+        $this-&gt;_postFiles[$inputName] = array(
+            'name' =&gt; $fileName,
+            'type' =&gt; $contentType
+        );
+        return true;
+    }
+
+    /**
+    * Adds raw postdata (DEPRECATED)
+    *
+    * @param string     The data
+    * @param bool       Whether data is preencoded or not, default = already encoded
+    * @access public
+    * @deprecated       deprecated since 1.3.0, method addBody() should be used instead
+    */
+    function addRawPostData($postdata, $preencoded = true)
+    {
+        $this-&gt;_body = $preencoded ? $postdata : urlencode($postdata);
+    }
+
+   /**
+    * Sets the request body (for POST, PUT and similar requests)
+    *
+    * @param    string  Request body
+    * @access   public
+    */
+    function setBody($body)
+    {
+        $this-&gt;_body = $body;
+    }
+
+    /**
+    * Clears any postdata that has been added (DEPRECATED). 
+    * 
+    * Useful for multiple request scenarios.
+    *
+    * @access public
+    * @deprecated deprecated since 1.2
+    */
+    function clearPostData()
+    {
+        $this-&gt;_postData = null;
+    }
+
+    /**
+    * Appends a cookie to &quot;Cookie:&quot; header
+    * 
+    * @param string $name cookie name
+    * @param string $value cookie value
+    * @access public
+    */
+    function addCookie($name, $value)
+    {
+        $cookies = isset($this-&gt;_requestHeaders['cookie']) ? $this-&gt;_requestHeaders['cookie']. '; ' : '';
+        $this-&gt;addHeader('Cookie', $cookies . $name . '=' . $value);
+    }
+    
+    /**
+    * Clears any cookies that have been added (DEPRECATED). 
+    * 
+    * Useful for multiple request scenarios
+    *
+    * @access public
+    * @deprecated deprecated since 1.2
+    */
+    function clearCookies()
+    {
+        $this-&gt;removeHeader('Cookie');
+    }
+
+    /**
+    * Sends the request
+    *
+    * @access public
+    * @param  bool   Whether to store response body in Response object property,
+    *                set this to false if downloading a LARGE file and using a Listener
+    * @return mixed  PEAR error on error, true otherwise
+    */
+    function sendRequest($saveBody = true)
+    {
+        if (!is_a($this-&gt;_url, 'Net_URL')) {
+            return PEAR::raiseError('No URL given.');
+        }
+
+        $host = isset($this-&gt;_proxy_host) ? $this-&gt;_proxy_host : $this-&gt;_url-&gt;host;
+        $port = isset($this-&gt;_proxy_port) ? $this-&gt;_proxy_port : $this-&gt;_url-&gt;port;
+
+        // 4.3.0 supports SSL connections using OpenSSL. The function test determines
+        // we running on at least 4.3.0
+        if (strcasecmp($this-&gt;_url-&gt;protocol, 'https') == 0 AND function_exists('file_get_contents') AND extension_loaded('openssl')) {
+            if (isset($this-&gt;_proxy_host)) {
+                return PEAR::raiseError('HTTPS proxies are not supported.');
+            }
+            $host = '<A HREF="ssl://">ssl://</A>' . $host;
+        }
+
+        // magic quotes may fuck up file uploads and chunked response processing
+        $magicQuotes = ini_get('magic_quotes_runtime');
+        ini_set('magic_quotes_runtime', false);
+
+        // If this is a second request, we may get away without
+        // re-connecting if they're on the same server
+        $err = $this-&gt;_sock-&gt;connect($host, $port, null, $this-&gt;_timeout, $this-&gt;_socketOptions);
+		$r   = $this-&gt;_buildRequest();
+		
+        PEAR::isError($err) or $err = $this-&gt;_sock-&gt;write($r);
+
+        if (!PEAR::isError($err)) {
+            if (!empty($this-&gt;_readTimeout)) {
+                $this-&gt;_sock-&gt;setTimeout($this-&gt;_readTimeout[0], $this-&gt;_readTimeout[1]);
+            }
+
+            $this-&gt;_notify('sentRequest');
+
+            // Read the response
+            $this-&gt;_response = &amp;new HTTP_Response($this-&gt;_sock, $this-&gt;_listeners);
+            $err = $this-&gt;_response-&gt;process($this-&gt;_saveBody &amp;&amp; $saveBody);
+        }
+
+        ini_set('magic_quotes_runtime', $magicQuotes);
+
+        if (PEAR::isError($err)) {
+            return $err;
+        }
+
+
+        // Check for redirection
+        if (    $this-&gt;_allowRedirects
+            AND $this-&gt;_redirects &lt;= $this-&gt;_maxRedirects
+            AND $this-&gt;getResponseCode() &gt; 300
+            AND $this-&gt;getResponseCode() &lt; 399
+            AND !empty($this-&gt;_response-&gt;_headers['location'])) {
+
+            
+            $redirect = $this-&gt;_response-&gt;_headers['location'];
+
+            // Absolute URL
+            if (preg_match('/^https?:\/\//i', $redirect)) {
+                $this-&gt;_url = &amp;new Net_URL($redirect);
+                $this-&gt;addHeader('Host', $this-&gt;_generateHostHeader());
+            // Absolute path
+            } elseif ($redirect{0} == '/') {
+                $this-&gt;_url-&gt;path = $redirect;
+            
+            // Relative path
+            } elseif (substr($redirect, 0, 3) == '../' OR substr($redirect, 0, 2) == './') {
+                if (substr($this-&gt;_url-&gt;path, -1) == '/') {
+                    $redirect = $this-&gt;_url-&gt;path . $redirect;
+                } else {
+                    $redirect = dirname($this-&gt;_url-&gt;path) . '/' . $redirect;
+                }
+                $redirect = Net_URL::resolvePath($redirect);
+                $this-&gt;_url-&gt;path = $redirect;
+                
+            // Filename, no path
+            } else {
+                if (substr($this-&gt;_url-&gt;path, -1) == '/') {
+                    $redirect = $this-&gt;_url-&gt;path . $redirect;
+                } else {
+                    $redirect = dirname($this-&gt;_url-&gt;path) . '/' . $redirect;
+                }
+                $this-&gt;_url-&gt;path = $redirect;
+            }
+
+            $this-&gt;_redirects++;
+            return $this-&gt;sendRequest($saveBody);
+
+        // Too many redirects
+        } elseif ($this-&gt;_allowRedirects AND $this-&gt;_redirects &gt; $this-&gt;_maxRedirects) {
+            return PEAR::raiseError('Too many redirects');
+        }
+
+        $this-&gt;_sock-&gt;disconnect();
+
+        return true;
+    }
+
+    /**
+    * Returns the response code
+    *
+    * @access public
+    * @return mixed     Response code, false if not set
+    */
+    function getResponseCode()
+    {
+        return isset($this-&gt;_response-&gt;_code) ? $this-&gt;_response-&gt;_code : false;
+    }
+
+    /**
+    * Returns either the named header or all if no name given
+    *
+    * @access public
+    * @param string     The header name to return, do not set to get all headers
+    * @return mixed     either the value of $headername (false if header is not present)
+    *                   or an array of all headers
+    */
+    function getResponseHeader($headername = null)
+    {
+        if (!isset($headername)) {
+            return isset($this-&gt;_response-&gt;_headers)? $this-&gt;_response-&gt;_headers: array();
+        } else {
+            $headername = strtolower($headername);
+            return isset($this-&gt;_response-&gt;_headers[$headername]) ? $this-&gt;_response-&gt;_headers[$headername] : false;
+        }
+    }
+
+    /**
+    * Returns the body of the response
+    *
+    * @access public
+    * @return mixed     response body, false if not set
+    */
+    function getResponseBody()
+    {
+        return isset($this-&gt;_response-&gt;_body) ? $this-&gt;_response-&gt;_body : false;
+    }
+
+    /**
+    * Returns cookies set in response
+    * 
+    * @access public
+    * @return mixed     array of response cookies, false if none are present
+    */
+    function getResponseCookies()
+    {
+        return isset($this-&gt;_response-&gt;_cookies) ? $this-&gt;_response-&gt;_cookies : false;
+    }
+
+    /**
+    * Builds the request string
+    *
+    * @access private
+    * @return string The request string
+    */
+    function _buildRequest()
+    {
+        $separator = ini_get('arg_separator.output');
+        ini_set('arg_separator.output', '&amp;');
+        $querystring = ($querystring = $this-&gt;_url-&gt;getQueryString()) ? '?' . $querystring : '';
+        ini_set('arg_separator.output', $separator);
+
+        $host = isset($this-&gt;_proxy_host) ? $this-&gt;_url-&gt;protocol . '://' . $this-&gt;_url-&gt;host : '';
+        $port = (isset($this-&gt;_proxy_host) AND $this-&gt;_url-&gt;port != 80) ? ':' . $this-&gt;_url-&gt;port : '';
+        $path = (empty($this-&gt;_url-&gt;path)? '/': $this-&gt;_url-&gt;path) . $querystring;
+        $url  = $host . $port . $path;
+
+        $request = $this-&gt;_method . ' ' . $url . ' HTTP/' . $this-&gt;_http . &quot;\r\n&quot;;
+
+        if (in_array($this-&gt;_method, $this-&gt;_bodyDisallowed) ||
+            (HTTP_REQUEST_METHOD_POST != $this-&gt;_method &amp;&amp; empty($this-&gt;_body)) ||
+            (HTTP_REQUEST_METHOD_POST != $this-&gt;_method &amp;&amp; empty($this-&gt;_postData) &amp;&amp; empty($this-&gt;_postFiles))) {
+
+            $this-&gt;removeHeader('Content-Type');
+        } else {
+            if (empty($this-&gt;_requestHeaders['content-type'])) {
+                // Add default content-type
+                $this-&gt;addHeader('Content-Type', 'application/x-www-form-urlencoded');
+            } elseif ('multipart/form-data' == $this-&gt;_requestHeaders['content-type']) {
+                $boundary = 'HTTP_Request_' . md5(uniqid('request') . microtime());
+                $this-&gt;addHeader('Content-Type', 'multipart/form-data; boundary=' . $boundary);
+            }
+        }
+
+        // Request Headers
+        if (!empty($this-&gt;_requestHeaders)) {
+            foreach ($this-&gt;_requestHeaders as $name =&gt; $value) {
+                $canonicalName = implode('-', array_map('ucfirst', explode('-', $name)));
+                $request      .= $canonicalName . ': ' . $value . &quot;\r\n&quot;;
+            }
+        }
+
+        // No post data or wrong method, so simply add a final CRLF
+        if (in_array($this-&gt;_method, $this-&gt;_bodyDisallowed) || 
+            (HTTP_REQUEST_METHOD_POST != $this-&gt;_method &amp;&amp; empty($this-&gt;_body))) {
+
+            $request .= &quot;\r\n&quot;;
+
+        // Post data if it's an array
+        } elseif (HTTP_REQUEST_METHOD_POST == $this-&gt;_method &amp;&amp; 
+                  (!empty($this-&gt;_postData) || !empty($this-&gt;_postFiles))) {
+
+            // &quot;normal&quot; POST request
+            if (!isset($boundary)) {
+                $postdata = implode('&amp;', array_map(
+                    create_function('$a', 'return $a[0] . \'=\' . $a[1];'), 
+                    $this-&gt;_flattenArray('', $this-&gt;_postData)
+                ));
+
+            // multipart request, probably with file uploads
+            } else {
+                $postdata = '';
+                if (!empty($this-&gt;_postData)) {
+                    $flatData = $this-&gt;_flattenArray('', $this-&gt;_postData);
+                    foreach ($flatData as $item) {
+                        $postdata .= '--' . $boundary . &quot;\r\n&quot;;
+                        $postdata .= 'Content-Disposition: form-data; name=&quot;' . $item[0] . '&quot;';
+                        $postdata .= &quot;\r\n\r\n&quot; . urldecode($item[1]) . &quot;\r\n&quot;;
+                    }
+                }
+                foreach ($this-&gt;_postFiles as $name =&gt; $value) {
+                    if (is_array($value['name'])) {
+                        $varname       = $name . ($this-&gt;_useBrackets? '[]': '');
+                    } else {
+                        $varname       = $name;
+                        $value['name'] = array($value['name']);
+                    }
+                    foreach ($value['name'] as $key =&gt; $filename) {
+                        $fp   = fopen($filename, 'r');
+                        $data = fread($fp, filesize($filename));
+                        fclose($fp);
+                        $basename = basename($filename);
+                        $type     = is_array($value['type'])? @$value['type'][$key]: $value['type'];
+
+                        $postdata .= '--' . $boundary . &quot;\r\n&quot;;
+                        $postdata .= 'Content-Disposition: form-data; name=&quot;' . $varname . '&quot;; filename=&quot;' . $basename . '&quot;';
+                        $postdata .= &quot;\r\nContent-Type: &quot; . $type;
+                        $postdata .= &quot;\r\n\r\n&quot; . $data . &quot;\r\n&quot;;
+                    }
+                }
+                $postdata .= '--' . $boundary . &quot;--\r\n&quot;;
+            }
+            $request .= 'Content-Length: ' . strlen($postdata) . &quot;\r\n\r\n&quot;;
+            $request .= $postdata;
+
+        // Explicitly set request body
+        } elseif (!empty($this-&gt;_body)) {
+
+            $request .= 'Content-Length: ' . strlen($this-&gt;_body) . &quot;\r\n\r\n&quot;;
+            $request .= $this-&gt;_body;
+        }       
+        return $request;
+    }
+
+   /**
+    * Helper function to change the (probably multidimensional) associative array
+    * into the simple one.
+    *
+    * @param    string  name for item
+    * @param    mixed   item's values
+    * @return   array   array with the following items: array('item name', 'item value');
+    */
+    function _flattenArray($name, $values)
+    {
+        if (!is_array($values)) {
+            return array(array($name, $values));
+        } else {
+            $ret = array();
+            foreach ($values as $k =&gt; $v) {
+                if (empty($name)) {
+                    $newName = $k;
+                } elseif ($this-&gt;_useBrackets) {
+                    $newName = $name . '[' . $k . ']';
+                } else {
+                    $newName = $name;
+                }
+                $ret = array_merge($ret, $this-&gt;_flattenArray($newName, $v));
+            }
+            return $ret;
+        }
+    }
+
+
+   /**
+    * Adds a Listener to the list of listeners that are notified of
+    * the object's events
+    * 
+    * @param    object   HTTP_Request_Listener instance to attach
+    * @return   boolean  whether the listener was successfully attached
+    * @access   public
+    */
+    function attach(&amp;$listener)
+    {
+        if (!is_a($listener, 'HTTP_Request_Listener')) {
+            return false;
+        }
+        $this-&gt;_listeners[$listener-&gt;getId()] =&amp; $listener;
+        return true;
+    }
+
+
+   /**
+    * Removes a Listener from the list of listeners 
+    * 
+    * @param    object   HTTP_Request_Listener instance to detach
+    * @return   boolean  whether the listener was successfully detached
+    * @access   public
+    */
+    function detach(&amp;$listener)
+    {
+        if (!is_a($listener, 'HTTP_Request_Listener') || 
+            !isset($this-&gt;_listeners[$listener-&gt;getId()])) {
+            return false;
+        }
+        unset($this-&gt;_listeners[$listener-&gt;getId()]);
+        return true;
+    }
+
+
+   /**
+    * Notifies all registered listeners of an event.
+    * 
+    * Events sent by HTTP_Request object
+    * 'sentRequest': after the request was sent
+    * Events sent by HTTP_Response object
+    * 'gotHeaders': after receiving response headers (headers are passed in $data)
+    * 'tick': on receiving a part of response body (the part is passed in $data)
+    * 'gzTick': on receiving a gzip-encoded part of response body (ditto)
+    * 'gotBody': after receiving the response body (passes the decoded body in $data if it was gzipped)
+    * 
+    * @param    string  Event name
+    * @param    mixed   Additional data
+    * @access   private
+    */
+    function _notify($event, $data = null)
+    {
+        foreach (array_keys($this-&gt;_listeners) as $id) {
+            $this-&gt;_listeners[$id]-&gt;update($this, $event, $data);
+        }
+    }
+}
+
+
+/**
+* Response class to complement the Request class
+*/
+class HTTP_Response
+{
+    /**
+    * Socket object
+    * @var object
+    */
+    var $_sock;
+
+    /**
+    * Protocol
+    * @var string
+    */
+    var $_protocol;
+    
+    /**
+    * Return code
+    * @var string
+    */
+    var $_code;
+    
+    /**
+    * Response headers
+    * @var array
+    */
+    var $_headers;
+
+    /**
+    * Cookies set in response  
+    * @var array
+    */
+    var $_cookies;
+
+    /**
+    * Response body
+    * @var string
+    */
+    var $_body = '';
+
+   /**
+    * Used by _readChunked(): remaining length of the current chunk
+    * @var string
+    */
+    var $_chunkLength = 0;
+
+   /**
+    * Attached listeners
+    * @var array
+    */
+    var $_listeners = array();
+
+    /**
+    * Constructor
+    *
+    * @param  object Net_Socket     socket to read the response from
+    * @param  array                 listeners attached to request
+    * @return mixed PEAR Error on error, true otherwise
+    */
+    function HTTP_Response(&amp;$sock, &amp;$listeners)
+    {
+        $this-&gt;_sock      =&amp; $sock;
+        $this-&gt;_listeners =&amp; $listeners;
+    }
+
+
+   /**
+    * Processes a HTTP response
+    * 
+    * This extracts response code, headers, cookies and decodes body if it 
+    * was encoded in some way
+    *
+    * @access public
+    * @param  bool      Whether to store response body in object property, set
+    *                   this to false if downloading a LARGE file and using a Listener.
+    *                   This is assumed to be true if body is gzip-encoded.
+    * @throws PEAR_Error
+    * @return mixed     true on success, PEAR_Error in case of malformed response
+    */
+    function process($saveBody = true)
+    {
+        do {
+            $line = $this-&gt;_sock-&gt;readLine();
+            if (sscanf($line, 'HTTP/%s %s', $http_version, $returncode) != 2) {
+                return PEAR::raiseError('Malformed response.');
+            } else {
+                $this-&gt;_protocol = 'HTTP/' . $http_version;
+                $this-&gt;_code     = intval($returncode);
+            }
+            while ('' !== ($header = $this-&gt;_sock-&gt;readLine())) {
+                $this-&gt;_processHeader($header);
+            }
+        } while (100 == $this-&gt;_code);
+
+        $this-&gt;_notify('gotHeaders', $this-&gt;_headers);
+
+        // If response body is present, read it and decode
+        $chunked = isset($this-&gt;_headers['transfer-encoding']) &amp;&amp; ('chunked' == $this-&gt;_headers['transfer-encoding']);
+        $gzipped = isset($this-&gt;_headers['content-encoding']) &amp;&amp; ('gzip' == $this-&gt;_headers['content-encoding']);
+        $hasBody = false;
+        if (!isset($this-&gt;_headers['content-length']) || 0 != $this-&gt;_headers['content-length']) {
+            while (!$this-&gt;_sock-&gt;eof()) {
+                if ($chunked) {
+                    $data = $this-&gt;_readChunked();
+                } else {
+                    $data = $this-&gt;_sock-&gt;read(4096);
+                }
+                if ('' == $data) {
+                    break;
+                } else {
+                    $hasBody = true;
+                    if ($saveBody || $gzipped) {
+                        $this-&gt;_body .= $data;
+                    }
+                    $this-&gt;_notify($gzipped? 'gzTick': 'tick', $data);
+                }
+            }
+        }
+        if ($hasBody) {
+            // Uncompress the body if needed
+            if ($gzipped) {
+                $this-&gt;_body = gzinflate(substr($this-&gt;_body, 10));
+                $this-&gt;_notify('gotBody', $this-&gt;_body);
+            } else {
+                $this-&gt;_notify('gotBody');
+            }
+        }
+        return true;
+    }
+
+
+   /**
+    * Processes the response header
+    *
+    * @access private
+    * @param  string    HTTP header
+    */
+    function _processHeader($header)
+    {
+        list($headername, $headervalue) = explode(':', $header, 2);
+        $headername  = strtolower($headername);
+        $headervalue = ltrim($headervalue);
+        
+        if ('set-cookie' != $headername) {
+            if (isset($this-&gt;_headers[$headername])) {
+                $this-&gt;_headers[$headername] .= ',' . $headervalue;
+            } else {
+                $this-&gt;_headers[$headername]  = $headervalue;
+            }
+        } else {
+            $this-&gt;_parseCookie($headervalue);
+        }
+    }
+
+
+   /**
+    * Parse a Set-Cookie header to fill $_cookies array
+    *
+    * @access private
+    * @param  string    value of Set-Cookie header
+    */
+    function _parseCookie($headervalue)
+    {
+        $cookie = array(
+            'expires' =&gt; null,
+            'domain'  =&gt; null,
+            'path'    =&gt; null,
+            'secure'  =&gt; false
+        );
+
+        // Only a name=value pair
+        if (!strpos($headervalue, ';')) {
+            $pos = strpos($headervalue, '=');
+            $cookie['name']  = trim(substr($headervalue, 0, $pos));
+            $cookie['value'] = trim(substr($headervalue, $pos + 1));
+
+        // Some optional parameters are supplied
+        } else {
+            $elements = explode(';', $headervalue);
+            $pos = strpos($elements[0], '=');
+            $cookie['name']  = trim(substr($elements[0], 0, $pos));
+            $cookie['value'] = trim(substr($elements[0], $pos + 1));
+
+            for ($i = 1; $i &lt; count($elements); $i++) {
+                if (false === strpos($elements[$i], '=')) {
+                    $elName  = trim($elements[$i]);
+                    $elValue = null;
+                } else {
+                    list ($elName, $elValue) = array_map('trim', explode('=', $elements[$i]));
+                }
+                $elName = strtolower($elName);
+                if ('secure' == $elName) {
+                    $cookie['secure'] = true;
+                } elseif ('expires' == $elName) {
+                    $cookie['expires'] = str_replace('&quot;', '', $elValue);
+                } elseif ('path' == $elName || 'domain' == $elName) {
+                    $cookie[$elName] = urldecode($elValue);
+                } else {
+                    $cookie[$elName] = $elValue;
+                }
+            }
+        }
+        $this-&gt;_cookies[] = $cookie;
+    }
+
+
+   /**
+    * Read a part of response body encoded with chunked Transfer-Encoding
+    * 
+    * @access private
+    * @return string
+    */
+    function _readChunked()
+    {
+        // at start of the next chunk?
+        if (0 == $this-&gt;_chunkLength) {
+            $line = $this-&gt;_sock-&gt;readLine();
+            if (preg_match('/^([0-9a-f]+)/i', $line, $matches)) {
+                $this-&gt;_chunkLength = hexdec($matches[1]); 
+                // Chunk with zero length indicates the end
+                if (0 == $this-&gt;_chunkLength) {
+                    $this-&gt;_sock-&gt;readLine(); // make this an eof()
+                    return '';
+                }
+            } else {
+                return '';
+            }
+        }
+        $data = $this-&gt;_sock-&gt;read($this-&gt;_chunkLength);
+        $this-&gt;_chunkLength -= strlen($data);
+        if (0 == $this-&gt;_chunkLength) {
+            $this-&gt;_sock-&gt;readLine(); // Trailing CRLF
+        }
+        return $data;
+    }
+
+
+   /**
+    * Notifies all registered listeners of an event.
+    * 
+    * @param    string  Event name
+    * @param    mixed   Additional data
+    * @access   private
+    * @see HTTP_Request::_notify()
+    */
+    function _notify($event, $data = null)
+    {
+        foreach (array_keys($this-&gt;_listeners) as $id) {
+            $this-&gt;_listeners[$id]-&gt;update($this, $event, $data);
+        }
+    }
+} // End class HTTP_Response
+?&gt;

Added: trunk/examples/basecamp_api/proxy/php/Socket.php
===================================================================
--- trunk/examples/basecamp_api/proxy/php/Socket.php	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/proxy/php/Socket.php	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,528 @@
+&lt;?php
+//
+// +----------------------------------------------------------------------+
+// | PHP Version 4                                                        |
+// +----------------------------------------------------------------------+
+// | Copyright (c) 1997-2003 The PHP Group                                |
+// +----------------------------------------------------------------------+
+// | This source file is subject to version 2.0 of the PHP license,       |
+// | that is bundled with this package in the file LICENSE, and is        |
+// | available at through the world-wide-web at                           |
+// | <A HREF="http://www.php.net/license/2_02.txt.">http://www.php.net/license/2_02.txt.</A>                                 |
+// | If you did not receive a copy of the PHP license and are unable to   |
+// | obtain it through the world-wide-web, please send a note to          |
+// | <A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">license at php.net</A> so we can mail you a copy immediately.               |
+// +----------------------------------------------------------------------+
+// | Authors: Stig Bakken &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">ssb at php.net</A>&gt;                                   |
+// |          Chuck Hagenbuch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">chuck at horde.org</A>&gt;                           |
+// +----------------------------------------------------------------------+
+//
+// $Id: Socket.php,v 1.24 2005/02/03 20:40:16 chagenbu Exp $
+
+require_once 'PEAR.php';
+
+define('NET_SOCKET_READ',  1);
+define('NET_SOCKET_WRITE', 2);
+define('NET_SOCKET_ERROR', 3);
+
+/**
+ * Generalized Socket class.
+ *
+ * @version 1.1
+ * @author Stig Bakken &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">ssb at php.net</A>&gt;
+ * @author Chuck Hagenbuch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">chuck at horde.org</A>&gt;
+ */
+class Net_Socket extends PEAR {
+
+    /**
+     * Socket file pointer.
+     * @var resource $fp
+     */
+    var $fp = null;
+
+    /**
+     * Whether the socket is blocking. Defaults to true.
+     * @var boolean $blocking
+     */
+    var $blocking = true;
+
+    /**
+     * Whether the socket is persistent. Defaults to false.
+     * @var boolean $persistent
+     */
+    var $persistent = false;
+
+    /**
+     * The IP address to connect to.
+     * @var string $addr
+     */
+    var $addr = '';
+
+    /**
+     * The port number to connect to.
+     * @var integer $port
+     */
+    var $port = 0;
+
+    /**
+     * Number of seconds to wait on socket connections before assuming
+     * there's no more data. Defaults to no timeout.
+     * @var integer $timeout
+     */
+    var $timeout = false;
+
+    /**
+     * Number of bytes to read at a time in readLine() and
+     * readAll(). Defaults to 2048.
+     * @var integer $lineLength
+     */
+    var $lineLength = 2048;
+
+    /**
+     * Connect to the specified port. If called when the socket is
+     * already connected, it disconnects and connects again.
+     *
+     * @param string  $addr        IP address or host name.
+     * @param integer $port        TCP port number.
+     * @param boolean $persistent  (optional) Whether the connection is
+     *                             persistent (kept open between requests
+     *                             by the web server).
+     * @param integer $timeout     (optional) How long to wait for data.
+     * @param array   $options     See options for stream_context_create.
+     *
+     * @access public
+     *
+     * @return boolean | PEAR_Error  True on success or a PEAR_Error on failure.
+     */
+    function connect($addr, $port = 0, $persistent = null, $timeout = null, $options = null)
+    {
+        if (is_resource($this-&gt;fp)) {
+            @fclose($this-&gt;fp);
+            $this-&gt;fp = null;
+        }
+
+        if (!$addr) {
+            return $this-&gt;raiseError('$addr cannot be empty');
+        } elseif (strspn($addr, '.0123456789') == strlen($addr) ||
+                  strstr($addr, '/') !== false) {
+            $this-&gt;addr = $addr;
+        } else {
+            $this-&gt;addr = @gethostbyname($addr);
+        }
+
+        $this-&gt;port = $port % 65536;
+
+        if ($persistent !== null) {
+            $this-&gt;persistent = $persistent;
+        }
+
+        if ($timeout !== null) {
+            $this-&gt;timeout = $timeout;
+        }
+
+        $openfunc = $this-&gt;persistent ? 'pfsockopen' : 'fsockopen';
+        $errno = 0;
+        $errstr = '';
+        if ($options &amp;&amp; function_exists('stream_context_create')) {
+            if ($this-&gt;timeout) {
+                $timeout = $this-&gt;timeout;
+            } else {
+                $timeout = 0;
+            }
+            $context = stream_context_create($options);
+            $fp = @$openfunc($this-&gt;addr, $this-&gt;port, $errno, $errstr, $timeout, $context);
+        } else {
+            if ($this-&gt;timeout) {
+                $fp = @$openfunc($this-&gt;addr, $this-&gt;port, $errno, $errstr, $this-&gt;timeout);
+            } else {
+                $fp = @$openfunc($this-&gt;addr, $this-&gt;port, $errno, $errstr);
+            }
+        }
+
+        if (!$fp) {
+            return $this-&gt;raiseError($errstr, $errno);
+        }
+
+        $this-&gt;fp = $fp;
+
+        return $this-&gt;setBlocking($this-&gt;blocking);
+    }
+
+    /**
+     * Disconnects from the peer, closes the socket.
+     *
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function disconnect()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        @fclose($this-&gt;fp);
+        $this-&gt;fp = null;
+        return true;
+    }
+
+    /**
+     * Find out if the socket is in blocking mode.
+     *
+     * @access public
+     * @return boolean  The current blocking mode.
+     */
+    function isBlocking()
+    {
+        return $this-&gt;blocking;
+    }
+
+    /**
+     * Sets whether the socket connection should be blocking or
+     * not. A read call to a non-blocking socket will return immediately
+     * if there is no data available, whereas it will block until there
+     * is data for blocking sockets.
+     *
+     * @param boolean $mode  True for blocking sockets, false for nonblocking.
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function setBlocking($mode)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $this-&gt;blocking = $mode;
+        socket_set_blocking($this-&gt;fp, $this-&gt;blocking);
+        return true;
+    }
+
+    /**
+     * Sets the timeout value on socket descriptor,
+     * expressed in the sum of seconds and microseconds
+     *
+     * @param integer $seconds  Seconds.
+     * @param integer $microseconds  Microseconds.
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function setTimeout($seconds, $microseconds)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        return socket_set_timeout($this-&gt;fp, $seconds, $microseconds);
+    }
+
+    /**
+     * Returns information about an existing socket resource.
+     * Currently returns four entries in the result array:
+     *
+     * &lt;p&gt;
+     * timed_out (bool) - The socket timed out waiting for data&lt;br&gt;
+     * blocked (bool) - The socket was blocked&lt;br&gt;
+     * eof (bool) - Indicates EOF event&lt;br&gt;
+     * unread_bytes (int) - Number of bytes left in the socket buffer&lt;br&gt;
+     * &lt;/p&gt;
+     *
+     * @access public
+     * @return mixed Array containing information about existing socket resource or an error object otherwise
+     */
+    function getStatus()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        return socket_get_status($this-&gt;fp);
+    }
+
+    /**
+     * Get a specified line of data
+     *
+     * @access public
+     * @return $size bytes of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function gets($size)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        return @fgets($this-&gt;fp, $size);
+    }
+
+    /**
+     * Read a specified amount of data. This is guaranteed to return,
+     * and has the added benefit of getting everything in one fread()
+     * chunk; if you know the size of the data you're getting
+     * beforehand, this is definitely the way to go.
+     *
+     * @param integer $size  The number of bytes to read from the socket.
+     * @access public
+     * @return $size bytes of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function read($size)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        return @fread($this-&gt;fp, $size);
+    }
+
+    /**
+     * Write a specified amount of data.
+     *
+     * @param string  $data       Data to write.
+     * @param integer $blocksize  Amount of data to write at once.
+     *                            NULL means all at once.
+     *
+     * @access public
+     * @return mixed true on success or an error object otherwise
+     */
+    function write($data, $blocksize = null)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        if (is_null($blocksize) &amp;&amp; !OS_WINDOWS) {
+            return fwrite($this-&gt;fp, $data);
+        } else {
+            if (is_null($blocksize)) {
+                $blocksize = 1024;
+            }
+
+            $pos = 0;
+            $size = strlen($data);
+            while ($pos &lt; $size) {
+                $written = @fwrite($this-&gt;fp, substr($data, $pos, $blocksize));
+                if ($written === false) {
+                    return false;
+                }
+                $pos += $written;
+            }
+
+            return $pos;
+        }
+    }
+
+    /**
+     * Write a line of data to the socket, followed by a trailing &quot;\r\n&quot;.
+     *
+     * @access public
+     * @return mixed fputs result, or an error
+     */
+    function writeLine($data)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        return fwrite($this-&gt;fp, $data . &quot;\r\n&quot;);
+    }
+
+    /**
+     * Tests for end-of-file on a socket descriptor.
+     *
+     * @access public
+     * @return bool
+     */
+    function eof()
+    {
+        return (is_resource($this-&gt;fp) &amp;&amp; feof($this-&gt;fp));
+    }
+
+    /**
+     * Reads a byte of data
+     *
+     * @access public
+     * @return 1 byte of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readByte()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        return ord(@fread($this-&gt;fp, 1));
+    }
+
+    /**
+     * Reads a word of data
+     *
+     * @access public
+     * @return 1 word of data from the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readWord()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $buf = @fread($this-&gt;fp, 2);
+        return (ord($buf[0]) + (ord($buf[1]) &lt;&lt; 8));
+    }
+
+    /**
+     * Reads an int of data
+     *
+     * @access public
+     * @return integer  1 int of data from the socket, or a PEAR_Error if
+     *                  not connected.
+     */
+    function readInt()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $buf = @fread($this-&gt;fp, 4);
+        return (ord($buf[0]) + (ord($buf[1]) &lt;&lt; 8) +
+                (ord($buf[2]) &lt;&lt; 16) + (ord($buf[3]) &lt;&lt; 24));
+    }
+
+    /**
+     * Reads a zero-terminated string of data
+     *
+     * @access public
+     * @return string, or a PEAR_Error if
+     *         not connected.
+     */
+    function readString()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $string = '';
+        while (($char = @fread($this-&gt;fp, 1)) != &quot;\x00&quot;)  {
+            $string .= $char;
+        }
+        return $string;
+    }
+
+    /**
+     * Reads an IP Address and returns it in a dot formated string
+     *
+     * @access public
+     * @return Dot formated string, or a PEAR_Error if
+     *         not connected.
+     */
+    function readIPAddress()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $buf = @fread($this-&gt;fp, 4);
+        return sprintf(&quot;%s.%s.%s.%s&quot;, ord($buf[0]), ord($buf[1]),
+                       ord($buf[2]), ord($buf[3]));
+    }
+
+    /**
+     * Read until either the end of the socket or a newline, whichever
+     * comes first. Strips the trailing newline from the returned data.
+     *
+     * @access public
+     * @return All available data up to a newline, without that
+     *         newline, or until the end of the socket, or a PEAR_Error if
+     *         not connected.
+     */
+    function readLine()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $line = '';
+        $timeout = time() + $this-&gt;timeout;
+        while (!feof($this-&gt;fp) &amp;&amp; (!$this-&gt;timeout || time() &lt; $timeout)) {
+            $line .= @fgets($this-&gt;fp, $this-&gt;lineLength);
+            if (substr($line, -1) == &quot;\n&quot;) {
+                return rtrim($line, &quot;\r\n&quot;);
+            }
+        }
+        return $line;
+    }
+
+    /**
+     * Read until the socket closes, or until there is no more data in
+     * the inner PHP buffer. If the inner buffer is empty, in blocking
+     * mode we wait for at least 1 byte of data. Therefore, in
+     * blocking mode, if there is no data at all to be read, this
+     * function will never exit (unless the socket is closed on the
+     * remote end).
+     *
+     * @access public
+     *
+     * @return string  All data until the socket closes, or a PEAR_Error if
+     *                 not connected.
+     */
+    function readAll()
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $data = '';
+        while (!feof($this-&gt;fp)) {
+            $data .= @fread($this-&gt;fp, $this-&gt;lineLength);
+        }
+        return $data;
+    }
+
+    /**
+     * Runs the equivalent of the select() system call on the socket
+     * with a timeout specified by tv_sec and tv_usec.
+     *
+     * @param integer $state    Which of read/write/error to check for.
+     * @param integer $tv_sec   Number of seconds for timeout.
+     * @param integer $tv_usec  Number of microseconds for timeout.
+     *
+     * @access public
+     * @return False if select fails, integer describing which of read/write/error
+     *         are ready, or PEAR_Error if not connected.
+     */
+    function select($state, $tv_sec, $tv_usec = 0)
+    {
+        if (!is_resource($this-&gt;fp)) {
+            return $this-&gt;raiseError('not connected');
+        }
+
+        $read = null;
+        $write = null;
+        $except = null;
+        if ($state &amp; NET_SOCKET_READ) {
+            $read[] = $this-&gt;fp;
+        }
+        if ($state &amp; NET_SOCKET_WRITE) {
+            $write[] = $this-&gt;fp;
+        }
+        if ($state &amp; NET_SOCKET_ERROR) {
+            $except[] = $this-&gt;fp;
+        }
+        if (false === ($sr = stream_select($read, $write, $except, $tv_sec, $tv_usec))) {
+            return false;
+        }
+
+        $result = 0;
+        if (count($read)) {
+            $result |= NET_SOCKET_READ;
+        }
+        if (count($write)) {
+            $result |= NET_SOCKET_WRITE;
+        }
+        if (count($except)) {
+            $result |= NET_SOCKET_ERROR;
+        }
+        return $result;
+    }
+
+}

Added: trunk/examples/basecamp_api/proxy/php/URL.php
===================================================================
--- trunk/examples/basecamp_api/proxy/php/URL.php	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/proxy/php/URL.php	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,410 @@
+&lt;?php
+// +-----------------------------------------------------------------------+
+// | Copyright (c) 2002-2004, Richard Heyes                                |
+// | All rights reserved.                                                  |
+// |                                                                       |
+// | Redistribution and use in source and binary forms, with or without    |
+// | modification, are permitted provided that the following conditions    |
+// | are met:                                                              |
+// |                                                                       |
+// | o Redistributions of source code must retain the above copyright      |
+// |   notice, this list of conditions and the following disclaimer.       |
+// | o Redistributions in binary form must reproduce the above copyright   |
+// |   notice, this list of conditions and the following disclaimer in the |
+// |   documentation and/or other materials provided with the distribution.|
+// | o The names of the authors may not be used to endorse or promote      |
+// |   products derived from this software without specific prior written  |
+// |   permission.                                                         |
+// |                                                                       |
+// | THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   |
+// | &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     |
+// | LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR |
+// | A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  |
+// | OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, |
+// | SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT      |
+// | LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, |
+// | DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY |
+// | THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   |
+// | (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE |
+// | OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  |
+// |                                                                       |
+// +-----------------------------------------------------------------------+
+// | Author: Richard Heyes &lt;richard at php net&gt;                            |
+// +-----------------------------------------------------------------------+
+//
+// $Id: URL.php,v 1.36 2004/06/19 18:58:50 richard Exp $
+//
+// Net_URL Class
+
+class Net_URL
+{
+    /**
+    * Full url
+    * @var string
+    */
+    var $url;
+
+    /**
+    * Protocol
+    * @var string
+    */
+    var $protocol;
+
+    /**
+    * Username
+    * @var string
+    */
+    var $username;
+
+    /**
+    * Password
+    * @var string
+    */
+    var $password;
+
+    /**
+    * Host
+    * @var string
+    */
+    var $host;
+
+    /**
+    * Port
+    * @var integer
+    */
+    var $port;
+
+    /**
+    * Path
+    * @var string
+    */
+    var $path;
+
+    /**
+    * Query string
+    * @var array
+    */
+    var $querystring;
+
+    /**
+    * Anchor
+    * @var string
+    */
+    var $anchor;
+
+    /**
+    * Whether to use []
+    * @var bool
+    */
+    var $useBrackets;
+
+    /**
+    * PHP4 Constructor
+    *
+    * @see __construct()
+    */
+    function Net_URL($url = null, $useBrackets = true)
+    {
+        $this-&gt;__construct($url, $useBrackets);
+    }
+
+    /**
+    * PHP5 Constructor
+    *
+    * Parses the given url and stores the various parts
+    * Defaults are used in certain cases
+    *
+    * @param string $url         Optional URL
+    * @param bool   $useBrackets Whether to use square brackets when
+    *                            multiple querystrings with the same name
+    *                            exist
+    */
+    function __construct($url = null, $useBrackets = true)
+    {
+        $HTTP_SERVER_VARS  = !empty($_SERVER) ? $_SERVER : $GLOBALS['HTTP_SERVER_VARS'];
+
+        $this-&gt;useBrackets = $useBrackets;
+        $this-&gt;url         = $url;
+        $this-&gt;user        = '';
+        $this-&gt;pass        = '';
+        $this-&gt;host        = '';
+        $this-&gt;port        = 80;
+        $this-&gt;path        = '';
+        $this-&gt;querystring = array();
+        $this-&gt;anchor      = '';
+
+        // Only use defaults if not an absolute URL given
+        if (!preg_match('/^[a-z0-9]+:\/\//i', $url)) {
+
+            $this-&gt;protocol    = (@$HTTP_SERVER_VARS['HTTPS'] == 'on' ? 'https' : 'http');
+
+            /**
+            * Figure out host/port
+            */
+            if (!empty($HTTP_SERVER_VARS['HTTP_HOST']) AND preg_match('/^(.*)(:([0-9]+))?$/U', $HTTP_SERVER_VARS['HTTP_HOST'], $matches)) {
+                $host = $matches[1];
+                if (!empty($matches[3])) {
+                    $port = $matches[3];
+                } else {
+                    $port = $this-&gt;getStandardPort($this-&gt;protocol);
+                }
+            }
+
+            $this-&gt;user        = '';
+            $this-&gt;pass        = '';
+            $this-&gt;host        = !empty($host) ? $host : (isset($HTTP_SERVER_VARS['SERVER_NAME']) ? $HTTP_SERVER_VARS['SERVER_NAME'] : 'localhost');
+            $this-&gt;port        = !empty($port) ? $port : (isset($HTTP_SERVER_VARS['SERVER_PORT']) ? $HTTP_SERVER_VARS['SERVER_PORT'] : $this-&gt;getStandardPort($this-&gt;protocol));
+            $this-&gt;path        = !empty($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : '/';
+            $this-&gt;querystring = isset($HTTP_SERVER_VARS['QUERY_STRING']) ? $this-&gt;_parseRawQuerystring($HTTP_SERVER_VARS['QUERY_STRING']) : null;
+            $this-&gt;anchor      = '';
+        }
+
+        // Parse the url and store the various parts
+        if (!empty($url)) {
+            $urlinfo = parse_url($url);
+
+            // Default querystring
+            $this-&gt;querystring = array();
+
+            foreach ($urlinfo as $key =&gt; $value) {
+                switch ($key) {
+                    case 'scheme':
+                        $this-&gt;protocol = $value;
+                        $this-&gt;port     = $this-&gt;getStandardPort($value);
+                        break;
+
+                    case 'user':
+                    case 'pass':
+                    case 'host':
+                    case 'port':
+                        $this-&gt;$key = $value;
+                        break;
+
+                    case 'path':
+                        if ($value{0} == '/') {
+                            $this-&gt;path = $value;
+                        } else {
+                            $path = dirname($this-&gt;path) == DIRECTORY_SEPARATOR ? '' : dirname($this-&gt;path);
+                            $this-&gt;path = sprintf('%s/%s', $path, $value);
+                        }
+                        break;
+
+                    case 'query':
+                        $this-&gt;querystring = $this-&gt;_parseRawQueryString($value);
+                        break;
+
+                    case 'fragment':
+                        $this-&gt;anchor = $value;
+                        break;
+                }
+            }
+        }
+    }
+
+    /**
+    * Returns full url
+    *
+    * @return string Full url
+    * @access public
+    */
+    function getURL()
+    {
+        $querystring = $this-&gt;getQueryString();
+
+        $this-&gt;url = $this-&gt;protocol . '://'
+                   . $this-&gt;user . (!empty($this-&gt;pass) ? ':' : '')
+                   . $this-&gt;pass . (!empty($this-&gt;user) ? '@' : '')
+                   . $this-&gt;host . ($this-&gt;port == $this-&gt;getStandardPort($this-&gt;protocol) ? '' : ':' . $this-&gt;port)
+                   . $this-&gt;path
+                   . (!empty($querystring) ? '?' . $querystring : '')
+                   . (!empty($this-&gt;anchor) ? '#' . $this-&gt;anchor : '');
+
+        return $this-&gt;url;
+    }
+
+    /**
+    * Adds a querystring item
+    *
+    * @param  string $name       Name of item
+    * @param  string $value      Value of item
+    * @param  bool   $preencoded Whether value is urlencoded or not, default = not
+    * @access public
+    */
+    function addQueryString($name, $value, $preencoded = false)
+    {
+        if ($preencoded) {
+            $this-&gt;querystring[$name] = $value;
+        } else {
+            $this-&gt;querystring[$name] = is_array($value) ? array_map('rawurlencode', $value): rawurlencode($value);
+        }
+    }
+
+    /**
+    * Removes a querystring item
+    *
+    * @param  string $name Name of item
+    * @access public
+    */
+    function removeQueryString($name)
+    {
+        if (isset($this-&gt;querystring[$name])) {
+            unset($this-&gt;querystring[$name]);
+        }
+    }
+
+    /**
+    * Sets the querystring to literally what you supply
+    *
+    * @param  string $querystring The querystring data. Should be of the format foo=bar&amp;x=y etc
+    * @access public
+    */
+    function addRawQueryString($querystring)
+    {
+        $this-&gt;querystring = $this-&gt;_parseRawQueryString($querystring);
+    }
+
+    /**
+    * Returns flat querystring
+    *
+    * @return string Querystring
+    * @access public
+    */
+    function getQueryString()
+    {
+        if (!empty($this-&gt;querystring)) {
+            foreach ($this-&gt;querystring as $name =&gt; $value) {
+                if (is_array($value)) {
+                    foreach ($value as $k =&gt; $v) {
+                        $querystring[] = $this-&gt;useBrackets ? sprintf('%s[%s]=%s', $name, $k, $v) : ($name . '=' . $v);
+                    }
+                } elseif (!is_null($value)) {
+                    $querystring[] = $name . '=' . $value;
+                } else {
+                    $querystring[] = $name;
+                }
+            }
+            $querystring = implode(ini_get('arg_separator.output'), $querystring);
+        } else {
+            $querystring = '';
+        }
+
+        return $querystring;
+    }
+
+    /**
+    * Parses raw querystring and returns an array of it
+    *
+    * @param  string  $querystring The querystring to parse
+    * @return array                An array of the querystring data
+    * @access private
+    */
+    function _parseRawQuerystring($querystring)
+    {
+        $parts  = preg_split('/[' . preg_quote(ini_get('arg_separator.input'), '/') . ']/', $querystring, -1, PREG_SPLIT_NO_EMPTY);
+        $return = array();
+
+        foreach ($parts as $part) {
+            if (strpos($part, '=') !== false) {
+                $value = substr($part, strpos($part, '=') + 1);
+                $key   = substr($part, 0, strpos($part, '='));
+            } else {
+                $value = null;
+                $key   = $part;
+            }
+            if (substr($key, -2) == '[]') {
+                $key = substr($key, 0, -2);
+                if (@!is_array($return[$key])) {
+                    $return[$key]   = array();
+                    $return[$key][] = $value;
+                } else {
+                    $return[$key][] = $value;
+                }
+            } elseif (!$this-&gt;useBrackets AND !empty($return[$key])) {
+                $return[$key]   = (array)$return[$key];
+                $return[$key][] = $value;
+            } else {
+                $return[$key] = $value;
+            }
+        }
+
+        return $return;
+    }
+
+    /**
+    * Resolves //, ../ and ./ from a path and returns
+    * the result. Eg:
+    *
+    * /foo/bar/../boo.php    =&gt; /foo/boo.php
+    * /foo/bar/../../boo.php =&gt; /boo.php
+    * /foo/bar/.././/boo.php =&gt; /foo/boo.php
+    *
+    * This method can also be called statically.
+    *
+    * @param  string $url URL path to resolve
+    * @return string      The result
+    */
+    function resolvePath($path)
+    {
+        $path = explode('/', str_replace('//', '/', $path));
+
+        for ($i=0; $i&lt;count($path); $i++) {
+            if ($path[$i] == '.') {
+                unset($path[$i]);
+                $path = array_values($path);
+                $i--;
+
+            } elseif ($path[$i] == '..' AND ($i &gt; 1 OR ($i == 1 AND $path[0] != '') ) ) {
+                unset($path[$i]);
+                unset($path[$i-1]);
+                $path = array_values($path);
+                $i -= 2;
+
+            } elseif ($path[$i] == '..' AND $i == 1 AND $path[0] == '') {
+                unset($path[$i]);
+                $path = array_values($path);
+                $i--;
+
+            } else {
+                continue;
+            }
+        }
+
+        return implode('/', $path);
+    }
+
+    /**
+    * Returns the standard port number for a protocol
+    *
+    * @param  string  $scheme The protocol to lookup
+    * @return integer         Port number or NULL if no scheme matches
+    *
+    * @author Philippe Jausions &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">Philippe.Jausions at 11abacus.com</A>&gt;
+    */
+    function getStandardPort($scheme)
+    {
+        switch (strtolower($scheme)) {
+            case 'http':    return 80;
+            case 'https':   return 443;
+            case 'ftp':     return 21;
+            case 'imap':    return 143;
+            case 'imaps':   return 993;
+            case 'pop3':    return 110;
+            case 'pop3s':   return 995;
+            default:        return null;
+       }
+    }
+
+    /**
+    * Forces the URL to a particular protocol
+    *
+    * @param string  $protocol Protocol to force the URL to
+    * @param integer $port     Optional port (standard port is used by default)
+    */
+    function setProtocol($protocol, $port = null)
+    {
+        $this-&gt;protocol = $protocol;
+        $this-&gt;port = is_null($port) ? $this-&gt;getStandardPort() : $port;
+    }
+
+}
+?&gt;

Added: trunk/examples/basecamp_api/proxy/php/proxy.php
===================================================================
--- trunk/examples/basecamp_api/proxy/php/proxy.php	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/proxy/php/proxy.php	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,47 @@
+&lt;?php
+	
+	$login    = &quot;freja&quot;;
+	$password = &quot;apitest&quot;;
+	$baseUrl  = &quot;<A HREF="http://freja.projectpath.com/">http://freja.projectpath.com/</A>&quot;;
+	
+	$HTTPMethod     = $_GET['HTTP_REQUEST_METHOD'];
+	$HTTPRequestUrl = $_GET['HTTP_REQUEST_URL'];
+	
+	include('Request.php');
+
+	// safety check, only request legit url
+	if(strpos($HTTPRequestUrl,$baseUrl)===0) {
+
+		$req = &amp;new HTTP_Request($HTTPRequestUrl);
+		$req-&gt;setBasicAuth($login,$password);
+		$req-&gt;setMethod($HTTPMethod);	
+		$req-&gt;addHeader('Content-Type','application/xml');
+		$req-&gt;addHeader('Accept','application/xml');
+		$req-&gt;clearPostData();		
+		// $req-&gt;addPostData('Foo', 'bar');
+		$req-&gt;sendRequest();
+		
+		$response = $req-&gt;getResponseBody();
+		$code     = $req-&gt;getResponseCode();
+		
+		switch($code) {
+			case 200:
+				header(&quot;HTTP/1.0 200 Ok&quot;);
+				break;
+			case 201:
+				header(&quot;HTTP/1.0 201 Created&quot;);
+				break;
+			case 404:
+				header(&quot;HTTP/1.0 404 Not Found&quot;);
+				break;				
+		}
+		header('Content-Type: text/xml');
+		echo $response;
+	} 
+	else {
+		header(&quot;HTTP/1.0 403 Forbidden&quot;);
+		echo &quot;Requested url not allowed.&quot;;
+	}
+
+
+?&gt;
\ No newline at end of file

Added: trunk/examples/basecamp_api/views/project.xsl
===================================================================
--- trunk/examples/basecamp_api/views/project.xsl	2006-04-17 20:47:15 UTC (rev 48)
+++ trunk/examples/basecamp_api/views/project.xsl	2006-04-18 21:34:47 UTC (rev 49)
@@ -0,0 +1,37 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;xsl:stylesheet version=&quot;1.0&quot;
+	xmlns:xsl=&quot;<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>&quot;&gt;
+
+&lt;xsl:template match=&quot;projects&quot;&gt;	
+	&lt;xsl:apply-templates /&gt;
+&lt;/xsl:template&gt;
+
+&lt;xsl:template match=&quot;project&quot;&gt;	
+	&lt;form method=&quot;post&quot; action=&quot;#&quot; id=&quot;project__{id}&quot;&gt;
+		&lt;label for=&quot;projectname&quot; class=&quot;preField&quot;&gt;Project Name: &lt;/label&gt;
+		&lt;input type=&quot;text&quot; name=&quot;//project[id={id}]/name&quot; value=&quot;{name}&quot; /&gt;&lt;br/&gt;
+		
+		&lt;label for=&quot;projectstatus&quot; class=&quot;preField&quot;&gt;Project Status: &lt;/label&gt;
+		&lt;select name=&quot;//project[id={id}]/status&quot;&gt;
+			&lt;option value='active'&gt;
+				&lt;xsl:if test=&quot;status='active'&quot;&gt;
+					&lt;xsl:attribute name='selected'&gt;selected&lt;/xsl:attribute&gt;
+				&lt;/xsl:if&gt;
+				active
+			&lt;/option&gt;
+			&lt;option value='inactive'&gt;
+				&lt;xsl:if test=&quot;status='inactive'&quot;&gt;
+					&lt;xsl:attribute name='selected'&gt;selected&lt;/xsl:attribute&gt;
+				&lt;/xsl:if&gt;
+				inactive
+			&lt;/option&gt;
+		&lt;/select&gt;&lt;br/&gt;
+		&lt;p&gt;
+			&lt;input type=&quot;button&quot; value=&quot;cancel&quot; /&gt;
+			&lt;input type=&quot;submit&quot; value=&quot;ok&quot; /&gt;
+		&lt;/p&gt;
+	&lt;/form&gt;
+&lt;/xsl:template&gt;
+
+&lt;xsl:template match=&quot;text()&quot; /&gt;
+&lt;/xsl:stylesheet&gt;
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000044.html">[Freja-svn] r48 - trunk/src
</A></li>
	<LI>Next message: <A HREF="000046.html">[Freja-svn] r50 - trunk/examples/basecamp_api/proxy/php
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#45">[ date ]</a>
              <a href="thread.html#45">[ thread ]</a>
              <a href="subject.html#45">[ subject ]</a>
              <a href="author.html#45">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/freja-svn">More information about the Freja-svn
mailing list</a><br>
</body></html>
