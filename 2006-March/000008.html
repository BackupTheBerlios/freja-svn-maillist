<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Freja-svn] r10 - in trunk: . examples/contacts external lib tests
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/freja-svn/2006-March/index.html" >
   <LINK REL="made" HREF="mailto:freja-svn%40lists.berlios.de?Subject=Re%3A%20%5BFreja-svn%5D%20r10%20-%20in%20trunk%3A%20.%20examples/contacts%20external%20lib%20tests&In-Reply-To=%3C200603190142.k2J1gNXa014820%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000005.html">
   <LINK REL="Next"  HREF="000006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Freja-svn] r10 - in trunk: . examples/contacts external lib tests</H1>
    <B>troelskn at BerliOS</B> 
    <A HREF="mailto:freja-svn%40lists.berlios.de?Subject=Re%3A%20%5BFreja-svn%5D%20r10%20-%20in%20trunk%3A%20.%20examples/contacts%20external%20lib%20tests&In-Reply-To=%3C200603190142.k2J1gNXa014820%40sheep.berlios.de%3E"
       TITLE="[Freja-svn] r10 - in trunk: . examples/contacts external lib tests">troelskn at berlios.de
       </A><BR>
    <I>Sun Mar 19 02:42:23 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000005.html">[Freja-svn] r9 - trunk/lib
</A></li>
        <LI>Next message: <A HREF="000006.html">[Freja-svn] r11 - in trunk: examples/contacts examples/contacts/models/php_inc examples/contacts/views lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: troelskn
Date: 2006-03-19 02:41:45 +0100 (Sun, 19 Mar 2006)
New Revision: 10

Added:
   trunk/external/
   trunk/external/srvc-xslt.php
Removed:
   trunk/examples/contacts/srvc-xslt.php
Modified:
   trunk/examples/contacts/client.js
   trunk/lib/Freja.js
   trunk/lib/MochiKit.js
   trunk/tests/test_View.js
Log:
Further integration of MochiKit.Async.Deferred
Fixed tests to run at Opera

Modified: trunk/examples/contacts/client.js
===================================================================
--- trunk/examples/contacts/client.js	2006-03-12 15:56:31 UTC (rev 9)
+++ trunk/examples/contacts/client.js	2006-03-19 01:41:45 UTC (rev 10)
@@ -1,5 +1,6 @@
 // model : contacts
 var contacts = new Freja.Model.DataSource(&quot;models/contact.php&quot;, &quot;models/contacts.php&quot;);
+Freja.AssetManager.XSLT_SERVICE_URL = &quot;../../external/srvc-xslt.php?path=examples/contacts/&quot;;
 
 // view : index
 var index = getView(&quot;views/index.xsl&quot;);

Deleted: trunk/examples/contacts/srvc-xslt.php
===================================================================
--- trunk/examples/contacts/srvc-xslt.php	2006-03-12 15:56:31 UTC (rev 9)
+++ trunk/examples/contacts/srvc-xslt.php	2006-03-19 01:41:45 UTC (rev 10)
@@ -1,70 +0,0 @@
-&lt;?php
-	function error_handler($errno, $errstr, $errfile, $errline) {
-		if (error_reporting() == 0) {
-			return;
-		}
-		header(&quot;HTTP/1.0 500 Internal Error&quot;);
-		header('Content-Type: text/xml');
-		echo $errstr;
-		exit;
-	}
-	function exception_handler($ex) {
-		error_handler($ex-&gt;getCode(), $ex-&gt;getMessage(), $ex-&gt;getFile(), $ex-&gt;getLine());
-	}
-	set_error_handler('error_handler');
-	if (function_exists('set_exception_handler')) {
-		set_exception_handler('exception_handler');
-	}
-
-	// XSL Transformation Service for Freja
-	// PHP4.0 Version 1.0
-
-	// Freja - a javascript Model-View-Controller Framework geared toward Zero-Latency Web Applications
-	// v1.0 Beta - Dec. 2005
-	// Copyright (c) 2005 C&#233;dric Savarese &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">pro at 4213miles.com</A>&gt;
-	// This software is licensed under the CC-GNU LGPL &lt;<A HREF="http://creativecommons.org/licenses/LGPL/2.1/">http://creativecommons.org/licenses/LGPL/2.1/</A>&gt;
-	// Documentation : <A HREF="http://www.csscripting.com/freja">http://www.csscripting.com/freja</A>
-
-
-	if(isset($_POST['xmlData']) &amp;&amp; isset($_POST['xslFile'])) {
-//		if (get_magic_quotes_gpc()) {
-//			array_map('stripslashes', $_POST);
-//		}
-		$xmlData     = stripslashes($_POST['xmlData']);
-		$xslFile     = dirname(__FILE__).&quot;/&quot;.stripslashes($_POST['xslFile']);
-
-		if (!preg_match(&quot;/^&quot;.preg_quote(realpath(dirname(__FILE__)), &quot;/&quot;).&quot;/&quot;, realpath($xslFile))) {
-			trigger_error(&quot;Illegal filename&quot;);
-		}
-		$arrXslParam = array();
-
-		if(isset($_POST['xslParam'])) {
-			$xslParam = $_POST['xslParam'];   // encoded as param_name1,value1,param_name2,value2
-			$arrXsl   = split(&quot;,&quot;,$xslParam);
-			for($i=0;$i&lt;count($arrXsl);$i+=2) {
-				$arrXslParam[$arrXsl[$i]] = $arrXsl[$i+1];
-			}
-		}
-		$xmlDoc = domxml_open_mem($xmlData, DOMXML_LOAD_DONT_KEEP_BLANKS);
-		if($xmlDoc) {
-			$xslDoc = domxml_xslt_stylesheet_file($xslFile);
-			if(!$xslDoc)
-				trigger_error(&quot;XSL_TRANSFORMATION: Load XSL failed. File path was: $xslFile.\n&quot;);
-			$transformedData = $xslDoc-&gt;process($xmlDoc, $arrXslParam);
-			if(!$transformedData)
-				trigger_error(&quot;XSL_TRANSFORMATION: Transformation failed.\n&quot;);
-			$xhtmlOuput = str_replace('&lt;?xml version=&quot;1.0&quot;?&gt;','',$xslDoc-&gt;result_dump_mem($transformedData));
-
-			header(&quot;HTTP/1.0 200 Ok&quot;);
-			header('Content-Type: text/xml');
-			echo $xhtmlOuput;
-
-		} else {
-			trigger_error(&quot;XSL_TRANSFORMATION: Parsing Error. Data was: $xmlData.\n&quot;);
-		}
-	}
-	else {
-		trigger_error (&quot;XSL_TRANSFORMATION: Bad Request.&quot;);
-		trigger_error(&quot;Bad Request.&quot;);
-	}
-?&gt;
\ No newline at end of file

Added: trunk/external/srvc-xslt.php
===================================================================
--- trunk/external/srvc-xslt.php	2006-03-12 15:56:31 UTC (rev 9)
+++ trunk/external/srvc-xslt.php	2006-03-19 01:41:45 UTC (rev 10)
@@ -0,0 +1,78 @@
+&lt;?php
+	function error_handler($errno, $errstr, $errfile, $errline) {
+		if (error_reporting() == 0) {
+			return;
+		}
+		$filename = &quot;log.txt&quot;;
+		if (!is_file($filename)) {
+			@fclose(fopen($filename, &quot;w&quot;));
+		}
+		error_log($errstr.&quot;\n&quot;, 3, $filename);
+		header(&quot;HTTP/1.0 500 Internal Error&quot;);
+		header('Content-Type: text/xml');
+		echo &quot;&lt;?xml version='1.0' ?&gt;&lt;error&gt;&quot;.$errstr.&quot;&lt;/error&gt;&quot;;
+		exit;
+	}
+	function exception_handler($ex) {
+		error_handler($ex-&gt;getCode(), $ex-&gt;getMessage(), $ex-&gt;getFile(), $ex-&gt;getLine());
+	}
+	set_error_handler('error_handler');
+	if (function_exists('set_exception_handler')) {
+		set_exception_handler('exception_handler');
+	}
+
+	// XSL Transformation Service for Freja
+	// PHP4.0 Version 1.0
+
+	// Freja - a javascript Model-View-Controller Framework geared toward Zero-Latency Web Applications
+	// v1.0 Beta - Dec. 2005
+	// Copyright (c) 2005 C&#233;dric Savarese &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/freja-svn">pro at 4213miles.com</A>&gt;
+	// This software is licensed under the CC-GNU LGPL &lt;<A HREF="http://creativecommons.org/licenses/LGPL/2.1/">http://creativecommons.org/licenses/LGPL/2.1/</A>&gt;
+	// Documentation : <A HREF="http://www.csscripting.com/freja">http://www.csscripting.com/freja</A>
+
+
+	if (isset($_POST['xmlData']) &amp;&amp; isset($_POST['xslFile'])) {
+//		if (get_magic_quotes_gpc()) {
+//			array_map('stripslashes', $_POST);
+//		}
+		$root = realpath(dirname(__FILE__).&quot;/../&quot;);
+		$xmlData = stripslashes($_POST['xmlData']);
+		$path = isset($_GET['path']) ? (&quot;/&quot;.stripslashes($_GET['path'])) : &quot;&quot;;
+		$xslFile = $root.$path.&quot;/&quot;.stripslashes($_POST['xslFile']);
+
+		if (!preg_match(&quot;/^&quot;.preg_quote(realpath($root), &quot;/&quot;).&quot;/&quot;, realpath($xslFile))) {
+			trigger_error(&quot;Illegal filename '$xslFile'&quot;);
+		}
+		$arrXslParam = array();
+
+		if (isset($_POST['xslParam'])) {
+			$xslParam = $_POST['xslParam'];   // encoded as param_name1,value1,param_name2,value2
+			$arrXsl   = split(&quot;,&quot;,$xslParam);
+			for ($i=0;$i&lt;count($arrXsl);$i+=2) {
+				$arrXslParam[$arrXsl[$i]] = $arrXsl[$i+1];
+			}
+		}
+		$xmlDoc = domxml_open_mem($xmlData, DOMXML_LOAD_DONT_KEEP_BLANKS);
+		if ($xmlDoc) {
+			$xslDoc = domxml_xslt_stylesheet_file($xslFile);
+			if (!$xslDoc) {
+				trigger_error(&quot;XSL_TRANSFORMATION: Load XSL failed. File path was: $xslFile.\n&quot;);
+			}
+			$transformedData = $xslDoc-&gt;process($xmlDoc, $arrXslParam);
+			if (!$transformedData) {
+				trigger_error(&quot;XSL_TRANSFORMATION: Transformation failed.\n&quot;);
+			}
+			$xhtmlOuput = str_replace('&lt;?xml version=&quot;1.0&quot;?&gt;','',$xslDoc-&gt;result_dump_mem($transformedData));
+
+			header(&quot;HTTP/1.0 200 Ok&quot;);
+			header('Content-Type: text/xml');
+			echo $xhtmlOuput;
+
+		} else {
+			trigger_error(&quot;XSL_TRANSFORMATION: Parsing Error. Data was: $xmlData.\n&quot;);
+		}
+	}
+	else {
+		trigger_error(&quot;XSL_TRANSFORMATION: Bad Request.&quot;);
+	}
+?&gt;
\ No newline at end of file

Modified: trunk/lib/Freja.js
===================================================================
--- trunk/lib/Freja.js	2006-03-12 15:56:31 UTC (rev 9)
+++ trunk/lib/Freja.js	2006-03-19 01:41:45 UTC (rev 10)
@@ -369,15 +369,54 @@
   * @param    model            Freja.Model
   * @param    placeholder      string    If supplied, this will be used instead of the
   *                                      default placeholder.
-  * @todo  Return a deferred
+  * @returns MochiKit.Async.Deferred
   */
 Freja.View.prototype.render = function(model, placeholder /* optional */ ) {
+
+	var Handler = function(model, view, deferred) {
+		this.model = model;
+		this.view = view;
+		this.deferred = deferred;
+	}
+
+	Handler.prototype.trigger = function() {
+		try {
+			if (!this.view.ready) {
+				connect(this.view, &quot;onload&quot;, bind(this.trigger, this));
+				return;
+			}
+			if (this.model &amp;&amp; !this.model.ready) {
+				connect(this.model, &quot;onload&quot;, bind(this.trigger, this));
+				return;
+			}
+			if (!model) {
+				model = { document : (new DOMParser()).parseFromString(&quot;&lt;?xml version='1.0' ?&gt;&lt;dummy/&gt;&quot;, &quot;text/xml&quot;)};
+			}
+			var trans = this.view.renderer.transform(model, this.view);
+			trans.addCallback(bind(function(html) {
+				this.destination.innerHTML = html;
+			}, this.view));
+			trans.addCallback(bind(function() {
+				MochiKit.Signal.signal(this, &quot;onrendercomplete&quot;, this.destination)
+			}, this.view));
+			trans.addCallback(this.deferred.callback);
+			trans.addErrback(this.deferred.errback);
+		} catch (ex) {
+			this.deferred.errback(ex);
+		}
+	}
+
+	var d = new MochiKit.Async.Deferred();
 	try {
 		var id = (typeof(placeholder) == &quot;undefined&quot;) ? this.placeholder : placeholder;
 		this.destination = $(id);
 		// @todo    Is this a good idea ?
 		// Perhaps we should leave it to the programmer to do this.
 		this.destination.innerHTML = Freja.AssetManager.THROBBER_HTML;
+
+		var h = new Handler(model, this, d);
+		h.trigger();
+/*
 		if (!this.ready) {
 			connect(this, &quot;onload&quot;, bind(this.render, this, model));
 			return;
@@ -389,17 +428,22 @@
 		if (!model) {
 			model = { document : (new DOMParser()).parseFromString(&quot;&lt;?xml version='1.0' ?&gt;&lt;dummy/&gt;&quot;, &quot;text/xml&quot;)};
 		}
-		var d = this.renderer.transform(model, this);
-		d.addCallback(bind(function(html) {
+		var trans = this.renderer.transform(model, this);
+		trans.addCallback(bind(function(html) {
 			this.destination.innerHTML = html;
 		}, this));
-		d.addCallback(bind(function() {
+		trans.addCallback(bind(function() {
 			MochiKit.Signal.signal(this, &quot;onrendercomplete&quot;, this.destination)
 		}, this));
+		trans.addCallback(d.callback);
+		trans.addErrback(d.errback);
+*/
 	} catch (ex) {
-		alert(ex.message);
+		d.errback(ex);
 	}
+	return d;
 }
+
 /**
   * Decorates the output of the primary renderer, to inject behaviour.
   * @note Maybe we could use cssQuery (<A HREF="http://dean.edwards.name/my/cssQuery/">http://dean.edwards.name/my/cssQuery/</A>)
@@ -470,19 +514,23 @@
   */
 Freja.View.Renderer.XSLTransformer.prototype.transform = function(model, view) {
         var d = new MochiKit.Async.Deferred();
-	var processor = new XSLTProcessor();
-	processor.importStylesheet(view.document);
-	var result = processor.transformToDocument(model.document);
-	var html = Sarissa.serialize(result);
-	if (!html) {
-		d.errback(new Error(&quot;XSL Transformation error.&quot;));
-	} else {
-		// fix empty textareas
-		// Can't this be fixed by outputting as html rather than xml ?
-		// &lt;xsl:output method=&quot;html&quot; /&gt;
-		html = html.replace(/&lt;textarea([^\/&gt;]*)\/&gt;/gi,&quot;&lt;textarea $1&gt;&lt;/textarea&gt;&quot;);
+        try {
+		var processor = new XSLTProcessor();
+		processor.importStylesheet(view.document);
+		var result = processor.transformToDocument(model.document);
+		var html = Sarissa.serialize(result);
+		if (!html) {
+			d.errback(new Error(&quot;XSL Transformation error.&quot;));
+		} else {
+			// fix empty textareas
+			// Can't this be fixed by outputting as html rather than xml ?
+			// &lt;xsl:output method=&quot;html&quot; /&gt;
+			html = html.replace(/&lt;textarea([^\/&gt;]*)\/&gt;/gi,&quot;&lt;textarea $1&gt;&lt;/textarea&gt;&quot;);
+			d.callback(html);
+		}
+	} catch (ex) {
+		d.errback(ex);
 	}
-	d.callback(html);
 	return d;
 }
 /**
@@ -515,14 +563,14 @@
 			}
 		}
 	}
-	req.open(&quot;POST&quot;, Freja.AssetManager.XSLT_SERVICE_URL, true);
+	var async = Freja.AssetManager.HTTP_REQUEST_TYPE == &quot;async&quot;;
+	req.open(&quot;POST&quot;, Freja.AssetManager.XSLT_SERVICE_URL, async);
 	req.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
 	if (Freja.AssetManager.USERNAME &amp;&amp; Freja.AssetManager.PASSWORD) {
 		var auth = &quot;Basic &quot; + Freja.Base64.encode(Freja.AssetManager.USERNAME + &quot;:&quot; + Freja.AssetManager.PASSWORD);
 		req.setRequestHeader(&quot;Authorization&quot;, auth);
 	}
 	req.send(postedData);
-
 	return d;
 }
 /**
@@ -658,19 +706,31 @@
 	}
 	try {
 		var req = new XMLHttpRequest();
+		var async = Freja.AssetManager.HTTP_REQUEST_TYPE == &quot;async&quot;;
 		if (preventCaching &amp;&amp; Freja.AssetManager.HTTP_METHOD_TUNNEL) {
-			req.open(&quot;POST&quot;, url, Freja.AssetManager.HTTP_REQUEST_TYPE == &quot;async&quot;);
+			req.open(&quot;POST&quot;, url, async);
 			req.setRequestHeader(Freja.AssetManager.HTTP_METHOD_TUNNEL, &quot;GET&quot;);
 			req.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
 		} else {
-			req.open(&quot;GET&quot;, url, Freja.AssetManager.HTTP_REQUEST_TYPE == &quot;async&quot;);
+			req.open(&quot;GET&quot;, url, async);
 		}
 		if (Freja.AssetManager.USERNAME &amp;&amp; Freja.AssetManager.PASSWORD) {
 			var auth = &quot;Basic &quot; + Freja.Base64.encode(Freja.AssetManager.USERNAME + &quot;:&quot; + Freja.AssetManager.PASSWORD);
 			req.setRequestHeader(&quot;Authorization&quot;, auth);
 		}
-//		req.open(&quot;GET&quot;, url, this.HTTP_REQUEST_TYPE == &quot;async&quot;);
-		var comm = MochiKit.Async.sendXMLHttpRequest(req).addCallbacks(handler, bind(d.errback, d));
+		// This shouldn't be nescesary, but alas it is - firefox chokes
+		// It's probably due to an error in MochiKit, so the problem
+		// should be fixed there.
+		var comm = MochiKit.Async.sendXMLHttpRequest(req);
+		if (async) {
+			comm.addCallbacks(handler, bind(d.errback, d));
+		} else {
+			if (req.status == 200 || req.status == 304) {
+				handler(req);
+			} else {
+				d.errback(new Error(&quot;Request failed:&quot; + req.status));
+			}
+		}
 	} catch (ex) {
 		d.errback(ex);
 	}

Modified: trunk/lib/MochiKit.js
===================================================================
--- trunk/lib/MochiKit.js	2006-03-12 15:56:31 UTC (rev 9)
+++ trunk/lib/MochiKit.js	2006-03-19 01:41:45 UTC (rev 10)
@@ -1,7596 +1,4646 @@
-
 /***
 
-MochiKit.Base 1.3
+    MochiKit.MochiKit 1.3 : PACKED VERSION
 
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
+    THIS FILE IS AUTOMATICALLY GENERATED.  If creating patches, please
+    diff against the source tree, not this file.
 
-(c) 2005 Bob Ippolito.  All rights Reserved.
+    See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
 
+    (c) 2005 Bob Ippolito.  All rights Reserved.
+
 ***/
 
-if (typeof(dojo) != 'undefined') {
-    dojo.provide(&quot;MochiKit.Base&quot;);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Base&quot;);
 }
-
-if (typeof(MochiKit) == 'undefined') {
-    MochiKit = {};
+if(typeof (MochiKit)==&quot;undefined&quot;){
+MochiKit={};
 }
-if (typeof(MochiKit.Base) == 'undefined') {
-    MochiKit.Base = {};
+if(typeof (MochiKit.Base)==&quot;undefined&quot;){
+MochiKit.Base={};
 }
-
-MochiKit.Base.VERSION = &quot;1.3&quot;;
-MochiKit.Base.NAME = &quot;MochiKit.Base&quot;
-MochiKit.Base.update = function (self, obj/*, ... */) {
-    /***
-
-        Mutate an object by replacing its key:value pairs with those
-        from other object(s).  Key:value pairs from later objects will
-        overwrite those from earlier objects.
-
-        If null is given as the initial object, a new one will be created.
-
-        This mutates *and returns* the given object, be warned.
-
-        A version of this function that creates a new object is available
-        as merge(o1, o2, ...)
-
-    ***/
-    if (self == null) {
-        self = {};
-    }
-    for (var i = 1; i &lt; arguments.length; i++) {
-        var o = arguments[i];
-        if (typeof(o) != 'undefined' &amp;&amp; o != null) {
-            for (var k in o) {
-                self[k] = o[k];
-            }
-        }
-    }
-    return self;
+MochiKit.Base.VERSION=&quot;1.3&quot;;
+MochiKit.Base.NAME=&quot;MochiKit.Base&quot;;
+MochiKit.Base.update=function(_1,_2){
+if(_1==null){
+_1={};
+}
+for(var i=1;i&lt;arguments.length;i++){
+var o=arguments[i];
+if(typeof (o)!=&quot;undefined&quot;&amp;&amp;o!=null){
+for(var k in o){
+_1[k]=o[k];
+}
+}
+}
+return _1;
 };
-
-MochiKit.Base.update(MochiKit.Base, {
-    __repr__: function () {
-        return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
-    },
-
-    toString: function () {
-        return this.__repr__();
-    },
-
-    counter: function (n/* = 1 */) {
-        if (arguments.length == 0) {
-            n = 1;
-        }
-        return function () {
-            return n++;
-        };
-    },
-
-    clone: function (obj) {
-        var me = arguments.callee;
-        if (arguments.length == 1) {
-            me.prototype = obj;
-            return new me();
-        }
-    },
-
-    extend: function (self, obj, /* optional */skip) {
-        /***
-
-            Mutate an array by extending it with an array-like obj,
-            starting with the &quot;skip&quot; index of obj.  If null is given
-            as the initial array, a new one will be created.
-
-            This mutates *and returns* the given array, be warned.
-
-        ***/
-
-        // Extend an array with an array-like object starting
-        // from the skip index
-        if (!skip) {
-            skip = 0;
-        }
-        if (obj) {
-            // allow iterable fall-through, but skip the full isArrayLike
-            // check for speed, this is called often.
-            var l = obj.length;
-            if (typeof(l) != 'number' /* !isArrayLike(obj) */) {
-                if (typeof(MochiKit.Iter) != &quot;undefined&quot;) {
-                    obj = MochiKit.Iter.list(obj);
-                    l = obj.length;
-                } else {
-                    throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
-                }
-            }
-            if (!self) {
-                self = [];
-            }
-            for (var i = skip; i &lt; l; i++) {
-                self.push(obj[i]);
-            }
-        }
-        // This mutates, but it's convenient to return because
-        // it's often used like a constructor when turning some
-        // ghetto array-like to a real array
-        return self;
-    },
-
-
-    updatetree: function (self, obj/*, ...*/) {
-        if (self == null) {
-            self = {};
-        }
-        for (var i = 1; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            if (typeof(o) != 'undefined' &amp;&amp; o != null) {
-                for (var k in o) {
-                    var v = o[k];
-                    if (typeof(self[k]) == 'object' &amp;&amp; typeof(v) == 'object') {
-                        arguments.callee(self[k], v);
-                    } else {
-                        self[k] = v;
-                    }
-                }
-            }
-        }
-        return self;
-    },
-
-    setdefault: function (self, obj/*, ...*/) {
-        /***
-
-            Mutate an object by replacing its key:value pairs with those
-            from other object(s) IF they are not already set on the initial
-            object.
-
-            If null is given as the initial object, a new one will be created.
-
-            This mutates *and returns* the given object, be warned.
-
-        ***/
-        if (self == null) {
-            self = {};
-        }
-        for (var i = 1; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            for (var k in o) {
-                if (!(k in self)) {
-                    self[k] = o[k];
-                }
-            }
-        }
-        return self;
-    },
-
-    keys: function (obj) {
-        /***
-
-            Return an array of the property names of an object
-            (in no particular order).
-
-        ***/
-        var rval = [];
-        for (var prop in obj) {
-            rval.push(prop);
-        }
-        return rval;
-    },
-
-    items: function (obj) {
-        /***
-
-            Return an array of [propertyName, propertyValue] pairs for an
-            object (in no particular order).
-
-        ***/
-        var rval = [];
-        var e;
-        for (var prop in obj) {
-            var v;
-            try {
-                v = obj[prop];
-            } catch (e) {
-                continue;
-            }
-            rval.push([prop, v]);
-        }
-        return rval;
-    },
-
-
-    _newNamedError: function (module, name, func) {
-        func.prototype = new MochiKit.Base.NamedError(module.NAME + &quot;.&quot; + name);
-        module[name] = func;
-    },
-
-
-    operator: {
-        /***
-
-            A table of JavaScript's operators for usage with map, filter, etc.
-
-        ***/
-
-        // unary logic operators
-        truth: function (a) { return !!a; },
-        lognot: function (a) { return !a; },
-        identity: function (a) { return a; },
-
-        // bitwise unary operators
-        not: function (a) { return ~a; },
-        neg: function (a) { return -a; },
-
-        // binary operators
-        add: function (a, b) { return a + b; },
-        sub: function (a, b) { return a - b; },
-        div: function (a, b) { return a / b; },
-        mod: function (a, b) { return a % b; },
-        mul: function (a, b) { return a * b; },
-
-        // bitwise binary operators
-        and: function (a, b) { return a &amp; b; },
-        or: function (a, b) { return a | b; },
-        xor: function (a, b) { return a ^ b; },
-        lshift: function (a, b) { return a &lt;&lt; b; },
-        rshift: function (a, b) { return a &gt;&gt; b; },
-        zrshift: function (a, b) { return a &gt;&gt;&gt; b; },
-
-        // near-worthless built-in comparators
-        eq: function (a, b) { return a == b; },
-        ne: function (a, b) { return a != b; },
-        gt: function (a, b) { return a &gt; b; },
-        ge: function (a, b) { return a &gt;= b; },
-        lt: function (a, b) { return a &lt; b; },
-        le: function (a, b) { return a &lt;= b; },
-
-        // compare comparators
-        ceq: function (a, b) { return MochiKit.Base.compare(a, b) == 0; },
-        cne: function (a, b) { return MochiKit.Base.compare(a, b) != 0; },
-        cgt: function (a, b) { return MochiKit.Base.compare(a, b) == 1; },
-        cge: function (a, b) { return MochiKit.Base.compare(a, b) != -1; },
-        clt: function (a, b) { return MochiKit.Base.compare(a, b) == -1; },
-        cle: function (a, b) { return MochiKit.Base.compare(a, b) != 1; },
-
-        // binary logical operators
-        logand: function (a, b) { return a &amp;&amp; b; },
-        logor: function (a, b) { return a || b; },
-        contains: function (a, b) { return b in a; }
-    },
-
-    forward: function (func) {
-        /***
-
-        Returns a function that forwards a method call to this.func(...)
-
-        ***/
-        return function () {
-            return this[func].apply(this, arguments);
-        };
-    },
-
-    itemgetter: function (func) {
-        /***
-
-        Returns a function that returns arg[func]
-
-        ***/
-        return function (arg) {
-            return arg[func];
-        };
-    },
-
-    typeMatcher: function (/* typ */) {
-        /***
-
-        Given a set of types (as string arguments),
-        returns a function that will return true if the types of the given
-        objects are members of that set.
-
-        ***/
-
-        var types = {};
-        for (var i = 0; i &lt; arguments.length; i++) {
-            var typ = arguments[i];
-            types[typ] = typ;
-        }
-        return function () {
-            for (var i = 0; i &lt; arguments.length; i++) {
-                if (!(typeof(arguments[i]) in types)) {
-                    return false;
-                }
-            }
-            return true;
-        };
-    },
-
-    isNull: function (/* ... */) {
-        /***
-
-        Returns true if all arguments are null.
-
-        ***/
-        for (var i = 0; i &lt; arguments.length; i++) {
-            if (arguments[i] !== null) {
-                return false;
-            }
-        }
-        return true;
-    },
-
-    isUndefinedOrNull: function (/* ... */) {
-        /***
-
-            Returns true if all arguments are undefined or null
-
-        ***/
-        for (var i = 0; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            if (!(typeof(o) == 'undefined' || o == null)) {
-                return false;
-            }
-        }
-        return true;
-    },
-
-    isNotEmpty: function (obj) {
-        /***
-
-            Returns true if all the array or string arguments
-            are not empty
-
-        ***/
-        for (var i = 0; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            if (!(o &amp;&amp; o.length)) {
-                return false;
-            }
-        }
-        return true;
-    },
-
-    isArrayLike: function () {
-        /***
-
-            Returns true if all given arguments are Array-like
-
-        ***/
-        for (var i = 0; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            var typ = typeof(o);
-            if (
-                (typ != 'object' &amp;&amp; !(typ == 'function' &amp;&amp; typeof(o.item) == 'function')) ||
-                o == null ||
-                typeof(o.length) != 'number'
-            ) {
-                return false;
-            }
-        }
-        return true;
-    },
-
-    isDateLike: function () {
-        /***
-
-            Returns true if all given arguments are Date-like
-
-        ***/
-        for (var i = 0; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            if (typeof(o) != &quot;object&quot; || o == null
-                    || typeof(o.getTime) != 'function') {
-                return false;
-            }
-        }
-        return true;
-    },
-
-
-    xmap: function (fn/*, obj... */) {
-        /***
-
-            Return an array composed of fn(obj) for every obj given as an
-            argument.
-
-            If fn is null, operator.identity is used.
-
-        ***/
-        if (fn == null) {
-            return MochiKit.Base.extend(null, arguments, 1);
-        }
-        var rval = [];
-        for (var i = 1; i &lt; arguments.length; i++) {
-            rval.push(fn(arguments[i]));
-        }
-        return rval;
-    },
-
-    map: function (fn, lst/*, lst... */) {
-        /***
-
-            Return a new array composed of the results of fn(x) for every x in
-            lst
-
-            If fn is null, and only one sequence argument is given the identity
-            function is used.
-
-                map(null, lst) -&gt; lst.slice();
-
-            If fn is null, and more than one sequence is given as arguments,
-            then the Array function is used, making it equivalent to zip.
-
-                map(null, p, q, ...)
-                    -&gt; zip(p, q, ...)
-                    -&gt; [[p0, q0, ...], [p1, q1, ...], ...];
-
-        ***/
-        var m = MochiKit.Base;
-        var isArrayLike = m.isArrayLike;
-        if (arguments.length &lt;= 2) {
-            // allow an iterable to be passed
-            if (!isArrayLike(lst)) {
-                if (MochiKit.Iter) {
-                    // fast path for map(null, iterable)
-                    lst = MochiKit.Iter.list(lst);
-                    if (fn == null) {
-                        return lst;
-                    }
-                } else {
-                    throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
-                }
-            }
-            // fast path for map(null, lst)
-            if (fn == null) {
-                return m.extend(null, lst);
-            }
-            // disabled fast path for map(fn, lst)
-            /*
-            if (false &amp;&amp; typeof(Array.prototype.map) == 'function') {
-                // Mozilla fast-path
-                return Array.prototype.map.call(lst, fn);
-            }
-            */
-            var rval = [];
-            for (var i = 0; i &lt; lst.length; i++) {
-                rval.push(fn(lst[i]));
-            }
-            return rval;
-        } else {
-            // default for map(null, ...) is zip(...)
-            if (fn == null) {
-                fn = Array;
-            }
-            var length = null;
-            for (i = 1; i &lt; arguments.length; i++) {
-                // allow iterables to be passed
-                if (!isArrayLike(arguments[i])) {
-                    if (MochiKit.Iter) {
-                        arguments[i] = MochiKit.Iter.list(arguments[i]);
-                    } else {
-                        throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
-                    }
-                }
-                // find the minimum length
-                var l = arguments[i].length;
-                if (length == null || length &gt; l) {
-                    length = l;
-                }
-            }
-            rval = [];
-            for (i = 0; i &lt; length; i++) {
-                var args = [];
-                for (var j = 1; j &lt; arguments.length; j++) {
-                    args.push(arguments[j][i]);
-                }
-                rval.push(fn.apply(this, args));
-            }
-            return rval;
-        }
-    },
-
-    xfilter: function (fn/*, obj... */) {
-        var rval = [];
-        if (fn == null) {
-            fn = MochiKit.Base.operator.truth;
-        }
-        for (var i = 1; i &lt; arguments.length; i++) {
-            var o = arguments[i];
-            if (fn(o)) {
-                rval.push(o);
-            }
-        }
-        return rval;
-    },
-
-    filter: function (fn, lst, self) {
-        var rval = [];
-        // allow an iterable to be passed
-        var m = MochiKit.Base;
-        if (!m.isArrayLike(lst)) {
-            if (MochiKit.Iter) {
-                lst = MochiKit.Iter.list(lst);
-            } else {
-                throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
-            }
-        }
-        if (fn == null) {
-            fn = m.operator.truth;
-        }
-        if (typeof(Array.prototype.filter) == 'function') {
-            // Mozilla fast-path
-            return Array.prototype.filter.call(lst, fn, self);
-        } else if (typeof(self) == 'undefined' || self == null) {
-            for (var i = 0; i &lt; lst.length; i++) {
-                var o = lst[i];
-                if (fn(o)) {
-                    rval.push(o);
-                }
-            }
-        } else {
-            for (i = 0; i &lt; lst.length; i++) {
-                o = lst[i];
-                if (fn.call(self, o)) {
-                    rval.push(o);
-                }
-            }
-        }
-        return rval;
-    },
-
-
-    _wrapDumbFunction: function (func) {
-        return function () {
-            // fast path!
-            switch (arguments.length) {
-                case 0: return func();
-                case 1: return func(arguments[0]);
-                case 2: return func(arguments[0], arguments[1]);
-                case 3: return func(arguments[0], arguments[1], arguments[2]);
-            }
-            var args = [];
-            for (var i = 0; i &lt; arguments.length; i++) {
-                args.push(&quot;arguments[&quot; + i + &quot;]&quot;);
-            }
-            return eval(&quot;(func(&quot; + args.join(&quot;,&quot;) + &quot;))&quot;);
-        };
-    },
-
-    bind: function (func, self/* args... */) {
-        if (typeof(func) == &quot;string&quot;) {
-            func = self[func];
-        }
-        var im_func = func.im_func;
-        var im_preargs = func.im_preargs;
-        var im_self = func.im_self;
-        var m = MochiKit.Base;
-        if (typeof(func) == &quot;function&quot; &amp;&amp; typeof(func.apply) == &quot;undefined&quot;) {
-            // this is for cases where JavaScript sucks ass and gives you a
-            // really dumb built-in function like alert() that doesn't have
-            // an apply
-            func = m._wrapDumbFunction(func);
-        }
-        if (typeof(im_func) != 'function') {
-            im_func = func;
-        }
-        if (typeof(self) != 'undefined') {
-            im_self = self;
-        }
-        if (typeof(im_preargs) == 'undefined') {
-            im_preargs = [];
-        } else  {
-            im_preargs = im_preargs.slice();
-        }
-        m.extend(im_preargs, arguments, 2);
-        var newfunc = function () {
-            var args = arguments;
-            var me = arguments.callee;
-            if (me.im_preargs.length &gt; 0) {
-                args = m.concat(me.im_preargs, args);
-            }
-            var self = me.im_self;
-            if (!self) {
-                self = this;
-            }
-            return me.im_func.apply(self, args);
-        };
-        newfunc.im_self = im_self;
-        newfunc.im_func = im_func;
-        newfunc.im_preargs = im_preargs;
-        return newfunc;
-    },
-
-    bindMethods: function (self) {
-        /***
-
-            Bind all functions in self to self,
-            which gives you a semi-Pythonic sort of instance.
-
-        ***/
-        var bind = MochiKit.Base.bind;
-        for (var k in self) {
-            var func = self[k];
-            if (typeof(func) == 'function') {
-                self[k] = bind(func, self);
-            }
-        }
-    },
-
-    registerComparator: function (name, check, comparator, /* optional */ override) {
-        /***
-
-            Register a comparator for use with the compare function.
-
-            name should be a unique identifier describing the comparator.
-
-            check is a function (a, b) that returns true if a and b
-            can be compared with comparator.
-
-            comparator is a function (a, b) that returns:
-
-                 0 when a == b
-                 1 when a &gt; b
-                -1 when a &lt; b
-
-            comparator is guaranteed to only be called if check(a, b)
-            returns a true value.
-
-            If override is given and true, then it will be made the
-            highest precedence comparator.  Otherwise, the lowest.
-
-        ***/
-        MochiKit.Base.comparatorRegistry.register(name, check, comparator, override);
-    },
-
-    _primitives: {'bool': true, 'string': true, 'number': true},
-
-    compare: function (a, b) {
-        /***
-
-            Compare two objects in a sensible manner.  Currently this is:
-
-                1. undefined and null compare equal to each other
-                2. undefined and null are less than anything else
-                3. comparators registered with registerComparator are
-                   used to find a good comparator.  Built-in comparators
-                   are currently available for arrays and dates.
-                4. Otherwise hope that the built-in comparison operators
-                   do something useful, which should work for numbers
-                   and strings.
-
-            Returns what one would expect from a comparison function.
-
-            returns:
-
-                 0 when a == b
-                 1 when a &gt; b
-                -1 when a &lt; b
-
-        ***/
-        if (a == b) {
-            return 0;
-        }
-        var aIsNull = (typeof(a) == 'undefined' || a == null);
-        var bIsNull = (typeof(b) == 'undefined' || b == null);
-        if (aIsNull &amp;&amp; bIsNull) {
-            return 0;
-        } else if (aIsNull) {
-            return -1;
-        } else if (bIsNull) {
-            return 1;
-        }
-        var m = MochiKit.Base;
-        // bool, number, string have meaningful comparisons
-        var prim = m._primitives;
-        if (!(typeof(a) in prim &amp;&amp; typeof(b) in prim)) {
-            try {
-                return m.comparatorRegistry.match(a, b);
-            } catch (e) {
-                if (e != m.NotFound) {
-                    throw e;
-                }
-            }
-        }
-        if (a &lt; b) {
-            return -1;
-        } else if (a &gt; b) {
-            return 1;
-        }
-        // These types can't be compared
-        var repr = m.repr;
-        throw new TypeError(repr(a) + &quot; and &quot; + repr(b) + &quot; can not be compared&quot;);
-    },
-
-    compareDateLike: function (a, b) {
-        return MochiKit.Base.compare(a.getTime(), b.getTime());
-    },
-
-    compareArrayLike: function (a, b) {
-        var compare = MochiKit.Base.compare;
-        var count = a.length;
-        var rval = 0;
-        if (count &gt; b.length) {
-            rval = 1;
-            count = b.length;
-        } else if (count &lt; b.length) {
-            rval = -1;
-        }
-        for (var i = 0; i &lt; count; i++) {
-            var cmp = compare(a[i], b[i]);
-            if (cmp) {
-                return cmp;
-            }
-        }
-        return rval;
-    },
-
-    registerRepr: function (name, check, wrap, /* optional */override) {
-        /***
-
-            Register a repr function.  repr functions should take
-            one argument and return a string representation of it
-            suitable for developers, primarily used when debugging.
-
-            If override is given, it is used as the highest priority
-            repr, otherwise it will be used as the lowest.
-
-        ***/
-        MochiKit.Base.reprRegistry.register(name, check, wrap, override);
-    },
-
-    repr: function (o) {
-        /***
-
-            Return a &quot;programmer representation&quot; for an object
-
-        ***/
-
-        if (typeof(o) == &quot;undefined&quot;) {
-            return &quot;undefined&quot;;
-        } else if (o === null) {
-            return &quot;null&quot;;
-        }
-        try {
-            if (typeof(o.__repr__) == 'function') {
-                return o.__repr__();
-            } else if (typeof(o.repr) == 'function' &amp;&amp; o.repr != arguments.callee) {
-                return o.repr();
-            }
-            return MochiKit.Base.reprRegistry.match(o);
-        } catch (e) {
-            if (typeof(o.NAME) == 'string' &amp;&amp; (
-                    o.toString == Function.prototype.toString ||
-                    o.toString == Object.prototype.toString
-                )) {
-                return o.NAME;
-            }
-        }
-        try {
-            var ostring = (o + &quot;&quot;);
-        } catch (e) {
-            return &quot;[&quot; + typeof(o) + &quot;]&quot;;
-        }
-        if (typeof(o) == &quot;function&quot;) {
-            o = ostring.replace(/^\s+/, &quot;&quot;);
-            var idx = o.indexOf(&quot;{&quot;);
-            if (idx != -1) {
-                o = o.substr(0, idx) + &quot;{...}&quot;;
-            }
-        }
-        return ostring;
-    },
-
-    reprArrayLike: function (o) {
-        var m = MochiKit.Base;
-        return &quot;[&quot; + m.map(m.repr, o).join(&quot;, &quot;) + &quot;]&quot;;
-    },
-
-    reprString: function (o) {
-        return ('&quot;' + o.replace(/([&quot;\\])/g, '\\$1') + '&quot;'
-            ).replace(/[\f]/g, &quot;\\f&quot;
-            ).replace(/[\b]/g, &quot;\\b&quot;
-            ).replace(/[\n]/g, &quot;\\n&quot;
-            ).replace(/[\t]/g, &quot;\\t&quot;
-            ).replace(/[\r]/g, &quot;\\r&quot;);
-    },
-
-    reprNumber: function (o) {
-        return o + &quot;&quot;;
-    },
-
-    registerJSON: function (name, check, wrap, /* optional */override) {
-        /***
-
-            Register a JSON serialization function.  JSON serialization
-            functions should take one argument and return an object
-            suitable for JSON serialization:
-
-            - string
-            - number
-            - boolean
-            - undefined
-            - object
-                - null
-                - Array-like (length property that is a number)
-                - Objects with a &quot;json&quot; method will have this method called
-                - Any other object will be used as {key:value, ...} pairs
-
-            If override is given, it is used as the highest priority
-            JSON serialization, otherwise it will be used as the lowest.
-
-        ***/
-        MochiKit.Base.jsonRegistry.register(name, check, wrap, override);
-    },
-
-
-    evalJSON: function () {
-        return eval(&quot;(&quot; + arguments[0] + &quot;)&quot;);
-    },
-
-    serializeJSON: function (o) {
-        /***
-
-            Create a JSON serialization of an object, note that this doesn't
-            check for infinite recursion, so don't do that!
-
-        ***/
-        var objtype = typeof(o);
-        if (objtype == &quot;undefined&quot;) {
-            return &quot;undefined&quot;;
-        } else if (objtype == &quot;number&quot; || objtype == &quot;boolean&quot;) {
-            return o + &quot;&quot;;
-        } else if (o === null) {
-            return &quot;null&quot;;
-        }
-        var m = MochiKit.Base;
-        var reprString = m.reprString;
-        if (objtype == &quot;string&quot;) {
-            return reprString(o);
-        }
-        // recurse
-        var me = arguments.callee;
-        // short-circuit for objects that support &quot;json&quot; serialization
-        // if they return &quot;self&quot; then just pass-through...
-        var newObj;
-        if (typeof(o.__json__) == &quot;function&quot;) {
-            newObj = o.__json__();
-            if (o !== newObj) {
-                return me(newObj);
-            }
-        }
-        if (typeof(o.json) == &quot;function&quot;) {
-            newObj = o.json();
-            if (o !== newObj) {
-                return me(newObj);
-            }
-        }
-        // array
-        if (objtype != &quot;function&quot; &amp;&amp; typeof(o.length) == &quot;number&quot;) {
-            var res = [];
-            for (var i = 0; i &lt; o.length; i++) {
-                var val = me(o[i]);
-                if (typeof(val) != &quot;string&quot;) {
-                    val = &quot;undefined&quot;;
-                }
-                res.push(val);
-            }
-            return &quot;[&quot; + res.join(&quot;, &quot;) + &quot;]&quot;;
-        }
-        // look in the registry
-        try {
-            newObj = m.jsonRegistry.match(o);
-            return me(newObj);
-        } catch (e) {
-            if (e != m.NotFound) {
-                // something really bad happened
-                throw e;
-            }
-        }
-        // it's a function with no adapter, bad
-        if (objtype == &quot;function&quot;) {
-            return null;
-        }
-        // generic object code path
-        res = [];
-        for (var k in o) {
-            var useKey;
-            if (typeof(k) == &quot;number&quot;) {
-                useKey = '&quot;' + k + '&quot;';
-            } else if (typeof(k) == &quot;string&quot;) {
-                useKey = reprString(k);
-            } else {
-                // skip non-string or number keys
-                continue;
-            }
-            val = me(o[k]);
-            if (typeof(val) != &quot;string&quot;) {
-                // skip non-serializable values
-                continue;
-            }
-            res.push(useKey + &quot;:&quot; + val);
-        }
-        return &quot;{&quot; + res.join(&quot;, &quot;) + &quot;}&quot;;
-    },
-
-
-    objEqual: function (a, b) {
-        /***
-
-            Compare the equality of two objects.
-
-        ***/
-        return (MochiKit.Base.compare(a, b) == 0);
-    },
-
-    arrayEqual: function (self, arr) {
-        /***
-
-            Compare two arrays for equality, with a fast-path for length
-            differences.
-
-        ***/
-        if (self.length != arr.length) {
-            return false;
-        }
-        return (MochiKit.Base.compare(self, arr) == 0);
-    },
-
-    concat: function (/* lst... */) {
-        /***
-
-            Concatenates all given array-like arguments and returns
-            a new array:
-
-                var lst = concat([&quot;1&quot;,&quot;3&quot;,&quot;5&quot;], [&quot;2&quot;,&quot;4&quot;,&quot;6&quot;]);
-                assert(lst.toString() == &quot;1,3,5,2,4,6&quot;);
-
-        ***/
-        var rval = [];
-        var extend = MochiKit.Base.extend;
-        for (var i = 0; i &lt; arguments.length; i++) {
-            extend(rval, arguments[i]);
-        }
-        return rval;
-    },
-
-    keyComparator: function (key/* ... */) {
-        /***
-
-            A comparator factory that compares a[key] with b[key].
-            e.g.:
-
-                var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
-                lst.sort(keyComparator(&quot;length&quot;));
-                assert(lst.toString() == &quot;a,cc,bbb&quot;);
-
-        ***/
-        // fast-path for single key comparisons
-        var m = MochiKit.Base;
-        var compare = m.compare;
-        if (arguments.length == 1) {
-            return function (a, b) {
-                return compare(a[key], b[key]);
-            }
-        }
-        var compareKeys = m.extend(null, arguments);
-        return function (a, b) {
-            var rval = 0;
-            // keep comparing until something is inequal or we run out of
-            // keys to compare
-            for (var i = 0; (rval == 0) &amp;&amp; (i &lt; compareKeys.length); i++) {
-                var key = compareKeys[i];
-                rval = compare(a[key], b[key]);
-            }
-            return rval;
-        };
-    },
-
-    reverseKeyComparator: function (key) {
-        /***
-
-            A comparator factory that compares a[key] with b[key] in reverse.
-            e.g.:
-
-                var lst = [&quot;a&quot;, &quot;bbb&quot;, &quot;cc&quot;];
-                lst.sort(reverseKeyComparator(&quot;length&quot;));
-                assert(lst.toString() == &quot;bbb,cc,aa&quot;);
-
-        ***/
-        var comparator = MochiKit.Base.keyComparator.apply(this, arguments);
-        return function (a, b) {
-            return comparator(b, a);
-        }
-    },
-
-    partial: function (func) {
-        var m = MochiKit.Base;
-        return m.bind.apply(this, m.extend([func, undefined], arguments, 1));
-    },
-
-    listMinMax: function (which, lst) {
-        /***
-
-            If which == -1 then it will return the smallest
-            element of the array-like lst.  This is also available
-            as:
-
-                listMin(lst)
-
-
-            If which == 1 then it will return the largest
-            element of the array-like lst.  This is also available
-            as:
-
-                listMax(list)
-
-        ***/
-        if (lst.length == 0) {
-            return null;
-        }
-        var cur = lst[0];
-        var compare = MochiKit.Base.compare;
-        for (var i = 1; i &lt; lst.length; i++) {
-            var o = lst[i];
-            if (compare(o, cur) == which) {
-                cur = o;
-            }
-        }
-        return cur;
-    },
-
-    objMax: function (/* obj... */) {
-        /***
-
-            Return the maximum object out of the given arguments
-
-        ***/
-        return MochiKit.Base.listMinMax(1, arguments);
-    },
-
-    objMin: function (/* obj... */) {
-        /***
-
-            Return the minimum object out of the given arguments
-
-        ***/
-        return MochiKit.Base.listMinMax(-1, arguments);
-    },
-
-    findIdentical: function (lst, value, start/* = 0 */, /* optional */end) {
-        if (typeof(end) == &quot;undefined&quot; || end == null) {
-            end = lst.length;
-        }
-        for (var i = (start || 0); i &lt; end; i++) {
-            if (lst[i] === value) {
-                return i;
-            }
-        }
-        return -1;
-    },
-
-    find: function (lst, value, start/* = 0 */, /* optional */end) {
-        if (typeof(end) == &quot;undefined&quot; || end == null) {
-            end = lst.length;
-        }
-        var cmp = MochiKit.Base.compare;
-        for (var i = (start || 0); i &lt; end; i++) {
-            if (cmp(lst[i], value) == 0) {
-                return i;
-            }
-        }
-        return -1;
-    },
-
-    nodeWalk: function (node, visitor) {
-        /***
-
-            Non-recursive generic node walking function (e.g. for a DOM)
-
-            @param node: The initial node to be searched.
-
-            @param visitor: The visitor function, will be called as
-                            visitor(node), and should return an Array-like
-                            of notes to be searched next (e.g.
-                            node.childNodes).
-
-        ***/
-        var nodes = [node];
-        var extend = MochiKit.Base.extend;
-        while (nodes.length) {
-            var res = visitor(nodes.shift());
-            if (res) {
-                extend(nodes, res);
-            }
-        }
-    },
-
-
-    nameFunctions: function (namespace) {
-        var base = namespace.NAME;
-        if (typeof(base) == 'undefined') {
-            base = '';
-        } else {
-            base = base + '.';
-        }
-        for (var name in namespace) {
-            var o = namespace[name];
-            if (typeof(o) == 'function' &amp;&amp; typeof(o.NAME) == 'undefined') {
-                try {
-                    o.NAME = base + name;
-                } catch (e) {
-                    // pass
-                }
-            }
-        }
-    },
-
-
-    queryString: function (names, values) {
-        // check to see if names is a string or a DOM element, and if
-        // MochiKit.DOM is available.  If so, drop it like it's a form
-        // Ugliest conditional in MochiKit?  Probably!
-        if (typeof(MochiKit.DOM) != &quot;undefined&quot; &amp;&amp; arguments.length == 1
-            &amp;&amp; (typeof(names) == &quot;string&quot; || (
-                typeof(names.nodeType) != &quot;undefined&quot; &amp;&amp; names.nodeType &gt; 0
-            ))
-        ) {
-            var kv = MochiKit.DOM.formContents(names);
-            names = kv[0];
-            values = kv[1];
-        } else if (arguments.length == 1) {
-            var o = names;
-            names = [];
-            values = [];
-            for (var k in o) {
-                var v = o[k];
-                if (typeof(v) != &quot;function&quot;) {
-                    names.push(k);
-                    values.push(v);
-                }
-            }
-        }
-        var rval = [];
-        var len = Math.min(names.length, values.length);
-        var urlEncode = MochiKit.Base.urlEncode;
-        for (var i = 0; i &lt; len; i++) {
-            v = values[i];
-            if (typeof(v) != 'undefined' &amp;&amp; v != null) {
-                rval.push(urlEncode(names[i]) + &quot;=&quot; + urlEncode(v));
-            }
-        }
-        return rval.join(&quot;&amp;&quot;);
-    },
-
-
-    parseQueryString: function (encodedString, useArrays) {
-        var pairs = encodedString.replace(/\+/g, &quot;%20&quot;).split(&quot;&amp;&quot;);
-        var o = {};
-        var decode;
-        if (typeof(decodeURIComponent) != &quot;undefined&quot;) {
-            decode = decodeURIComponent;
-        } else {
-            decode = unescape;
-        }
-        if (useArrays) {
-            for (var i = 0; i &lt; pairs.length; i++) {
-                var pair = pairs[i].split(&quot;=&quot;);
-                var name = decode(pair[0]);
-                var arr = o[name];
-                if (!(arr instanceof Array)) {
-                    arr = [];
-                    o[name] = arr;
-                }
-                arr.push(decode(pair[1]));
-            }
-        } else {
-            for (i = 0; i &lt; pairs.length; i++) {
-                pair = pairs[i].split(&quot;=&quot;);
-                o[decode(pair[0])] = decode(pair[1]);
-            }
-        }
-        return o;
-    }
-});
-
-MochiKit.Base.AdapterRegistry = function () {
-    /***
-
-        A registry to facilitate adaptation.
-
-        Pairs is an array of [name, check, wrap] triples
-
-        All check/wrap functions in this registry should be of the same arity.
-
-    ***/
-    this.pairs = [];
+MochiKit.Base.update(MochiKit.Base,{__repr__:function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
+},toString:function(){
+return this.__repr__();
+},counter:function(n){
+if(arguments.length==0){
+n=1;
+}
+return function(){
+return n++;
 };
-
-MochiKit.Base.AdapterRegistry.prototype = {
-    register: function (name, check, wrap, /* optional */ override) {
-        /***
-
-            The check function should return true if the given arguments are
-            appropriate for the wrap function.
-
-            If override is given and true, the check function will be given
-            highest priority.  Otherwise, it will be the lowest priority
-            adapter.
-
-        ***/
-
-        if (override) {
-            this.pairs.unshift([name, check, wrap]);
-        } else {
-            this.pairs.push([name, check, wrap]);
-        }
-    },
-
-    match: function (/* ... */) {
-        /***
-
-            Find an adapter for the given arguments.
-
-            If no suitable adapter is found, throws NotFound.
-
-        ***/
-        for (var i = 0; i &lt; this.pairs.length; i++) {
-            var pair = this.pairs[i];
-            if (pair[1].apply(this, arguments)) {
-                return pair[2].apply(this, arguments);
-            }
-        }
-        throw MochiKit.Base.NotFound;
-    },
-
-    unregister: function (name) {
-        /***
-
-            Remove a named adapter from the registry
-
-        ***/
-        for (var i = 0; i &lt; this.pairs.length; i++) {
-            var pair = this.pairs[i];
-            if (pair[0] == name) {
-                this.pairs.splice(i, 1);
-                return true;
-            }
-        }
-        return false;
-    }
+},clone:function(_7){
+var me=arguments.callee;
+if(arguments.length==1){
+me.prototype=_7;
+return new me();
+}
+},extend:function(_9,obj,_11){
+if(!_11){
+_11=0;
+}
+if(obj){
+var l=obj.length;
+if(typeof (l)!=&quot;number&quot;){
+if(typeof (MochiKit.Iter)!=&quot;undefined&quot;){
+obj=MochiKit.Iter.list(obj);
+l=obj.length;
+}else{
+throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
+}
+}
+if(!_9){
+_9=[];
+}
+for(var i=_11;i&lt;l;i++){
+_9.push(obj[i]);
+}
+}
+return _9;
+},updatetree:function(_13,obj){
+if(_13==null){
+_13={};
+}
+for(var i=1;i&lt;arguments.length;i++){
+var o=arguments[i];
+if(typeof (o)!=&quot;undefined&quot;&amp;&amp;o!=null){
+for(var k in o){
+var v=o[k];
+if(typeof (_13[k])==&quot;object&quot;&amp;&amp;typeof (v)==&quot;object&quot;){
+arguments.callee(_13[k],v);
+}else{
+_13[k]=v;
+}
+}
+}
+}
+return _13;
+},setdefault:function(_15,obj){
+if(_15==null){
+_15={};
+}
+for(var i=1;i&lt;arguments.length;i++){
+var o=arguments[i];
+for(var k in o){
+if(!(k in _15)){
+_15[k]=o[k];
+}
+}
+}
+return _15;
+},keys:function(obj){
+var _16=[];
+for(var _17 in obj){
+_16.push(_17);
+}
+return _16;
+},items:function(obj){
+var _18=[];
+var e;
+for(var _20 in obj){
+var v;
+try{
+v=obj[_20];
+}
+catch(e){
+continue;
+}
+_18.push([_20,v]);
+}
+return _18;
+},_newNamedError:function(_21,_22,_23){
+_23.prototype=new MochiKit.Base.NamedError(_21.NAME+&quot;.&quot;+_22);
+_21[_22]=_23;
+},operator:{truth:function(a){
+return !!a;
+},lognot:function(a){
+return !a;
+},identity:function(a){
+return a;
+},not:function(a){
+return ~a;
+},neg:function(a){
+return -a;
+},add:function(a,b){
+return a+b;
+},sub:function(a,b){
+return a-b;
+},div:function(a,b){
+return a/b;
+},mod:function(a,b){
+return a%b;
+},mul:function(a,b){
+return a*b;
+},and:function(a,b){
+return a&b;
+},or:function(a,b){
+return a|b;
+},xor:function(a,b){
+return a^b;
+},lshift:function(a,b){
+return a&lt;&lt;b;
+},rshift:function(a,b){
+return a&gt;&gt;b;
+},zrshift:function(a,b){
+return a&gt;&gt;&gt;b;
+},eq:function(a,b){
+return a==b;
+},ne:function(a,b){
+return a!=b;
+},gt:function(a,b){
+return a&gt;b;
+},ge:function(a,b){
+return a&gt;=b;
+},lt:function(a,b){
+return a&lt;b;
+},le:function(a,b){
+return a&lt;=b;
+},ceq:function(a,b){
+return MochiKit.Base.compare(a,b)==0;
+},cne:function(a,b){
+return MochiKit.Base.compare(a,b)!=0;
+},cgt:function(a,b){
+return MochiKit.Base.compare(a,b)==1;
+},cge:function(a,b){
+return MochiKit.Base.compare(a,b)!=-1;
+},clt:function(a,b){
+return MochiKit.Base.compare(a,b)==-1;
+},cle:function(a,b){
+return MochiKit.Base.compare(a,b)!=1;
+},logand:function(a,b){
+return a&amp;&b;
+},logor:function(a,b){
+return a||b;
+},contains:function(a,b){
+return b in a;
+}},forward:function(_26){
+return function(){
+return this[_26].apply(this,arguments);
 };
-
-
-MochiKit.Base.EXPORT = [
-    &quot;counter&quot;,
-    &quot;clone&quot;,
-    &quot;extend&quot;,
-    &quot;update&quot;,
-    &quot;updatetree&quot;,
-    &quot;setdefault&quot;,
-    &quot;keys&quot;,
-    &quot;items&quot;,
-    &quot;NamedError&quot;,
-    &quot;operator&quot;,
-    &quot;forward&quot;,
-    &quot;itemgetter&quot;,
-    &quot;typeMatcher&quot;,
-    &quot;isCallable&quot;,
-    &quot;isUndefined&quot;,
-    &quot;isUndefinedOrNull&quot;,
-    &quot;isNull&quot;,
-    &quot;isNotEmpty&quot;,
-    &quot;isArrayLike&quot;,
-    &quot;isDateLike&quot;,
-    &quot;xmap&quot;,
-    &quot;map&quot;,
-    &quot;xfilter&quot;,
-    &quot;filter&quot;,
-    &quot;bind&quot;,
-    &quot;bindMethods&quot;,
-    &quot;NotFound&quot;,
-    &quot;AdapterRegistry&quot;,
-    &quot;registerComparator&quot;,
-    &quot;compare&quot;,
-    &quot;registerRepr&quot;,
-    &quot;repr&quot;,
-    &quot;objEqual&quot;,
-    &quot;arrayEqual&quot;,
-    &quot;concat&quot;,
-    &quot;keyComparator&quot;,
-    &quot;reverseKeyComparator&quot;,
-    &quot;partial&quot;,
-    &quot;merge&quot;,
-    &quot;listMinMax&quot;,
-    &quot;listMax&quot;,
-    &quot;listMin&quot;,
-    &quot;objMax&quot;,
-    &quot;objMin&quot;,
-    &quot;nodeWalk&quot;,
-    &quot;zip&quot;,
-    &quot;urlEncode&quot;,
-    &quot;queryString&quot;,
-    &quot;serializeJSON&quot;,
-    &quot;registerJSON&quot;,
-    &quot;evalJSON&quot;,
-    &quot;parseQueryString&quot;,
-    &quot;find&quot;,
-    &quot;findIdentical&quot;
-];
-
-MochiKit.Base.EXPORT_OK = [
-    &quot;nameFunctions&quot;,
-    &quot;comparatorRegistry&quot;,
-    &quot;reprRegistry&quot;,
-    &quot;jsonRegistry&quot;,
-    &quot;compareDateLike&quot;,
-    &quot;compareArrayLike&quot;,
-    &quot;reprArrayLike&quot;,
-    &quot;reprString&quot;,
-    &quot;reprNumber&quot;
-];
-
-MochiKit.Base._exportSymbols = function (globals, module) {
-    if (typeof(MochiKit.__export__) == &quot;undefined&quot;) {
-        MochiKit.__export__ = (MochiKit.__compat__  ||
-            (typeof(JSAN) == 'undefined' &amp;&amp; typeof(dojo) == 'undefined')
-        );
-    }
-    if (!MochiKit.__export__) {
-        return;
-    }
-    var all = module.EXPORT_TAGS[&quot;:all&quot;];
-    for (var i = 0; i &lt; all.length; i++) {
-        globals[all[i]] = module[all[i]];
-    }
+},itemgetter:function(_27){
+return function(arg){
+return arg[_27];
 };
-
-MochiKit.Base.__new__ = function () {
-    // A singleton raised when no suitable adapter is found
-    var m = this;
-    if (typeof(encodeURIComponent) != &quot;undefined&quot;) {
-        m.urlEncode = function (unencoded) {
-            return encodeURIComponent(unencoded).replace(/\'/g, '%27');
-        };
-    } else {
-        m.urlEncode = function (unencoded) {
-            return escape(unencoded
-                ).replace(/\+/g, '%2B'
-                ).replace(/\&quot;/g,'%22'
-                ).rval.replace(/\'/g, '%27');
-        };
-    }
-
-    m.NamedError = function (name) {
-        this.message = name;
-        this.name = name;
-    };
-    m.NamedError.prototype = new Error();
-    m.update(m.NamedError.prototype, {
-        repr: function () {
-            if (this.message &amp;&amp; this.message != this.name) {
-                return this.name + &quot;(&quot; + m.repr(this.message) + &quot;)&quot;;
-            } else {
-                return this.name + &quot;()&quot;;
-            }
-        },
-        toString: m.forward(&quot;repr&quot;)
-    });
-
-    m.NotFound = new m.NamedError(&quot;MochiKit.Base.NotFound&quot;);
-
-
-    m.listMax = m.partial(m.listMinMax, 1);
-    m.listMin = m.partial(m.listMinMax, -1);
-
-    m.isCallable = m.typeMatcher('function');
-    m.isUndefined = m.typeMatcher('undefined');
-
-    m.merge = m.partial(m.update, null);
-    m.zip = m.partial(m.map, null);
-
-    m.comparatorRegistry = new m.AdapterRegistry();
-    m.registerComparator(&quot;dateLike&quot;, m.isDateLike, m.compareDateLike);
-    m.registerComparator(&quot;arrayLike&quot;, m.isArrayLike, m.compareArrayLike);
-
-    m.reprRegistry = new m.AdapterRegistry();
-    m.registerRepr(&quot;arrayLike&quot;, m.isArrayLike, m.reprArrayLike);
-    m.registerRepr(&quot;string&quot;, m.typeMatcher(&quot;string&quot;), m.reprString);
-    m.registerRepr(&quot;numbers&quot;, m.typeMatcher(&quot;number&quot;, &quot;boolean&quot;), m.reprNumber);
-
-    m.jsonRegistry = new m.AdapterRegistry();
-
-    var all = m.concat(m.EXPORT, m.EXPORT_OK);
-    m.EXPORT_TAGS = {
-        &quot;:common&quot;: m.concat(m.EXPORT_OK),
-        &quot;:all&quot;: all
-    };
-
-    m.nameFunctions(this);
-
+},typeMatcher:function(){
+var _29={};
+for(var i=0;i&lt;arguments.length;i++){
+var typ=arguments[i];
+_29[typ]=typ;
+}
+return function(){
+for(var i=0;i&lt;arguments.length;i++){
+if(!(typeof (arguments[i]) in _29)){
+return false;
+}
+}
+return true;
 };
-
+},isNull:function(){
+for(var i=0;i&lt;arguments.length;i++){
+if(arguments[i]!==null){
+return false;
+}
+}
+return true;
+},isUndefinedOrNull:function(){
+for(var i=0;i&lt;arguments.length;i++){
+var o=arguments[i];
+if(!(typeof (o)==&quot;undefined&quot;||o==null)){
+return false;
+}
+}
+return true;
+},isNotEmpty:function(obj){
+for(var i=0;i&lt;arguments.length;i++){
+var o=arguments[i];
+if(!(o&amp;&amp;o.length)){
+return false;
+}
+}
+return true;
+},isArrayLike:function(){
+for(var i=0;i&lt;arguments.length;i++){
+var o=arguments[i];
+var typ=typeof (o);
+if((typ!=&quot;object&quot;&amp;&amp;!(typ==&quot;function&quot;&amp;&amp;typeof (o.item)==&quot;function&quot;))||o==null||typeof (o.length)!=&quot;number&quot;){
+return false;
+}
+}
+return true;
+},isDateLike:function(){
+for(var i=0;i&lt;arguments.length;i++){
+var o=arguments[i];
+if(typeof (o)!=&quot;object&quot;||o==null||typeof (o.getTime)!=&quot;function&quot;){
+return false;
+}
+}
+return true;
+},xmap:function(fn){
+if(fn==null){
+return MochiKit.Base.extend(null,arguments,1);
+}
+var _32=[];
+for(var i=1;i&lt;arguments.length;i++){
+_32.push(fn(arguments[i]));
+}
+return _32;
+},map:function(fn,lst){
+var m=MochiKit.Base;
+var _35=m.isArrayLike;
+if(arguments.length&lt;=2){
+if(!_35(lst)){
+if(MochiKit.Iter){
+lst=MochiKit.Iter.list(lst);
+if(fn==null){
+return lst;
+}
+}else{
+throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
+}
+}
+if(fn==null){
+return m.extend(null,lst);
+}
+var _36=[];
+for(var i=0;i&lt;lst.length;i++){
+_36.push(fn(lst[i]));
+}
+return _36;
+}else{
+if(fn==null){
+fn=Array;
+}
+var _37=null;
+for(i=1;i&lt;arguments.length;i++){
+if(!_35(arguments[i])){
+if(MochiKit.Iter){
+arguments[i]=MochiKit.Iter.list(arguments[i]);
+}else{
+throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
+}
+}
+var l=arguments[i].length;
+if(_37==null||_37&gt;l){
+_37=l;
+}
+}
+_36=[];
+for(i=0;i&lt;_37;i++){
+var _38=[];
+for(var j=1;j&lt;arguments.length;j++){
+_38.push(arguments[j][i]);
+}
+_36.push(fn.apply(this,_38));
+}
+return _36;
+}
+},xfilter:function(fn){
+var _40=[];
+if(fn==null){
+fn=MochiKit.Base.operator.truth;
+}
+for(var i=1;i&lt;arguments.length;i++){
+var o=arguments[i];
+if(fn(o)){
+_40.push(o);
+}
+}
+return _40;
+},filter:function(fn,lst,_41){
+var _42=[];
+var m=MochiKit.Base;
+if(!m.isArrayLike(lst)){
+if(MochiKit.Iter){
+lst=MochiKit.Iter.list(lst);
+}else{
+throw new TypeError(&quot;Argument not an array-like and MochiKit.Iter not present&quot;);
+}
+}
+if(fn==null){
+fn=m.operator.truth;
+}
+if(typeof (Array.prototype.filter)==&quot;function&quot;){
+return Array.prototype.filter.call(lst,fn,_41);
+}else{
+if(typeof (_41)==&quot;undefined&quot;||_41==null){
+for(var i=0;i&lt;lst.length;i++){
+var o=lst[i];
+if(fn(o)){
+_42.push(o);
+}
+}
+}else{
+for(i=0;i&lt;lst.length;i++){
+o=lst[i];
+if(fn.call(_41,o)){
+_42.push(o);
+}
+}
+}
+}
+return _42;
+},_wrapDumbFunction:function(_43){
+return function(){
+switch(arguments.length){
+case 0:
+return _43();
+case 1:
+return _43(arguments[0]);
+case 2:
+return _43(arguments[0],arguments[1]);
+case 3:
+return _43(arguments[0],arguments[1],arguments[2]);
+}
+var _44=[];
+for(var i=0;i&lt;arguments.length;i++){
+_44.push(&quot;arguments[&quot;+i+&quot;]&quot;);
+}
+return eval(&quot;(func(&quot;+_44.join(&quot;,&quot;)+&quot;))&quot;);
+};
+},bind:function(_45,_46){
+if(typeof (_45)==&quot;string&quot;){
+_45=_46[_45];
+}
+var _47=_45.im_func;
+var _48=_45.im_preargs;
+var _49=_45.im_self;
+var m=MochiKit.Base;
+if(typeof (_45)==&quot;function&quot;&amp;&amp;typeof (_45.apply)==&quot;undefined&quot;){
+_45=m._wrapDumbFunction(_45);
+}
+if(typeof (_47)!=&quot;function&quot;){
+_47=_45;
+}
+if(typeof (_46)!=&quot;undefined&quot;){
+_49=_46;
+}
+if(typeof (_48)==&quot;undefined&quot;){
+_48=[];
+}else{
+_48=_48.slice();
+}
+m.extend(_48,arguments,2);
+var _50=function(){
+var _51=arguments;
+var me=arguments.callee;
+if(me.im_preargs.length&gt;0){
+_51=m.concat(me.im_preargs,_51);
+}
+var _46=me.im_self;
+if(!_46){
+_46=this;
+}
+return me.im_func.apply(_46,_51);
+};
+_50.im_self=_49;
+_50.im_func=_47;
+_50.im_preargs=_48;
+return _50;
+},bindMethods:function(_52){
+var _53=MochiKit.Base.bind;
+for(var k in _52){
+var _54=_52[k];
+if(typeof (_54)==&quot;function&quot;){
+_52[k]=_53(_54,_52);
+}
+}
+},registerComparator:function(_55,_56,_57,_58){
+MochiKit.Base.comparatorRegistry.register(_55,_56,_57,_58);
+},_primitives:{&quot;bool&quot;:true,&quot;string&quot;:true,&quot;number&quot;:true},compare:function(a,b){
+if(a==b){
+return 0;
+}
+var _59=(typeof (a)==&quot;undefined&quot;||a==null);
+var _60=(typeof (b)==&quot;undefined&quot;||b==null);
+if(_59&amp;&amp;_60){
+return 0;
+}else{
+if(_59){
+return -1;
+}else{
+if(_60){
+return 1;
+}
+}
+}
+var m=MochiKit.Base;
+var _61=m._primitives;
+if(!(typeof (a) in _61&amp;&amp;typeof (b) in _61)){
+try{
+return m.comparatorRegistry.match(a,b);
+}
+catch(e){
+if(e!=m.NotFound){
+throw e;
+}
+}
+}
+if(a&lt;b){
+return -1;
+}else{
+if(a&gt;b){
+return 1;
+}
+}
+var _62=m.repr;
+throw new TypeError(_62(a)+&quot; and &quot;+_62(b)+&quot; can not be compared&quot;);
+},compareDateLike:function(a,b){
+return MochiKit.Base.compare(a.getTime(),b.getTime());
+},compareArrayLike:function(a,b){
+var _63=MochiKit.Base.compare;
+var _64=a.length;
+var _65=0;
+if(_64&gt;b.length){
+_65=1;
+_64=b.length;
+}else{
+if(_64&lt;b.length){
+_65=-1;
+}
+}
+for(var i=0;i&lt;_64;i++){
+var cmp=_63(a[i],b[i]);
+if(cmp){
+return cmp;
+}
+}
+return _65;
+},registerRepr:function(_67,_68,_69,_70){
+MochiKit.Base.reprRegistry.register(_67,_68,_69,_70);
+},repr:function(o){
+if(typeof (o)==&quot;undefined&quot;){
+return &quot;undefined&quot;;
+}else{
+if(o===null){
+return &quot;null&quot;;
+}
+}
+try{
+if(typeof (o.__repr__)==&quot;function&quot;){
+return o.__repr__();
+}else{
+if(typeof (o.repr)==&quot;function&quot;&amp;&amp;o.repr!=arguments.callee){
+return o.repr();
+}
+}
+return MochiKit.Base.reprRegistry.match(o);
+}
+catch(e){
+if(typeof (o.NAME)==&quot;string&quot;&amp;&amp;(o.toString==Function.prototype.toString||o.toString==Object.prototype.toString)){
+return o.NAME;
+}
+}
+try{
+var _71=(o+&quot;&quot;);
+}
+catch(e){
+return &quot;[&quot;+typeof (o)+&quot;]&quot;;
+}
+if(typeof (o)==&quot;function&quot;){
+o=_71.replace(/^\s+/,&quot;&quot;);
+var idx=o.indexOf(&quot;{&quot;);
+if(idx!=-1){
+o=o.substr(0,idx)+&quot;{...}&quot;;
+}
+}
+return _71;
+},reprArrayLike:function(o){
+var m=MochiKit.Base;
+return &quot;[&quot;+m.map(m.repr,o).join(&quot;, &quot;)+&quot;]&quot;;
+},reprString:function(o){
+return (&quot;\&quot;&quot;+o.replace(/([&quot;\\])/g,&quot;\\$1&quot;)+&quot;\&quot;&quot;).replace(/[\f]/g,&quot;\\f&quot;).replace(/[\b]/g,&quot;\\b&quot;).replace(/[\n]/g,&quot;\\n&quot;).replace(/[\t]/g,&quot;\\t&quot;).replace(/[\r]/g,&quot;\\r&quot;);
+},reprNumber:function(o){
+return o+&quot;&quot;;
+},registerJSON:function(_73,_74,_75,_76){
+MochiKit.Base.jsonRegistry.register(_73,_74,_75,_76);
+},evalJSON:function(){
+return eval(&quot;(&quot;+arguments[0]+&quot;)&quot;);
+},serializeJSON:function(o){
+var _77=typeof (o);
+if(_77==&quot;undefined&quot;){
+return &quot;undefined&quot;;
+}else{
+if(_77==&quot;number&quot;||_77==&quot;boolean&quot;){
+return o+&quot;&quot;;
+}else{
+if(o===null){
+return &quot;null&quot;;
+}
+}
+}
+var m=MochiKit.Base;
+var _78=m.reprString;
+if(_77==&quot;string&quot;){
+return _78(o);
+}
+var me=arguments.callee;
+var _79;
+if(typeof (o.__json__)==&quot;function&quot;){
+_79=o.__json__();
+if(o!==_79){
+return me(_79);
+}
+}
+if(typeof (o.json)==&quot;function&quot;){
+_79=o.json();
+if(o!==_79){
+return me(_79);
+}
+}
+if(_77!=&quot;function&quot;&amp;&amp;typeof (o.length)==&quot;number&quot;){
+var res=[];
+for(var i=0;i&lt;o.length;i++){
+var val=me(o[i]);
+if(typeof (val)!=&quot;string&quot;){
+val=&quot;undefined&quot;;
+}
+res.push(val);
+}
+return &quot;[&quot;+res.join(&quot;, &quot;)+&quot;]&quot;;
+}
+try{
+_79=m.jsonRegistry.match(o);
+return me(_79);
+}
+catch(e){
+if(e!=m.NotFound){
+throw e;
+}
+}
+if(_77==&quot;function&quot;){
+return null;
+}
+res=[];
+for(var k in o){
+var _82;
+if(typeof (k)==&quot;number&quot;){
+_82=&quot;\&quot;&quot;+k+&quot;\&quot;&quot;;
+}else{
+if(typeof (k)==&quot;string&quot;){
+_82=_78(k);
+}else{
+continue;
+}
+}
+val=me(o[k]);
+if(typeof (val)!=&quot;string&quot;){
+continue;
+}
+res.push(_82+&quot;:&quot;+val);
+}
+return &quot;{&quot;+res.join(&quot;, &quot;)+&quot;}&quot;;
+},objEqual:function(a,b){
+return (MochiKit.Base.compare(a,b)==0);
+},arrayEqual:function(_83,arr){
+if(_83.length!=arr.length){
+return false;
+}
+return (MochiKit.Base.compare(_83,arr)==0);
+},concat:function(){
+var _85=[];
+var _86=MochiKit.Base.extend;
+for(var i=0;i&lt;arguments.length;i++){
+_86(_85,arguments[i]);
+}
+return _85;
+},keyComparator:function(key){
+var m=MochiKit.Base;
+var _88=m.compare;
+if(arguments.length==1){
+return function(a,b){
+return _88(a[key],b[key]);
+};
+}
+var _89=m.extend(null,arguments);
+return function(a,b){
+var _90=0;
+for(var i=0;(_90==0)&amp;&amp;(i&lt;_89.length);i++){
+var key=_89[i];
+_90=_88(a[key],b[key]);
+}
+return _90;
+};
+},reverseKeyComparator:function(key){
+var _91=MochiKit.Base.keyComparator.apply(this,arguments);
+return function(a,b){
+return _91(b,a);
+};
+},partial:function(_92){
+var m=MochiKit.Base;
+return m.bind.apply(this,m.extend([_92,undefined],arguments,1));
+},listMinMax:function(_93,lst){
+if(lst.length==0){
+return null;
+}
+var cur=lst[0];
+var _95=MochiKit.Base.compare;
+for(var i=1;i&lt;lst.length;i++){
+var o=lst[i];
+if(_95(o,cur)==_93){
+cur=o;
+}
+}
+return cur;
+},objMax:function(){
+return MochiKit.Base.listMinMax(1,arguments);
+},objMin:function(){
+return MochiKit.Base.listMinMax(-1,arguments);
+},findIdentical:function(lst,_96,_97,end){
+if(typeof (end)==&quot;undefined&quot;||end==null){
+end=lst.length;
+}
+for(var i=(_97||0);i&lt;end;i++){
+if(lst[i]===_96){
+return i;
+}
+}
+return -1;
+},find:function(lst,_99,_100,end){
+if(typeof (end)==&quot;undefined&quot;||end==null){
+end=lst.length;
+}
+var cmp=MochiKit.Base.compare;
+for(var i=(_100||0);i&lt;end;i++){
+if(cmp(lst[i],_99)==0){
+return i;
+}
+}
+return -1;
+},nodeWalk:function(node,_102){
+var _103=[node];
+var _104=MochiKit.Base.extend;
+while(_103.length){
+var res=_102(_103.shift());
+if(res){
+_104(_103,res);
+}
+}
+},nameFunctions:function(_105){
+var base=_105.NAME;
+if(typeof (base)==&quot;undefined&quot;){
+base=&quot;&quot;;
+}else{
+base=base+&quot;.&quot;;
+}
+for(var name in _105){
+var o=_105[name];
+if(typeof (o)==&quot;function&quot;&amp;&amp;typeof (o.NAME)==&quot;undefined&quot;){
+try{
+o.NAME=base+name;
+}
+catch(e){
+}
+}
+}
+},queryString:function(_108,_109){
+if(typeof (MochiKit.DOM)!=&quot;undefined&quot;&amp;&amp;arguments.length==1&amp;&amp;(typeof (_108)==&quot;string&quot;||(typeof (_108.nodeType)!=&quot;undefined&quot;&amp;&amp;_108.nodeType&gt;0))){
+var kv=MochiKit.DOM.formContents(_108);
+_108=kv[0];
+_109=kv[1];
+}else{
+if(arguments.length==1){
+var o=_108;
+_108=[];
+_109=[];
+for(var k in o){
+var v=o[k];
+if(typeof (v)!=&quot;function&quot;){
+_108.push(k);
+_109.push(v);
+}
+}
+}
+}
+var rval=[];
+var len=Math.min(_108.length,_109.length);
+var _113=MochiKit.Base.urlEncode;
+for(var i=0;i&lt;len;i++){
+v=_109[i];
+if(typeof (v)!=&quot;undefined&quot;&amp;&amp;v!=null){
+rval.push(_113(_108[i])+&quot;=&quot;+_113(v));
+}
+}
+return rval.join(&quot;&amp;&quot;);
+},parseQueryString:function(_114,_115){
+var _116=_114.replace(/\+/g,&quot;%20&quot;).split(&quot;&amp;&quot;);
+var o={};
+var _117;
+if(typeof (decodeURIComponent)!=&quot;undefined&quot;){
+_117=decodeURIComponent;
+}else{
+_117=unescape;
+}
+if(_115){
+for(var i=0;i&lt;_116.length;i++){
+var pair=_116[i].split(&quot;=&quot;);
+var name=_117(pair[0]);
+var arr=o[name];
+if(!(arr instanceof Array)){
+arr=[];
+o[name]=arr;
+}
+arr.push(_117(pair[1]));
+}
+}else{
+for(i=0;i&lt;_116.length;i++){
+pair=_116[i].split(&quot;=&quot;);
+o[_117(pair[0])]=_117(pair[1]);
+}
+}
+return o;
+}});
+MochiKit.Base.AdapterRegistry=function(){
+this.pairs=[];
+};
+MochiKit.Base.AdapterRegistry.prototype={register:function(name,_119,wrap,_121){
+if(_121){
+this.pairs.unshift([name,_119,wrap]);
+}else{
+this.pairs.push([name,_119,wrap]);
+}
+},match:function(){
+for(var i=0;i&lt;this.pairs.length;i++){
+var pair=this.pairs[i];
+if(pair[1].apply(this,arguments)){
+return pair[2].apply(this,arguments);
+}
+}
+throw MochiKit.Base.NotFound;
+},unregister:function(name){
+for(var i=0;i&lt;this.pairs.length;i++){
+var pair=this.pairs[i];
+if(pair[0]==name){
+this.pairs.splice(i,1);
+return true;
+}
+}
+return false;
+}};
+MochiKit.Base.EXPORT=[&quot;counter&quot;,&quot;clone&quot;,&quot;extend&quot;,&quot;update&quot;,&quot;updatetree&quot;,&quot;setdefault&quot;,&quot;keys&quot;,&quot;items&quot;,&quot;NamedError&quot;,&quot;operator&quot;,&quot;forward&quot;,&quot;itemgetter&quot;,&quot;typeMatcher&quot;,&quot;isCallable&quot;,&quot;isUndefined&quot;,&quot;isUndefinedOrNull&quot;,&quot;isNull&quot;,&quot;isNotEmpty&quot;,&quot;isArrayLike&quot;,&quot;isDateLike&quot;,&quot;xmap&quot;,&quot;map&quot;,&quot;xfilter&quot;,&quot;filter&quot;,&quot;bind&quot;,&quot;bindMethods&quot;,&quot;NotFound&quot;,&quot;AdapterRegistry&quot;,&quot;registerComparator&quot;,&quot;compare&quot;,&quot;registerRepr&quot;,&quot;repr&quot;,&quot;objEqual&quot;,&quot;arrayEqual&quot;,&quot;concat&quot;,&quot;keyComparator&quot;,&quot;reverseKeyComparator&quot;,&quot;partial&quot;,&quot;merge&quot;,&quot;listMinMax&quot;,&quot;listMax&quot;,&quot;listMin&quot;,&quot;objMax&quot;,&quot;objMin&quot;,&quot;nodeWalk&quot;,&quot;zip&quot;,&quot;urlEncode&quot;,&quot;queryString&quot;,&quot;serializeJSON&quot;,&quot;registerJSON&quot;,&quot;evalJSON&quot;,&quot;parseQueryString&quot;,&quot;find&quot;,&quot;findIdentical&quot;];
+MochiKit.Base.EXPORT_OK=[&quot;nameFunctions&quot;,&quot;comparatorRegistry&quot;,&quot;reprRegistry&quot;,&quot;jsonRegistry&quot;,&quot;compareDateLike&quot;,&quot;compareArrayLike&quot;,&quot;reprArrayLike&quot;,&quot;reprString&quot;,&quot;reprNumber&quot;];
+MochiKit.Base._exportSymbols=function(_122,_123){
+if(typeof (MochiKit.__export__)==&quot;undefined&quot;){
+MochiKit.__export__=(MochiKit.__compat__||(typeof (JSAN)==&quot;undefined&quot;&amp;&amp;typeof (dojo)==&quot;undefined&quot;));
+}
+if(!MochiKit.__export__){
+return;
+}
+var all=_123.EXPORT_TAGS[&quot;:all&quot;];
+for(var i=0;i&lt;all.length;i++){
+_122[all[i]]=_123[all[i]];
+}
+};
+MochiKit.Base.__new__=function(){
+var m=this;
+if(typeof (encodeURIComponent)!=&quot;undefined&quot;){
+m.urlEncode=function(_125){
+return encodeURIComponent(_125).replace(/\'/g,&quot;%27&quot;);
+};
+}else{
+m.urlEncode=function(_126){
+return escape(_126).replace(/\+/g,&quot;%2B&quot;).replace(/\&quot;/g,&quot;%22&quot;).rval.replace(/\'/g,&quot;%27&quot;);
+};
+}
+m.NamedError=function(name){
+this.message=name;
+this.name=name;
+};
+m.NamedError.prototype=new Error();
+m.update(m.NamedError.prototype,{repr:function(){
+if(this.message&amp;&amp;this.message!=this.name){
+return this.name+&quot;(&quot;+m.repr(this.message)+&quot;)&quot;;
+}else{
+return this.name+&quot;()&quot;;
+}
+},toString:m.forward(&quot;repr&quot;)});
+m.NotFound=new m.NamedError(&quot;MochiKit.Base.NotFound&quot;);
+m.listMax=m.partial(m.listMinMax,1);
+m.listMin=m.partial(m.listMinMax,-1);
+m.isCallable=m.typeMatcher(&quot;function&quot;);
+m.isUndefined=m.typeMatcher(&quot;undefined&quot;);
+m.merge=m.partial(m.update,null);
+m.zip=m.partial(m.map,null);
+m.comparatorRegistry=new m.AdapterRegistry();
+m.registerComparator(&quot;dateLike&quot;,m.isDateLike,m.compareDateLike);
+m.registerComparator(&quot;arrayLike&quot;,m.isArrayLike,m.compareArrayLike);
+m.reprRegistry=new m.AdapterRegistry();
+m.registerRepr(&quot;arrayLike&quot;,m.isArrayLike,m.reprArrayLike);
+m.registerRepr(&quot;string&quot;,m.typeMatcher(&quot;string&quot;),m.reprString);
+m.registerRepr(&quot;numbers&quot;,m.typeMatcher(&quot;number&quot;,&quot;boolean&quot;),m.reprNumber);
+m.jsonRegistry=new m.AdapterRegistry();
+var all=m.concat(m.EXPORT,m.EXPORT_OK);
+m.EXPORT_TAGS={&quot;:common&quot;:m.concat(m.EXPORT_OK),&quot;:all&quot;:all};
+m.nameFunctions(this);
+};
 MochiKit.Base.__new__();
-
-//
-// XXX: Internet Explorer blows
-//
-compare = MochiKit.Base.compare;
-
-MochiKit.Base._exportSymbols(this, MochiKit.Base);
-
-/***
-
-MochiKit.Iter 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.Iter');
-    dojo.require('MochiKit.Base');
+compare=MochiKit.Base.compare;
+MochiKit.Base._exportSymbols(this,MochiKit.Base);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Iter&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
 }
-
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Base&quot;, []);
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
 }
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.Iter depends on MochiKit.Base!&quot;;
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;){
+throw &quot;&quot;;
 }
-
-if (typeof(MochiKit.Iter) == 'undefined') {
-    MochiKit.Iter = {};
 }
-
-MochiKit.Iter.NAME = &quot;MochiKit.Iter&quot;;
-MochiKit.Iter.VERSION = &quot;1.3&quot;;
-MochiKit.Base.update(MochiKit.Iter, {
-    __repr__: function () {
-        return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
-    },
-    toString: function () {
-        return this.__repr__();
-    },
-
-    registerIteratorFactory: function (name, check, iterfactory, /* optional */ override) {
-        /***
-
-            Register an iterator factory for use with the iter function.
-
-            check is a function (a) that returns true if a can be converted
-            into an iterator with iterfactory.
-
-            iterfactory is a function (a) that returns an object with a
-            &quot;next&quot; function that returns the next value in the sequence.
-
-            iterfactory is guaranteed to only be called if check(a)
-            returns a true value.
-
-            If override is given and true, then it will be made the
-            highest precedence iterator factory.  Otherwise, the lowest.
-
-        ***/
-
-        MochiKit.Iter.iteratorRegistry.register(name, check, iterfactory, override);
-    },
-
-    iter: function (iterable, /* optional */ sentinel) {
-        /***
-
-            Convert the given argument to an iterator (object implementing
-            &quot;next&quot;).
-
-            1. If iterable is an iterator (implements &quot;next&quot;), then it will be
-               returned as-is.
-            2. If iterable is an iterator factory (implements &quot;iter&quot;), then the
-               result of iterable.iter() will be returned.
-            3. Otherwise, the iterator factory registry is used to find a
-               match.
-            4. If no factory is found, it will throw TypeError
-
-            When used directly, using an iterator should look like this::
-
-                var it = iter(iterable);
-                try {
-                    while (var o = it.next()) {
-                        // use o
-                    }
-                } catch (e) {
-                    if (e != StopIteration) {
-                        throw e;
-                    }
-                    // pass
-                }
-
-        ***/
-
-        var self = MochiKit.Iter;
-        if (arguments.length == 2) {
-            return self.takewhile(
-                function (a) { return a != sentinel; },
-                iterable
-            );
-        }
-        if (typeof(iterable.next) == 'function') {
-            return iterable;
-        } else if (typeof(iterable.iter) == 'function') {
-            return iterable.iter();
-        }
-        try {
-            return self.iteratorRegistry.match(iterable);
-        } catch (e) {
-            var m = MochiKit.Base;
-            if (e == m.NotFound) {
-                e = new TypeError(typeof(iterable) + &quot;: &quot; + m.repr(iterable) + &quot; is not iterable&quot;);
-            }
-            throw e;
-        }
-    },
-
-    count: function (n) {
-        /***
-
-            count([n]) --&gt; n, n + 1, n + 2, ...
-
-        ***/
-        if (!n) {
-            n = 0;
-        }
-        var m = MochiKit.Base;
-        return {
-            repr: function () { return &quot;count(&quot; + n + &quot;)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: m.counter(n)
-        };
-    },
-
-    cycle: function (p) {
-        /***
-
-            cycle(p) --&gt; p0, p1, ... plast, p0, p1, ...
-
-        ***/
-        var self = MochiKit.Iter;
-        var m = MochiKit.Base;
-        var lst = [];
-        var iterator = self.iter(p);
-        return {
-            repr: function () { return &quot;cycle(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                try {
-                    var rval = iterator.next();
-                    lst.push(rval);
-                    return rval;
-                } catch (e) {
-                    if (e != self.StopIteration) {
-                        throw e;
-                    }
-                    if (lst.length == 0) {
-                        this.next = function () {
-                            throw self.StopIteration;
-                        };
-                    } else {
-                        var i = -1;
-                        this.next = function () {
-                            i = (i + 1) % lst.length;
-                            return lst[i];
-                        }
-                    }
-                    return this.next();
-                }
-            }
-        }
-    },
-
-    repeat: function (elem, /* optional */n) {
-        /***
-
-            repeat(elem, [,n]) --&gt; elem, elem, elem, ... endlessly or up to n
-                times
-
-        ***/
-        var m = MochiKit.Base;
-        if (typeof(n) == 'undefined') {
-            return {
-                repr: function () {
-                    return &quot;repeat(&quot; + m.repr(elem) + &quot;)&quot;;
-                },
-                toString: m.forward(&quot;repr&quot;),
-                next: function () {
-                    return elem;
-                }
-            };
-        }
-        return {
-            repr: function () {
-                return &quot;repeat(&quot; + m.repr(elem) + &quot;, &quot; + n + &quot;)&quot;;
-            },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                if (n &lt;= 0) {
-                    throw MochiKit.Iter.StopIteration;
-                }
-                n -= 1;
-                return elem;
-            }
-        };
-    },
-
-    next: function (iterator) {
-        /***
-
-            Return the next value from the iterator
-
-        ***/
-        return iterator.next();
-    },
-
-    izip: function (p, q/*, ...*/) {
-        /***
-
-            izip(p, q, ...) --&gt; (p0, q0, ...), (p1, q1, ...), ...
-
-        ***/
-        var m = MochiKit.Base;
-        var next = MochiKit.Iter.next;
-        var iterables = m.map(iter, arguments);
-        return {
-            repr: function () { return &quot;izip(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () { return m.map(next, iterables); }
-        };
-    },
-
-    ifilter: function (pred, seq) {
-        /***
-
-            ifilter(pred, seq) --&gt; elements of seq where pred(elem) is true
-
-        ***/
-        var m = MochiKit.Base;
-        seq = MochiKit.Iter.iter(seq);
-        if (pred == null) {
-            pred = m.operator.truth;
-        }
-        return {
-            repr: function () { return &quot;ifilter(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                while (true) {
-                    var rval = seq.next();
-                    if (pred(rval)) {
-                        return rval;
-                    }
-                }
-                // mozilla warnings aren't too bright
-                return undefined;
-            }
-        }
-    },
-
-    ifilterfalse: function (pred, seq) {
-        /***
-
-            ifilterfalse(pred, seq) --&gt; elements of seq where pred(elem) is
-                false
-
-        ***/
-        var m = MochiKit.Base;
-        seq = MochiKit.Iter.iter(seq);
-        if (pred == null) {
-            pred = m.operator.truth;
-        }
-        return {
-            repr: function () { return &quot;ifilterfalse(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                while (true) {
-                    var rval = seq.next();
-                    if (!pred(rval)) {
-                        return rval;
-                    }
-                }
-                // mozilla warnings aren't too bright
-                return undefined;
-            }
-        }
-    },
-
-    islice: function (seq/*, [start,] stop[, step] */) {
-        /***
-
-            islice(seq, [start,] stop[, step])  --&gt; elements from
-                seq[start:stop:step] (in Python slice syntax)
-
-        ***/
-        var self = MochiKit.Iter;
-        var m = MochiKit.Base;
-        seq = self.iter(seq);
-        var start = 0;
-        var stop = 0;
-        var step = 1;
-        var i = -1;
-        if (arguments.length == 2) {
-            stop = arguments[1];
-        } else if (arguments.length == 3) {
-            start = arguments[1];
-            stop = arguments[2];
-        } else {
-            start = arguments[1];
-            stop = arguments[2];
-            step = arguments[3];
-        }
-        return {
-            repr: function () {
-                return &quot;islice(&quot; + [&quot;...&quot;, start, stop, step].join(&quot;, &quot;) + &quot;)&quot;;
-            },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                var rval;
-                while (i &lt; start) {
-                    rval = seq.next();
-                    i++;
-                }
-                if (start &gt;= stop) {
-                    throw self.StopIteration;
-                }
-                start += step;
-                return rval;
-            }
-        };
-    },
-
-    imap: function (fun, p, q/*, ...*/) {
-        /***
-
-            imap(fun, p, q, ...) --&gt; fun(p0, q0, ...), fun(p1, q1, ...), ...
-
-        ***/
-        var m = MochiKit.Base;
-        var self = MochiKit.Iter;
-        var iterables = m.map(self.iter, m.extend(null, arguments, 1));
-        var map = m.map;
-        var next = self.next;
-        return {
-            repr: function () { return &quot;imap(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                return fun.apply(this, map(next, iterables));
-            }
-        };
-    },
-
-    applymap: function (fun, seq, self) {
-        /***
-
-            applymap(fun, seq) --&gt;
-                fun.apply(self, seq0), fun.apply(self, seq1), ...
-
-        ***/
-        seq = MochiKit.Iter.iter(seq);
-        var m = MochiKit.Base;
-        return {
-            repr: function () { return &quot;applymap(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                return fun.apply(self, seq.next());
-            }
-        };
-    },
-
-    chain: function (p, q/*, ...*/) {
-        /***
-
-            chain(p, q, ...) --&gt; p0, p1, ... plast, q0, q1, ...
-
-        ***/
-        // dumb fast path
-        var self = MochiKit.Iter;
-        var m = MochiKit.Base;
-        if (arguments.length == 1) {
-            return self.iter(arguments[0]);
-        }
-        var argiter = m.map(self.iter, arguments);
-        return {
-            repr: function () { return &quot;chain(...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                while (argiter.length &gt; 1) {
-                    try {
-                        return argiter[0].next();
-                    } catch (e) {
-                        if (e != self.StopIteration) {
-                            throw e;
-                        }
-                        argiter.shift();
-                    }
-                }
-                if (argiter.length == 1) {
-                    // optimize last element
-                    var arg = argiter.shift();
-                    this.next = m.bind(&quot;next&quot;, arg);
-                    return this.next();
-                }
-                throw self.StopIteration;
-            }
-        };
-    },
-
-    takewhile: function (pred, seq) {
-        /***
-
-            takewhile(pred, seq) --&gt; seq[0], seq[1], ... until pred(seq[n])
-                fails
-
-        ***/
-        var self = MochiKit.Iter;
-        seq = self.iter(seq);
-        return {
-            repr: function () { return &quot;takewhile(...)&quot;; },
-            toString: MochiKit.Base.forward(&quot;repr&quot;),
-            next: function () {
-                var rval = seq.next();
-                if (!pred(rval)) {
-                    this.next = function () {
-                        throw self.StopIteration;
-                    };
-                    this.next();
-                }
-                return rval;
-            }
-        };
-    },
-
-    dropwhile: function (pred, seq) {
-        /***
-
-            dropwhile(pred, seq) --&gt; seq[n], seq[n + 1], starting when
-                pred(seq[n]) fails
-
-        ***/
-        seq = MochiKit.Iter.iter(seq);
-        var m = MochiKit.Base;
-        var bind = m.bind;
-        return {
-            &quot;repr&quot;: function () { return &quot;dropwhile(...)&quot;; },
-            &quot;toString&quot;: m.forward(&quot;repr&quot;),
-            &quot;next&quot;: function () {
-                while (true) {
-                    var rval = seq.next();
-                    if (!pred(rval)) {
-                        break;
-                    }
-                }
-                this.next = bind(&quot;next&quot;, seq);
-                return rval;
-            }
-        };
-    },
-
-    _tee: function (ident, sync, iterable) {
-        sync.pos[ident] = -1;
-        var m = MochiKit.Base;
-        var listMin = m.listMin;
-        return {
-            repr: function () { return &quot;tee(&quot; + ident + &quot;, ...)&quot;; },
-            toString: m.forward(&quot;repr&quot;),
-            next: function () {
-                var rval;
-                var i = sync.pos[ident];
-
-                if (i == sync.max) {
-                    rval = iterable.next();
-                    sync.deque.push(rval);
-                    sync.max += 1;
-                    sync.pos[ident] += 1;
-                } else {
-                    rval = sync.deque[i - sync.min];
-                    sync.pos[ident] += 1;
-                    if (i == sync.min &amp;&amp; listMin(sync.pos) != sync.min) {
-                        sync.min += 1;
-                        sync.deque.shift();
-                    }
-                }
-                return rval;
-            }
-        };
-    },
-
-    tee: function (iterable, n/* = 2 */) {
-        /***
-
-            tee(it, n=2) --&gt; (it1, it2, it3, ... itn) splits one iterator
-                into n
-
-        ***/
-        var rval = [];
-        var sync = {
-            &quot;pos&quot;: [],
-            &quot;deque&quot;: [],
-            &quot;max&quot;: -1,
-            &quot;min&quot;: -1
-        };
-        if (arguments.length == 1) {
-            n = 2;
-        }
-        var self = MochiKit.Iter;
-        iterable = self.iter(iterable);
-        var _tee = self._tee;
-        for (var i = 0; i &lt; n; i++) {
-            rval.push(_tee(i, sync, iterable));
-        }
-        return rval;
-    },
-
-    list: function (iterable) {
-        /***
-
-            Convert an iterable to a new array
-
-        ***/
-
-        // Fast-path for Array and Array-like
-        var m = MochiKit.Base;
-        if (typeof(iterable.slice) == 'function') {
-            return iterable.slice();
-        } else if (m.isArrayLike(iterable)) {
-            return m.concat(iterable);
-        }
-
-        var self = MochiKit.Iter;
-        iterable = self.iter(iterable);
-        var rval = [];
-        try {
-            while (true) {
-                rval.push(iterable.next());
-            }
-        } catch (e) {
-            if (e != self.StopIteration) {
-                throw e;
-            }
-            return rval;
-        }
-        // mozilla warnings aren't too bright
-        return undefined;
-    },
-
-
-    reduce: function (fn, iterable, /* optional */initial) {
-        /***
-
-            Apply a fn = function (a, b) cumulatively to the items of an
-            iterable from left to right, so as to reduce the iterable
-            to a single value.
-
-            For example::
-
-                reduce(function (a, b) { return x + y; }, [1, 2, 3, 4, 5])
-
-            calculates::
-
-                ((((1 + 2) + 3) + 4) + 5).
-
-            If initial is given, it is placed before the items of the sequence
-            in the calculation, and serves as a default when the sequence is
-            empty.
-
-            Note that the above example could be written more clearly as::
-
-                reduce(operator.add, [1, 2, 3, 4, 5])
-
-            Or even simpler::
-
-                sum([1, 2, 3, 4, 5])
-
-        ***/
-        var i = 0;
-        var x = initial;
-        var self = MochiKit.Iter;
-        iterable = self.iter(iterable);
-        if (arguments.length &lt; 3) {
-            try {
-                x = iterable.next();
-            } catch (e) {
-                if (e == self.StopIteration) {
-                    e = new TypeError(&quot;reduce() of empty sequence with no initial value&quot;);
-                }
-                throw e;
-            }
-            i++;
-        }
-        try {
-            while (true) {
-                x = fn(x, iterable.next());
-            }
-        } catch (e) {
-            if (e != self.StopIteration) {
-                throw e;
-            }
-        }
-        return x;
-    },
-
-    range: function (/* [start,] stop[, step] */) {
-        /***
-
-        Return an iterator containing an arithmetic progression of integers.
-        range(i, j) returns iter([i, i + 1, i + 2, ..., j - 1]);
-        start (!) defaults to 0.  When step is given, it specifies the
-        increment (or decrement).  For example, range(4) returns
-        iter([0, 1, 2, 3]).  The end point is omitted!  These are exactly the
-        valid elements for an array of 4 elements.
-
-        ***/
-        var start = 0;
-        var stop = 0;
-        var step = 1;
-        if (arguments.length == 1) {
-            stop = arguments[0];
-        } else if (arguments.length == 2) {
-            start = arguments[0];
-            stop = arguments[1];
-        } else if (arguments.length == 3) {
-            start = arguments[0];
-            stop = arguments[1];
-            step = arguments[2];
-        } else {
-            throw new TypeError(&quot;range() takes 1, 2, or 3 arguments!&quot;);
-        }
-        if (step == 0) {
-            throw new TypeError(&quot;range() step must not be 0&quot;);
-        }
-        return {
-            next: function () {
-                if ((step &gt; 0 &amp;&amp; start &gt;= stop) || (step &lt; 0 &amp;&amp; start &lt;= stop)) {
-                    throw MochiKit.Iter.StopIteration;
-                }
-                var rval = start;
-                start += step;
-                return rval;
-            },
-            repr: function () {
-                return &quot;range(&quot; + [start, stop, step].join(&quot;, &quot;) + &quot;)&quot;;
-            },
-            toString: MochiKit.Base.forward(&quot;repr&quot;)
-        };
-    },
-
-    sum: function (iterable, start/* = 0 */) {
-        /***
-
-        Returns the sum of a sequence of numbers (NOT strings) plus the value
-        of parameter 'start' (with a default of 0).  When the sequence is
-        empty, returns start.
-
-        Equivalent to::
-
-            reduce(operator.add, iterable, start);
-
-        ***/
-        var x = start || 0;
-        var self = MochiKit.Iter;
-        iterable = self.iter(iterable);
-        try {
-            while (true) {
-                x += iterable.next();
-            }
-        } catch (e) {
-            if (e != self.StopIteration) {
-                throw e;
-            }
-        }
-        return x;
-    },
-
-    exhaust: function (iterable) {
-        /***
-
-            Exhausts an iterable without saving the results anywhere,
-            like list(iterable) when you don't care what the output is.
-
-        ***/
-
-        var self = MochiKit.Iter;
-        iterable = self.iter(iterable);
-        try {
-            while (true) {
-                iterable.next();
-            }
-        } catch (e) {
-            if (e != self.StopIteration) {
-                throw e;
-            }
-        }
-    },
-
-    forEach: function (iterable, func, /* optional */self) {
-        /***
-
-            Call func for each item in iterable.
-
-        ***/
-        var m = MochiKit.Base;
-        if (arguments.length &gt; 2) {
-            func = m.bind(func, self);
-        }
-        // fast path for array
-        if (m.isArrayLike(iterable)) {
-            try {
-                for (var i = 0; i &lt; iterable.length; i++) {
-                    func(iterable[i]);
-                }
-            } catch (e) {
-                if (e != MochiKit.Iter.StopIteration) {
-                    throw e;
-                }
-            }
-        } else {
-            self = MochiKit.Iter;
-            self.exhaust(self.imap(func, iterable));
-        }
-    },
-
-    every: function (iterable, func) {
-        /***
-
-            Return true if func(item) is true for every item in iterable
-
-        ***/
-        var self = MochiKit.Iter;
-        try {
-            self.ifilterfalse(func, iterable).next();
-            return false;
-        } catch (e) {
-            if (e != self.StopIteration) {
-                throw e;
-            }
-            return true;
-        }
-    },
-
-    sorted: function (iterable, /* optional */cmp) {
-        /***
-
-            Return a sorted array from iterable
-
-        ***/
-        var rval = MochiKit.Iter.list(iterable);
-        if (arguments.length == 1) {
-            cmp = MochiKit.Base.compare;
-        }
-        rval.sort(cmp);
-        return rval;
-    },
-
-    reversed: function (iterable) {
-        /***
-
-            Return a reversed array from iterable.
-
-        ***/
-        var rval = MochiKit.Iter.list(iterable);
-        rval.reverse();
-        return rval;
-    },
-
-    some: function (iterable, func) {
-        /***
-
-            Return true if func(item) is true for at least one item in iterable
-
-        ***/
-        var self = MochiKit.Iter;
-        try {
-            self.ifilter(func, iterable).next();
-            return true;
-        } catch (e) {
-            if (e != self.StopIteration) {
-                throw e;
-            }
-            return false;
-        }
-    },
-
-    iextend: function (lst, iterable) {
-        /***
-
-            Just like list(iterable), except it pushes results on lst
-
-        ***/
-
-        if (MochiKit.Base.isArrayLike(iterable)) {
-            // fast-path for array-like
-            for (var i = 0; i &lt; iterable.length; i++) {
-                lst.push(iterable[i]);
-            }
-        } else {
-            var self = MochiKit.Iter;
-            iterable = self.iter(iterable);
-            try {
-                while (true) {
-                    lst.push(iterable.next());
-                }
-            } catch (e) {
-                if (e != self.StopIteration) {
-                    throw e;
-                }
-            }
-        }
-        return lst;
-    },
-
-    groupby: function(iterable, /* optional */ keyfunc) {
-        /***
-
-            Like Python's itertools.groupby
-
-        ***/
-        var m = MochiKit.Base;
-        var self = MochiKit.Iter;
-        if (arguments.length &lt; 2) {
-            keyfunc = m.operator.identity;
-        }
-        iterable = self.iter(iterable);
-
-        // shared
-        var pk = undefined;
-        var k = undefined;
-        var v;
-
-        function fetch() {
-            v = iterable.next();
-            k = keyfunc(v);
-        };
-
-        function eat() {
-            var ret = v;
-            v = undefined;
-            return ret;
-        };
-
-        var first = true;
-        return {
-            repr: function () { return &quot;groupby(...)&quot;; },
-            next: function() {
-                // iterator-next
-
-                // iterate until meet next group
-                while (k == pk) {
-                    fetch();
-                    if (first) {
-                        first = false;
-                        break;
-                    }
-                }
-                pk = k;
-                return [k, {
-                    next: function() {
-                        // subiterator-next
-                        if (v == undefined) { // Is there something to eat?
-                            fetch();
-                        }
-                        if (k != pk) {
-                            throw self.StopIteration;
-                        }
-                        return eat();
-                    }
-                }];
-            }
-        };
-    },
-
-    groupby_as_array: function (iterable, /* optional */ keyfunc) {
-        /***
-
-            Like groupby, but return array of [key, subarray of values]
-
-        ***/
-        var m = MochiKit.Base;
-        var self = MochiKit.Iter;
-        if (arguments.length &lt; 2) {
-            keyfunc = m.operator.identity;
-        }
-
-        iterable = self.iter(iterable);
-        var result = [];
-        var first = true;
-        var prev_key;
-        while (true) {
-            try {
-                var value = iterable.next();
-                var key = keyfunc(value);
-            } catch (e) {
-                if (e == self.StopIteration) {
-                    break;
-                }
-                throw e;
-            }
-            if (first || key != prev_key) {
-                var values = [];
-                result.push([key, values]);
-            }
-            values.push(value);
-            first = false;
-            prev_key = key;
-        }
-        return result;
-    },
-
-    arrayLikeIter: function (iterable) {
-        var i = 0;
-        return {
-            repr: function () { return &quot;arrayLikeIter(...)&quot;; },
-            toString: MochiKit.Base.forward(&quot;repr&quot;),
-            next: function () {
-                if (i &gt;= iterable.length) {
-                    throw MochiKit.Iter.StopIteration;
-                }
-                return iterable[i++];
-            }
-        };
-    },
-
-    hasIterateNext: function (iterable) {
-        return (iterable &amp;&amp; typeof(iterable.iterateNext) == &quot;function&quot;);
-    },
-
-    iterateNextIter: function (iterable) {
-        return {
-            repr: function () { return &quot;iterateNextIter(...)&quot;; },
-            toString: MochiKit.Base.forward(&quot;repr&quot;),
-            next: function () {
-                var rval = iterable.iterateNext();
-                if (rval === null || rval === undefined) {
-                    throw MochiKit.Iter.StopIteration;
-                }
-                return rval;
-            }
-        };
-    }
-});
-
-
-MochiKit.Iter.EXPORT_OK = [
-    &quot;iteratorRegistry&quot;,
-    &quot;arrayLikeIter&quot;,
-    &quot;hasIterateNext&quot;,
-    &quot;iterateNextIter&quot;,
-];
-
-MochiKit.Iter.EXPORT = [
-    &quot;StopIteration&quot;,
-    &quot;registerIteratorFactory&quot;,
-    &quot;iter&quot;,
-    &quot;count&quot;,
-    &quot;cycle&quot;,
-    &quot;repeat&quot;,
-    &quot;next&quot;,
-    &quot;izip&quot;,
-    &quot;ifilter&quot;,
-    &quot;ifilterfalse&quot;,
-    &quot;islice&quot;,
-    &quot;imap&quot;,
-    &quot;applymap&quot;,
-    &quot;chain&quot;,
-    &quot;takewhile&quot;,
-    &quot;dropwhile&quot;,
-    &quot;tee&quot;,
-    &quot;list&quot;,
-    &quot;reduce&quot;,
-    &quot;range&quot;,
-    &quot;sum&quot;,
-    &quot;exhaust&quot;,
-    &quot;forEach&quot;,
-    &quot;every&quot;,
-    &quot;sorted&quot;,
-    &quot;reversed&quot;,
-    &quot;some&quot;,
-    &quot;iextend&quot;,
-    &quot;groupby&quot;,
-    &quot;groupby_as_array&quot;
-];
-
-MochiKit.Iter.__new__ = function () {
-    var m = MochiKit.Base;
-    this.StopIteration = new m.NamedError(&quot;StopIteration&quot;);
-    this.iteratorRegistry = new m.AdapterRegistry();
-    // Register the iterator factory for arrays
-    this.registerIteratorFactory(
-        &quot;arrayLike&quot;,
-        m.isArrayLike,
-        this.arrayLikeIter
-    );
-
-    this.registerIteratorFactory(
-        &quot;iterateNext&quot;,
-        this.hasIterateNext,
-        this.iterateNextIter
-    );
-
-    this.EXPORT_TAGS = {
-        &quot;:common&quot;: this.EXPORT,
-        &quot;:all&quot;: m.concat(this.EXPORT, this.EXPORT_OK)
-    };
-
-    m.nameFunctions(this);
-
+catch(e){
+throw &quot;MochiKit.Iter depends on MochiKit.Base!&quot;;
+}
+if(typeof (MochiKit.Iter)==&quot;undefined&quot;){
+MochiKit.Iter={};
+}
+MochiKit.Iter.NAME=&quot;MochiKit.Iter&quot;;
+MochiKit.Iter.VERSION=&quot;1.3&quot;;
+MochiKit.Base.update(MochiKit.Iter,{__repr__:function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
+},toString:function(){
+return this.__repr__();
+},registerIteratorFactory:function(name,_127,_128,_129){
+MochiKit.Iter.iteratorRegistry.register(name,_127,_128,_129);
+},iter:function(_130,_131){
+var self=MochiKit.Iter;
+if(arguments.length==2){
+return self.takewhile(function(a){
+return a!=_131;
+},_130);
+}
+if(typeof (_130.next)==&quot;function&quot;){
+return _130;
+}else{
+if(typeof (_130.iter)==&quot;function&quot;){
+return _130.iter();
+}
+}
+try{
+return self.iteratorRegistry.match(_130);
+}
+catch(e){
+var m=MochiKit.Base;
+if(e==m.NotFound){
+e=new TypeError(typeof (_130)+&quot;: &quot;+m.repr(_130)+&quot; is not iterable&quot;);
+}
+throw e;
+}
+},count:function(n){
+if(!n){
+n=0;
+}
+var m=MochiKit.Base;
+return {repr:function(){
+return &quot;count(&quot;+n+&quot;)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:m.counter(n)};
+},cycle:function(p){
+var self=MochiKit.Iter;
+var m=MochiKit.Base;
+var lst=[];
+var _134=self.iter(p);
+return {repr:function(){
+return &quot;cycle(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+try{
+var rval=_134.next();
+lst.push(rval);
+return rval;
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+if(lst.length==0){
+this.next=function(){
+throw self.StopIteration;
 };
-
+}else{
+var i=-1;
+this.next=function(){
+i=(i+1)%lst.length;
+return lst[i];
+};
+}
+return this.next();
+}
+}};
+},repeat:function(elem,n){
+var m=MochiKit.Base;
+if(typeof (n)==&quot;undefined&quot;){
+return {repr:function(){
+return &quot;repeat(&quot;+m.repr(elem)+&quot;)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+return elem;
+}};
+}
+return {repr:function(){
+return &quot;repeat(&quot;+m.repr(elem)+&quot;, &quot;+n+&quot;)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+if(n&lt;=0){
+throw MochiKit.Iter.StopIteration;
+}
+n-=1;
+return elem;
+}};
+},next:function(_136){
+return _136.next();
+},izip:function(p,q){
+var m=MochiKit.Base;
+var next=MochiKit.Iter.next;
+var _139=m.map(iter,arguments);
+return {repr:function(){
+return &quot;izip(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+return m.map(next,_139);
+}};
+},ifilter:function(pred,seq){
+var m=MochiKit.Base;
+seq=MochiKit.Iter.iter(seq);
+if(pred==null){
+pred=m.operator.truth;
+}
+return {repr:function(){
+return &quot;ifilter(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+while(true){
+var rval=seq.next();
+if(pred(rval)){
+return rval;
+}
+}
+return undefined;
+}};
+},ifilterfalse:function(pred,seq){
+var m=MochiKit.Base;
+seq=MochiKit.Iter.iter(seq);
+if(pred==null){
+pred=m.operator.truth;
+}
+return {repr:function(){
+return &quot;ifilterfalse(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+while(true){
+var rval=seq.next();
+if(!pred(rval)){
+return rval;
+}
+}
+return undefined;
+}};
+},islice:function(seq){
+var self=MochiKit.Iter;
+var m=MochiKit.Base;
+seq=self.iter(seq);
+var _142=0;
+var stop=0;
+var step=1;
+var i=-1;
+if(arguments.length==2){
+stop=arguments[1];
+}else{
+if(arguments.length==3){
+_142=arguments[1];
+stop=arguments[2];
+}else{
+_142=arguments[1];
+stop=arguments[2];
+step=arguments[3];
+}
+}
+return {repr:function(){
+return &quot;islice(&quot;+[&quot;...&quot;,_142,stop,step].join(&quot;, &quot;)+&quot;)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+var rval;
+while(i&lt;_142){
+rval=seq.next();
+i++;
+}
+if(_142&gt;=stop){
+throw self.StopIteration;
+}
+_142+=step;
+return rval;
+}};
+},imap:function(fun,p,q){
+var m=MochiKit.Base;
+var self=MochiKit.Iter;
+var _146=m.map(self.iter,m.extend(null,arguments,1));
+var map=m.map;
+var next=self.next;
+return {repr:function(){
+return &quot;imap(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+return fun.apply(this,map(next,_146));
+}};
+},applymap:function(fun,seq,self){
+seq=MochiKit.Iter.iter(seq);
+var m=MochiKit.Base;
+return {repr:function(){
+return &quot;applymap(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+return fun.apply(self,seq.next());
+}};
+},chain:function(p,q){
+var self=MochiKit.Iter;
+var m=MochiKit.Base;
+if(arguments.length==1){
+return self.iter(arguments[0]);
+}
+var _148=m.map(self.iter,arguments);
+return {repr:function(){
+return &quot;chain(...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+while(_148.length&gt;1){
+try{
+return _148[0].next();
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+_148.shift();
+}
+}
+if(_148.length==1){
+var arg=_148.shift();
+this.next=m.bind(&quot;next&quot;,arg);
+return this.next();
+}
+throw self.StopIteration;
+}};
+},takewhile:function(pred,seq){
+var self=MochiKit.Iter;
+seq=self.iter(seq);
+return {repr:function(){
+return &quot;takewhile(...)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;),next:function(){
+var rval=seq.next();
+if(!pred(rval)){
+this.next=function(){
+throw self.StopIteration;
+};
+this.next();
+}
+return rval;
+}};
+},dropwhile:function(pred,seq){
+seq=MochiKit.Iter.iter(seq);
+var m=MochiKit.Base;
+var bind=m.bind;
+return {&quot;repr&quot;:function(){
+return &quot;dropwhile(...)&quot;;
+},&quot;toString&quot;:m.forward(&quot;repr&quot;),&quot;next&quot;:function(){
+while(true){
+var rval=seq.next();
+if(!pred(rval)){
+break;
+}
+}
+this.next=bind(&quot;next&quot;,seq);
+return rval;
+}};
+},_tee:function(_150,sync,_152){
+sync.pos[_150]=-1;
+var m=MochiKit.Base;
+var _153=m.listMin;
+return {repr:function(){
+return &quot;tee(&quot;+_150+&quot;, ...)&quot;;
+},toString:m.forward(&quot;repr&quot;),next:function(){
+var rval;
+var i=sync.pos[_150];
+if(i==sync.max){
+rval=_152.next();
+sync.deque.push(rval);
+sync.max+=1;
+sync.pos[_150]+=1;
+}else{
+rval=sync.deque[i-sync.min];
+sync.pos[_150]+=1;
+if(i==sync.min&amp;&amp;_153(sync.pos)!=sync.min){
+sync.min+=1;
+sync.deque.shift();
+}
+}
+return rval;
+}};
+},tee:function(_154,n){
+var rval=[];
+var sync={&quot;pos&quot;:[],&quot;deque&quot;:[],&quot;max&quot;:-1,&quot;min&quot;:-1};
+if(arguments.length==1){
+n=2;
+}
+var self=MochiKit.Iter;
+_154=self.iter(_154);
+var _tee=self._tee;
+for(var i=0;i&lt;n;i++){
+rval.push(_tee(i,sync,_154));
+}
+return rval;
+},list:function(_156){
+var m=MochiKit.Base;
+if(typeof (_156.slice)==&quot;function&quot;){
+return _156.slice();
+}else{
+if(m.isArrayLike(_156)){
+return m.concat(_156);
+}
+}
+var self=MochiKit.Iter;
+_156=self.iter(_156);
+var rval=[];
+try{
+while(true){
+rval.push(_156.next());
+}
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+return rval;
+}
+return undefined;
+},reduce:function(fn,_157,_158){
+var i=0;
+var x=_158;
+var self=MochiKit.Iter;
+_157=self.iter(_157);
+if(arguments.length&lt;3){
+try{
+x=_157.next();
+}
+catch(e){
+if(e==self.StopIteration){
+e=new TypeError(&quot;reduce() of empty sequence with no initial value&quot;);
+}
+throw e;
+}
+i++;
+}
+try{
+while(true){
+x=fn(x,_157.next());
+}
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+}
+return x;
+},range:function(){
+var _160=0;
+var stop=0;
+var step=1;
+if(arguments.length==1){
+stop=arguments[0];
+}else{
+if(arguments.length==2){
+_160=arguments[0];
+stop=arguments[1];
+}else{
+if(arguments.length==3){
+_160=arguments[0];
+stop=arguments[1];
+step=arguments[2];
+}else{
+throw new TypeError(&quot;range() takes 1, 2, or 3 arguments!&quot;);
+}
+}
+}
+if(step==0){
+throw new TypeError(&quot;range() step must not be 0&quot;);
+}
+return {next:function(){
+if((step&gt;0&amp;&amp;_160&gt;=stop)||(step&lt;0&amp;&amp;_160&lt;=stop)){
+throw MochiKit.Iter.StopIteration;
+}
+var rval=_160;
+_160+=step;
+return rval;
+},repr:function(){
+return &quot;range(&quot;+[_160,stop,step].join(&quot;, &quot;)+&quot;)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;)};
+},sum:function(_161,_162){
+var x=_162||0;
+var self=MochiKit.Iter;
+_161=self.iter(_161);
+try{
+while(true){
+x+=_161.next();
+}
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+}
+return x;
+},exhaust:function(_163){
+var self=MochiKit.Iter;
+_163=self.iter(_163);
+try{
+while(true){
+_163.next();
+}
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+}
+},forEach:function(_164,func,self){
+var m=MochiKit.Base;
+if(arguments.length&gt;2){
+func=m.bind(func,self);
+}
+if(m.isArrayLike(_164)){
+try{
+for(var i=0;i&lt;_164.length;i++){
+func(_164[i]);
+}
+}
+catch(e){
+if(e!=MochiKit.Iter.StopIteration){
+throw e;
+}
+}
+}else{
+self=MochiKit.Iter;
+self.exhaust(self.imap(func,_164));
+}
+},every:function(_166,func){
+var self=MochiKit.Iter;
+try{
+self.ifilterfalse(func,_166).next();
+return false;
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+return true;
+}
+},sorted:function(_167,cmp){
+var rval=MochiKit.Iter.list(_167);
+if(arguments.length==1){
+cmp=MochiKit.Base.compare;
+}
+rval.sort(cmp);
+return rval;
+},reversed:function(_168){
+var rval=MochiKit.Iter.list(_168);
+rval.reverse();
+return rval;
+},some:function(_169,func){
+var self=MochiKit.Iter;
+try{
+self.ifilter(func,_169).next();
+return true;
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+return false;
+}
+},iextend:function(lst,_170){
+if(MochiKit.Base.isArrayLike(_170)){
+for(var i=0;i&lt;_170.length;i++){
+lst.push(_170[i]);
+}
+}else{
+var self=MochiKit.Iter;
+_170=self.iter(_170);
+try{
+while(true){
+lst.push(_170.next());
+}
+}
+catch(e){
+if(e!=self.StopIteration){
+throw e;
+}
+}
+}
+return lst;
+},groupby:function(_171,_172){
+var m=MochiKit.Base;
+var self=MochiKit.Iter;
+if(arguments.length&lt;2){
+_172=m.operator.identity;
+}
+_171=self.iter(_171);
+var pk=undefined;
+var k=undefined;
+var v;
+function fetch(){
+v=_171.next();
+k=_172(v);
+}
+function eat(){
+var ret=v;
+v=undefined;
+return ret;
+}
+var _175=true;
+return {repr:function(){
+return &quot;groupby(...)&quot;;
+},next:function(){
+while(k==pk){
+fetch();
+if(_175){
+_175=false;
+break;
+}
+}
+pk=k;
+return [k,{next:function(){
+if(v==undefined){
+fetch();
+}
+if(k!=pk){
+throw self.StopIteration;
+}
+return eat();
+}}];
+}};
+},groupby_as_array:function(_176,_177){
+var m=MochiKit.Base;
+var self=MochiKit.Iter;
+if(arguments.length&lt;2){
+_177=m.operator.identity;
+}
+_176=self.iter(_176);
+var _178=[];
+var _179=true;
+var _180;
+while(true){
+try{
+var _181=_176.next();
+var key=_177(_181);
+}
+catch(e){
+if(e==self.StopIteration){
+break;
+}
+throw e;
+}
+if(_179||key!=_180){
+var _182=[];
+_178.push([key,_182]);
+}
+_182.push(_181);
+_179=false;
+_180=key;
+}
+return _178;
+},arrayLikeIter:function(_183){
+var i=0;
+return {repr:function(){
+return &quot;arrayLikeIter(...)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;),next:function(){
+if(i&gt;=_183.length){
+throw MochiKit.Iter.StopIteration;
+}
+return _183[i++];
+}};
+},hasIterateNext:function(_184){
+return (_184&amp;&amp;typeof (_184.iterateNext)==&quot;function&quot;);
+},iterateNextIter:function(_185){
+return {repr:function(){
+return &quot;iterateNextIter(...)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;),next:function(){
+var rval=_185.iterateNext();
+if(rval===null||rval===undefined){
+throw MochiKit.Iter.StopIteration;
+}
+return rval;
+}};
+}});
+MochiKit.Iter.EXPORT_OK=[&quot;iteratorRegistry&quot;,&quot;arrayLikeIter&quot;,&quot;hasIterateNext&quot;,&quot;iterateNextIter&quot;,];
+MochiKit.Iter.EXPORT=[&quot;StopIteration&quot;,&quot;registerIteratorFactory&quot;,&quot;iter&quot;,&quot;count&quot;,&quot;cycle&quot;,&quot;repeat&quot;,&quot;next&quot;,&quot;izip&quot;,&quot;ifilter&quot;,&quot;ifilterfalse&quot;,&quot;islice&quot;,&quot;imap&quot;,&quot;applymap&quot;,&quot;chain&quot;,&quot;takewhile&quot;,&quot;dropwhile&quot;,&quot;tee&quot;,&quot;list&quot;,&quot;reduce&quot;,&quot;range&quot;,&quot;sum&quot;,&quot;exhaust&quot;,&quot;forEach&quot;,&quot;every&quot;,&quot;sorted&quot;,&quot;reversed&quot;,&quot;some&quot;,&quot;iextend&quot;,&quot;groupby&quot;,&quot;groupby_as_array&quot;];
+MochiKit.Iter.__new__=function(){
+var m=MochiKit.Base;
+this.StopIteration=new m.NamedError(&quot;StopIteration&quot;);
+this.iteratorRegistry=new m.AdapterRegistry();
+this.registerIteratorFactory(&quot;arrayLike&quot;,m.isArrayLike,this.arrayLikeIter);
+this.registerIteratorFactory(&quot;iterateNext&quot;,this.hasIterateNext,this.iterateNextIter);
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+m.nameFunctions(this);
+};
 MochiKit.Iter.__new__();
-
-//
-// XXX: Internet Explorer blows
-//
-reduce = MochiKit.Iter.reduce;
-
-MochiKit.Base._exportSymbols(this, MochiKit.Iter);
-
-/***
-
-MochiKit.Logging 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.Logging');
-    dojo.require('MochiKit.Base');
+reduce=MochiKit.Iter.reduce;
+MochiKit.Base._exportSymbols(this,MochiKit.Iter);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Logging&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
 }
-
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Base&quot;, []);
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
 }
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.Logging depends on MochiKit.Base!&quot;;
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;){
+throw &quot;&quot;;
 }
-
-if (typeof(MochiKit.Logging) == 'undefined') {
-    MochiKit.Logging = {};
 }
-
-MochiKit.Logging.NAME = &quot;MochiKit.Logging&quot;;
-MochiKit.Logging.VERSION = &quot;1.3&quot;;
-MochiKit.Logging.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+catch(e){
+throw &quot;MochiKit.Logging depends on MochiKit.Base!&quot;;
+}
+if(typeof (MochiKit.Logging)==&quot;undefined&quot;){
+MochiKit.Logging={};
+}
+MochiKit.Logging.NAME=&quot;MochiKit.Logging&quot;;
+MochiKit.Logging.VERSION=&quot;1.3&quot;;
+MochiKit.Logging.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-
-MochiKit.Logging.toString = function () {
-    return this.__repr__();
+MochiKit.Logging.toString=function(){
+return this.__repr__();
 };
-
-
-MochiKit.Logging.EXPORT = [
-    &quot;LogLevel&quot;,
-    &quot;LogMessage&quot;,
-    &quot;Logger&quot;,
-    &quot;alertListener&quot;,
-    &quot;logger&quot;,
-    &quot;log&quot;,
-    &quot;logError&quot;,
-    &quot;logDebug&quot;,
-    &quot;logFatal&quot;,
-    &quot;logWarning&quot;
-];
-
-
-MochiKit.Logging.EXPORT_OK = [
-    &quot;logLevelAtLeast&quot;,
-    &quot;isLogMessage&quot;,
-    &quot;compareLogMessage&quot;
-];
-
-
-MochiKit.Logging.LogMessage = function (num, level, info) {
-    this.num = num;
-    this.level = level;
-    this.info = info;
-    this.timestamp = new Date();
+MochiKit.Logging.EXPORT=[&quot;LogLevel&quot;,&quot;LogMessage&quot;,&quot;Logger&quot;,&quot;alertListener&quot;,&quot;logger&quot;,&quot;log&quot;,&quot;logError&quot;,&quot;logDebug&quot;,&quot;logFatal&quot;,&quot;logWarning&quot;];
+MochiKit.Logging.EXPORT_OK=[&quot;logLevelAtLeast&quot;,&quot;isLogMessage&quot;,&quot;compareLogMessage&quot;];
+MochiKit.Logging.LogMessage=function(num,_187,info){
+this.num=num;
+this.level=_187;
+this.info=info;
+this.timestamp=new Date();
 };
-
-MochiKit.Logging.LogMessage.prototype = {
-    repr: function () {
-        var m = MochiKit.Base;
-        return 'LogMessage(' +
-            m.map(
-                m.repr,
-                [this.num, this.level, this.info]
-            ).join(', ') + ')';
-    },
-    toString: MochiKit.Base.forward(&quot;repr&quot;)
+MochiKit.Logging.LogMessage.prototype={repr:function(){
+var m=MochiKit.Base;
+return &quot;LogMessage(&quot;+m.map(m.repr,[this.num,this.level,this.info]).join(&quot;, &quot;)+&quot;)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;)};
+MochiKit.Base.update(MochiKit.Logging,{logLevelAtLeast:function(_189){
+var self=MochiKit.Logging;
+if(typeof (_189)==&quot;string&quot;){
+_189=self.LogLevel[_189];
+}
+return function(msg){
+var _191=msg.level;
+if(typeof (_191)==&quot;string&quot;){
+_191=self.LogLevel[_191];
+}
+return _191&gt;=_189;
 };
-
-MochiKit.Base.update(MochiKit.Logging, {
-    logLevelAtLeast: function (minLevel) {
-        /***
-
-            Return a function that will match log messages whose level
-            is at least minLevel
-
-        ***/
-        var self = MochiKit.Logging;
-        if (typeof(minLevel) == 'string') {
-            minLevel = self.LogLevel[minLevel];
-        }
-        return function (msg) {
-            var msgLevel = msg.level;
-            if (typeof(msgLevel) == 'string') {
-                msgLevel = self.LogLevel[msgLevel];
-            }
-            return msgLevel &gt;= minLevel;
-        }
-    },
-
-    isLogMessage: function (/* ... */) {
-        var LogMessage = MochiKit.Logging.LogMessage;
-        for (var i = 0; i &lt; arguments.length; i++) {
-            if (!(arguments[i] instanceof LogMessage)) {
-                return false;
-            }
-        }
-        return true;
-    },
-
-    compareLogMessage: function (a, b) {
-        return MochiKit.Base.compare([a.level, a.info], [b.level, b.info]);
-    },
-
-    alertListener: function (msg) {
-        /***
-
-        Ultra-obnoxious alert(...) listener
-
-        ***/
-        alert(
-            &quot;num: &quot; + msg.num +
-            &quot;\nlevel: &quot; +  msg.level +
-            &quot;\ninfo: &quot; + msg.info.join(&quot; &quot;)
-        );
-    }
-
-});
-
-MochiKit.Logging.Logger = function (/* optional */maxSize) {
-    /***
-
-        A basic logger object that has a buffer of recent messages
-        plus a listener dispatch mechanism for &quot;real-time&quot; logging
-        of important messages
-
-        maxSize is the maximum number of entries in the log.
-        If maxSize &gt;= 0, then the log will not buffer more than that
-        many messages.
-
-        There is a default logger available named &quot;logger&quot;, and several
-        of its methods are also global functions:
-
-            logger.log      -&gt; log
-            logger.debug    -&gt; logDebug
-            logger.warning  -&gt; logWarning
-            logger.error    -&gt; logError
-            logger.fatal    -&gt; logFatal
-
-    ***/
-    this.counter = 0;
-    if (typeof(maxSize) == 'undefined' || maxSize == null) {
-        maxSize = -1;
-    }
-    this.maxSize = maxSize;
-    this._messages = [];
-    this.listeners = {};
+},isLogMessage:function(){
+var _192=MochiKit.Logging.LogMessage;
+for(var i=0;i&lt;arguments.length;i++){
+if(!(arguments[i] instanceof _192)){
+return false;
+}
+}
+return true;
+},compareLogMessage:function(a,b){
+return MochiKit.Base.compare([a.level,a.info],[b.level,b.info]);
+},alertListener:function(msg){
+alert(&quot;num: &quot;+msg.num+&quot;\nlevel: &quot;+msg.level+&quot;\ninfo: &quot;+msg.info.join(&quot; &quot;));
+}});
+MochiKit.Logging.Logger=function(_193){
+this.counter=0;
+if(typeof (_193)==&quot;undefined&quot;||_193==null){
+_193=-1;
+}
+this.maxSize=_193;
+this._messages=[];
+this.listeners={};
 };
-
-MochiKit.Logging.Logger.prototype = {
-    clear: function () {
-        /***
-
-            Clear all messages from the message buffer.
-
-        ***/
-        this._messages.splice(0, this._messages.length);
-    },
-
-    dispatchListeners: function (msg) {
-        /***
-
-            Dispatch a log message to all listeners.
-
-        ***/
-        for (var k in this.listeners) {
-            var pair = this.listeners[k];
-            if (pair.ident != k || (pair[0] &amp;&amp; !pair[0](msg))) {
-                continue;
-            }
-            pair[1](msg);
-        }
-    },
-
-    addListener: function (ident, filter, listener) {
-        /***
-
-            Add a listener for log messages.
-
-            ident is a unique identifier that may be used to remove the listener
-            later on.
-
-            filter can be one of the following:
-                null:
-                    listener(msg) will be called for every log message
-                    received.
-
-                string:
-                    logLevelAtLeast(filter) will be used as the function
-                    (see below).
-
-                function:
-                    filter(msg) will be called for every msg, if it returns
-                    true then listener(msg) will be called.
-
-            listener is a function that takes one argument, a log message.  A log
-            message has three properties:
-
-                num:
-                    A counter that uniquely identifies a log message (per-logger)
-
-                level:
-                    A string or number representing the log level.  If string, you
-                    may want to use LogLevel[level] for comparison.
-
-                info:
-                    A list of objects passed as arguments to the log function.
-
-        ***/
-
-
-        if (typeof(filter) == 'string') {
-            filter = MochiKit.Logging.logLevelAtLeast(filter);
-        }
-        var entry = [filter, listener];
-        entry.ident = ident;
-        this.listeners[ident] = entry;
-    },
-
-    removeListener: function (ident) {
-        /***
-
-            Remove a listener using the ident given to addListener
-
-        ***/
-        delete this.listeners[ident];
-    },
-
-    baseLog: function (level, message/*, ...*/) {
-        /***
-
-            The base functionality behind all of the log functions.
-            The first argument is the log level as a string or number,
-            and all other arguments are used as the info list.
-
-            This function is available partially applied as:
-
-                Logger.debug    'DEBUG'
-                Logger.log      'INFO'
-                Logger.error    'ERROR'
-                Logger.fatal    'FATAL'
-                Logger.warning  'WARNING'
-
-            For the default logger, these are also available as global functions,
-            see the Logger constructor documentation for more info.
-
-        ***/
-
-        var msg = new MochiKit.Logging.LogMessage(
-            this.counter,
-            level,
-            MochiKit.Base.extend(null, arguments, 1)
-        );
-        this._messages.push(msg);
-        this.dispatchListeners(msg);
-        this.counter += 1;
-        while (this.maxSize &gt;= 0 &amp;&amp; this._messages.length &gt; this.maxSize) {
-            this._messages.shift();
-        }
-    },
-
-    getMessages: function (howMany) {
-        /***
-
-            Return a list of up to howMany messages from the message buffer.
-
-        ***/
-        var firstMsg = 0;
-        if (!(typeof(howMany) == 'undefined' || howMany == null)) {
-            firstMsg = Math.max(0, this._messages.length - howMany);
-        }
-        return this._messages.slice(firstMsg);
-    },
-
-    getMessageText: function (howMany) {
-        /***
-
-            Get a string representing up to the last howMany messages in the
-            message buffer.  The default is 30.
-
-            The message looks like this:
-
-                LAST {messages.length} MESSAGES:
-                  [{msg.num}] {msg.level}: {m.info.join(' ')}
-                  [{msg.num}] {msg.level}: {m.info.join(' ')}
-                  ...
-
-            If you want some other format, use Logger.getMessages and do it
-            yourself.
-
-        ***/
-        if (typeof(howMany) == 'undefined' || howMany == null) {
-            howMany = 30;
-        }
-        var messages = this.getMessages(howMany);
-        if (messages.length) {
-            var lst = map(function (m) {
-                return '\n  [' + m.num + '] ' + m.level + ': ' + m.info.join(' ');
-            }, messages);
-            lst.unshift('LAST ' + messages.length + ' MESSAGES:');
-            return lst.join('');
-        }
-        return '';
-    },
-
-    debuggingBookmarklet: function (inline) {
-        if (typeof(MochiKit.LoggingPane) == &quot;undefined&quot;) {
-            alert(this.getMessageText());
-        } else {
-            MochiKit.LoggingPane.createLoggingPane(inline || false);
-        }
-    }
+MochiKit.Logging.Logger.prototype={clear:function(){
+this._messages.splice(0,this._messages.length);
+},dispatchListeners:function(msg){
+for(var k in this.listeners){
+var pair=this.listeners[k];
+if(pair.ident!=k||(pair[0]&amp;&amp;!pair[0](msg))){
+continue;
+}
+pair[1](msg);
+}
+},addListener:function(_194,_195,_196){
+if(typeof (_195)==&quot;string&quot;){
+_195=MochiKit.Logging.logLevelAtLeast(_195);
+}
+var _197=[_195,_196];
+_197.ident=_194;
+this.listeners[_194]=_197;
+},removeListener:function(_198){
+delete this.listeners[_198];
+},baseLog:function(_199,_200){
+var msg=new MochiKit.Logging.LogMessage(this.counter,_199,MochiKit.Base.extend(null,arguments,1));
+this._messages.push(msg);
+this.dispatchListeners(msg);
+this.counter+=1;
+while(this.maxSize&gt;=0&amp;&amp;this._messages.length&gt;this.maxSize){
+this._messages.shift();
+}
+},getMessages:function(_201){
+var _202=0;
+if(!(typeof (_201)==&quot;undefined&quot;||_201==null)){
+_202=Math.max(0,this._messages.length-_201);
+}
+return this._messages.slice(_202);
+},getMessageText:function(_203){
+if(typeof (_203)==&quot;undefined&quot;||_203==null){
+_203=30;
+}
+var _204=this.getMessages(_203);
+if(_204.length){
+var lst=map(function(m){
+return &quot;\n  [&quot;+m.num+&quot;] &quot;+m.level+&quot;: &quot;+m.info.join(&quot; &quot;);
+},_204);
+lst.unshift(&quot;LAST &quot;+_204.length+&quot; MESSAGES:&quot;);
+return lst.join(&quot;&quot;);
+}
+return &quot;&quot;;
+},debuggingBookmarklet:function(_205){
+if(typeof (MochiKit.LoggingPane)==&quot;undefined&quot;){
+alert(this.getMessageText());
+}else{
+MochiKit.LoggingPane.createLoggingPane(_205||false);
+}
+}};
+MochiKit.Logging.__new__=function(){
+this.LogLevel={ERROR:40,FATAL:50,WARNING:30,INFO:20,DEBUG:10};
+var m=MochiKit.Base;
+m.registerComparator(&quot;LogMessage&quot;,this.isLogMessage,this.compareLogMessage);
+var _206=m.partial;
+var _207=this.Logger;
+var _208=_207.prototype.baseLog;
+m.update(this.Logger.prototype,{debug:_206(_208,&quot;DEBUG&quot;),log:_206(_208,&quot;INFO&quot;),error:_206(_208,&quot;ERROR&quot;),fatal:_206(_208,&quot;FATAL&quot;),warning:_206(_208,&quot;WARNING&quot;)});
+var self=this;
+var _209=function(name){
+return function(){
+self.logger[name].apply(self.logger,arguments);
 };
-
-
-MochiKit.Logging.__new__ = function () {
-    this.LogLevel = {
-        ERROR: 40,
-        FATAL: 50,
-        WARNING: 30,
-        INFO: 20,
-        DEBUG: 10
-    };
-
-    var m = MochiKit.Base;
-    m.registerComparator(&quot;LogMessage&quot;,
-        this.isLogMessage,
-        this.compareLogMessage
-    );
-
-    var partial = m.partial;
-
-    var Logger = this.Logger;
-    var baseLog = Logger.prototype.baseLog;
-    m.update(this.Logger.prototype, {
-        debug: partial(baseLog, 'DEBUG'),
-        log: partial(baseLog, 'INFO'),
-        error: partial(baseLog, 'ERROR'),
-        fatal: partial(baseLog, 'FATAL'),
-        warning: partial(baseLog, 'WARNING')
-    });
-
-    // indirectly find logger so it can be replaced
-    var self = this;
-    var connectLog = function (name) {
-        return function () {
-            self.logger[name].apply(self.logger, arguments);
-        }
-    };
-
-    this.log = connectLog('log');
-    this.logError = connectLog('error');
-    this.logDebug = connectLog('debug');
-    this.logFatal = connectLog('fatal');
-    this.logWarning = connectLog('warning');
-    this.logger = new Logger();
-
-    this.EXPORT_TAGS = {
-        &quot;:common&quot;: this.EXPORT,
-        &quot;:all&quot;: m.concat(this.EXPORT, this.EXPORT_OK)
-    };
-
-    m.nameFunctions(this);
-
 };
-
+this.log=_209(&quot;log&quot;);
+this.logError=_209(&quot;error&quot;);
+this.logDebug=_209(&quot;debug&quot;);
+this.logFatal=_209(&quot;fatal&quot;);
+this.logWarning=_209(&quot;warning&quot;);
+this.logger=new _207();
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+m.nameFunctions(this);
+};
 MochiKit.Logging.__new__();
-
-MochiKit.Base._exportSymbols(this, MochiKit.Logging);
-
-/***
-
-MochiKit.DateTime 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.DateTime');
+MochiKit.Base._exportSymbols(this,MochiKit.Logging);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.DateTime&quot;);
 }
-
-if (typeof(MochiKit) == 'undefined') {
-    MochiKit = {};
+if(typeof (MochiKit)==&quot;undefined&quot;){
+MochiKit={};
 }
-
-if (typeof(MochiKit.DateTime) == 'undefined') {
-    MochiKit.DateTime = {};
+if(typeof (MochiKit.DateTime)==&quot;undefined&quot;){
+MochiKit.DateTime={};
 }
-
-MochiKit.DateTime.NAME = &quot;MochiKit.DateTime&quot;;
-MochiKit.DateTime.VERSION = &quot;1.3&quot;;
-MochiKit.DateTime.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+MochiKit.DateTime.NAME=&quot;MochiKit.DateTime&quot;;
+MochiKit.DateTime.VERSION=&quot;1.3&quot;;
+MochiKit.DateTime.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-MochiKit.DateTime.toString = function () {
-    return this.__repr__();
+MochiKit.DateTime.toString=function(){
+return this.__repr__();
 };
-
-MochiKit.DateTime.isoDate = function (str) {
-    /***
-
-        Convert an ISO 8601 date (YYYY-MM-DD) to a Date object.
-
-    ***/
-    str = str + &quot;&quot;;
-    if (typeof(str) != &quot;string&quot; || str.length == 0) {
-        return null;
-    }
-    var iso = str.split('-');
-    if (iso.length == 0) {
-        return null;
-    }
-    return new Date(iso[0], iso[1] - 1, iso[2]);
+MochiKit.DateTime.isoDate=function(str){
+str=str+&quot;&quot;;
+if(typeof (str)!=&quot;string&quot;||str.length==0){
+return null;
+}
+var iso=str.split(&quot;-&quot;);
+if(iso.length==0){
+return null;
+}
+return new Date(iso[0],iso[1]-1,iso[2]);
 };
-
-MochiKit.DateTime._isoRegexp = /(\d{4,})(?:-(\d{1,2})(?:-(\d{1,2})(?:[T ](\d{1,2}):(\d{1,2})(?::(\d{1,2})(?:\.(\d+))?)?(?:(Z)|([+-])(\d{1,2})(?::(\d{1,2}))?)?)?)?)?/;
-
-MochiKit.DateTime.isoTimestamp = function (str) {
-    /***
-
-        Convert an ISO 8601 timestamp (or something close to it) to
-        a Date object.  Will accept the &quot;de facto&quot; form:
-
-            YYYY-MM-DD hh:mm:ss
-
-        or (the proper form):
-
-            YYYY-MM-DDThh:mm:ss
-
-    ***/
-    str = str + &quot;&quot;;
-    if (typeof(str) != &quot;string&quot; || str.length == 0) {
-        return null;
-    }
-    var res = str.match(MochiKit.DateTime._isoRegexp);
-    if (typeof(res) == &quot;undefined&quot; || res == null) {
-        return null;
-    }
-    var year, month, day, hour, min, sec, msec;
-    year = parseInt(res[1], 10);
-    if (typeof(res[2]) == &quot;undefined&quot; || res[2] == &quot;&quot;) {
-        return new Date(year);
-    }
-    month = parseInt(res[2], 10) - 1;
-    day = parseInt(res[3], 10);
-    if (typeof(res[4]) == &quot;undefined&quot; || res[4] == &quot;&quot;) {
-        return new Date(year, month, day);
-    }
-    hour = parseInt(res[4], 10);
-    min = parseInt(res[5], 10);
-    sec = (typeof(res[6]) != &quot;undefined&quot; &amp;&amp; res[6] != &quot;&quot;) ? parseInt(res[6], 10) : 0;
-    if (typeof(res[7]) != &quot;undefined&quot; &amp;&amp; res[7] != &quot;&quot;) {
-        msec = Math.round(1000.0 * parseFloat(&quot;0.&quot; + res[7]));
-    } else {
-        msec = 0;
-    }
-    if ((typeof(res[8]) == &quot;undefined&quot; || res[8] == &quot;&quot;) &amp;&amp; (typeof(res[9]) == &quot;undefined&quot; || res[9] == &quot;&quot;)) {
-        return new Date(year, month, day, hour, min, sec, msec);
-    }
-    var ofs;
-    if (typeof(res[9]) != &quot;undefined&quot; &amp;&amp; res[9] != &quot;&quot;) {
-        ofs = parseInt(res[10], 10) * 3600000;
-        if (typeof(res[11]) != &quot;undefined&quot; &amp;&amp; res[11] != &quot;&quot;) {
-            ofs += parseInt(res[11], 10) * 60000;
-        }
-        if (res[9] == &quot;-&quot;) {
-            ofs = -ofs;
-        }
-    } else {
-        ofs = 0;
-    }
-    return new Date(Date.UTC(year, month, day, hour, min, sec, msec) - ofs);
+MochiKit.DateTime._isoRegexp=/(\d{4,})(?:-(\d{1,2})(?:-(\d{1,2})(?:[T ](\d{1,2}):(\d{1,2})(?::(\d{1,2})(?:\.(\d+))?)?(?:(Z)|([+-])(\d{1,2})(?::(\d{1,2}))?)?)?)?)?/;
+MochiKit.DateTime.isoTimestamp=function(str){
+str=str+&quot;&quot;;
+if(typeof (str)!=&quot;string&quot;||str.length==0){
+return null;
+}
+var res=str.match(MochiKit.DateTime._isoRegexp);
+if(typeof (res)==&quot;undefined&quot;||res==null){
+return null;
+}
+var year,month,day,hour,min,sec,msec;
+year=parseInt(res[1],10);
+if(typeof (res[2])==&quot;undefined&quot;||res[2]==&quot;&quot;){
+return new Date(year);
+}
+month=parseInt(res[2],10)-1;
+day=parseInt(res[3],10);
+if(typeof (res[4])==&quot;undefined&quot;||res[4]==&quot;&quot;){
+return new Date(year,month,day);
+}
+hour=parseInt(res[4],10);
+min=parseInt(res[5],10);
+sec=(typeof (res[6])!=&quot;undefined&quot;&amp;&amp;res[6]!=&quot;&quot;)?parseInt(res[6],10):0;
+if(typeof (res[7])!=&quot;undefined&quot;&amp;&amp;res[7]!=&quot;&quot;){
+msec=Math.round(1000*parseFloat(&quot;0.&quot;+res[7]));
+}else{
+msec=0;
+}
+if((typeof (res[8])==&quot;undefined&quot;||res[8]==&quot;&quot;)&amp;&amp;(typeof (res[9])==&quot;undefined&quot;||res[9]==&quot;&quot;)){
+return new Date(year,month,day,hour,min,sec,msec);
+}
+var ofs;
+if(typeof (res[9])!=&quot;undefined&quot;&amp;&amp;res[9]!=&quot;&quot;){
+ofs=parseInt(res[10],10)*3600000;
+if(typeof (res[11])!=&quot;undefined&quot;&amp;&amp;res[11]!=&quot;&quot;){
+ofs+=parseInt(res[11],10)*60000;
+}
+if(res[9]==&quot;-&quot;){
+ofs=-ofs;
+}
+}else{
+ofs=0;
+}
+return new Date(Date.UTC(year,month,day,hour,min,sec,msec)-ofs);
 };
-
-MochiKit.DateTime.toISOTime = function (date, realISO/* = false */) {
-    /***
-
-        Get the hh:mm:ss from the given Date object.
-
-    ***/
-    if (typeof(date) == &quot;undefined&quot; || date == null) {
-        return null;
-    }
-    var hh = date.getHours();
-    var mm = date.getMinutes();
-    var ss = date.getSeconds();
-    var lst = [
-        ((realISO &amp;&amp; (hh &lt; 10)) ? &quot;0&quot; + hh : hh),
-        ((mm &lt; 10) ? &quot;0&quot; + mm : mm),
-        ((ss &lt; 10) ? &quot;0&quot; + ss : ss)
-    ];
-    return lst.join(&quot;:&quot;);
+MochiKit.DateTime.toISOTime=function(date,_215){
+if(typeof (date)==&quot;undefined&quot;||date==null){
+return null;
+}
+var hh=date.getHours();
+var mm=date.getMinutes();
+var ss=date.getSeconds();
+var lst=[((_215&amp;&amp;(hh&lt;10))?&quot;0&quot;+hh:hh),((mm&lt;10)?&quot;0&quot;+mm:mm),((ss&lt;10)?&quot;0&quot;+ss:ss)];
+return lst.join(&quot;:&quot;);
 };
-
-MochiKit.DateTime.toISOTimestamp = function (date, realISO/* = false*/) {
-    /***
-
-        Convert a Date object to something that's ALMOST but not quite an
-        ISO 8601 timestamp.  If it was a proper ISO timestamp it would be:
-
-            YYYY-MM-DDThh:mm:ssZ
-
-        However, we see junk in SQL and other places that looks like this:
-
-            YYYY-MM-DD hh:mm:ss
-
-        So, this function returns the latter form, despite its name, unless
-        you pass true for realISO.
-
-    ***/
-    if (typeof(date) == &quot;undefined&quot; || date == null) {
-        return null;
-    }
-    var sep = realISO ? &quot;T&quot; : &quot; &quot;;
-    var foot = realISO ? &quot;Z&quot; : &quot;&quot;;
-    if (realISO) {
-        date = new Date(date.getTime() + (date.getTimezoneOffset() * 60000));
-    }
-    return MochiKit.DateTime.toISODate(date) + sep + MochiKit.DateTime.toISOTime(date, realISO) + foot;
+MochiKit.DateTime.toISOTimestamp=function(date,_219){
+if(typeof (date)==&quot;undefined&quot;||date==null){
+return null;
+}
+var sep=_219?&quot;T&quot;:&quot; &quot;;
+var foot=_219?&quot;Z&quot;:&quot;&quot;;
+if(_219){
+date=new Date(date.getTime()+(date.getTimezoneOffset()*60000));
+}
+return MochiKit.DateTime.toISODate(date)+sep+MochiKit.DateTime.toISOTime(date,_219)+foot;
 };
-
-MochiKit.DateTime.toISODate = function (date) {
-    /***
-
-        Convert a Date object to an ISO 8601 date string (YYYY-MM-DD)
-
-    ***/
-    if (typeof(date) == &quot;undefined&quot; || date == null) {
-        return null;
-    }
-    var _padTwo = MochiKit.DateTime._padTwo;
-    return [
-        date.getFullYear(),
-        _padTwo(date.getMonth() + 1),
-        _padTwo(date.getDate())
-    ].join(&quot;-&quot;);
+MochiKit.DateTime.toISODate=function(date){
+if(typeof (date)==&quot;undefined&quot;||date==null){
+return null;
+}
+var _222=MochiKit.DateTime._padTwo;
+return [date.getFullYear(),_222(date.getMonth()+1),_222(date.getDate())].join(&quot;-&quot;);
 };
-
-MochiKit.DateTime.americanDate = function (d) {
-    /***
-
-        Converts a MM/DD/YYYY date to a Date object
-
-    ***/
-    d = d + &quot;&quot;;
-    if (typeof(d) != &quot;string&quot; || d.length == 0) {
-        return null;
-    }
-    var a = d.split('/');
-    return new Date(a[2], a[0] - 1, a[1]);
+MochiKit.DateTime.americanDate=function(d){
+d=d+&quot;&quot;;
+if(typeof (d)!=&quot;string&quot;||d.length==0){
+return null;
+}
+var a=d.split(&quot;/&quot;);
+return new Date(a[2],a[0]-1,a[1]);
 };
-
-MochiKit.DateTime._padTwo = function (n) {
-    return (n &gt; 9) ? n : &quot;0&quot; + n;
+MochiKit.DateTime._padTwo=function(n){
+return (n&gt;9)?n:&quot;0&quot;+n;
 };
-
-MochiKit.DateTime.toPaddedAmericanDate = function (d) {
-    /***
-
-        Converts a Date object to an MM/DD/YYYY date, e.g. 01/01/2001
-
-    ***/
-    if (typeof(d) == &quot;undefined&quot; || d == null) {
-        return null;
-    }
-    var _padTwo = MochiKit.DateTime._padTwo;
-    return [
-        _padTwo(d.getMonth() + 1),
-        _padTwo(d.getDate()),
-        d.getFullYear()
-    ].join('/');
+MochiKit.DateTime.toPaddedAmericanDate=function(d){
+if(typeof (d)==&quot;undefined&quot;||d==null){
+return null;
+}
+var _224=MochiKit.DateTime._padTwo;
+return [_224(d.getMonth()+1),_224(d.getDate()),d.getFullYear()].join(&quot;/&quot;);
 };
-
-MochiKit.DateTime.toAmericanDate = function (d) {
-    /***
-
-        Converts a Date object to an M/D/YYYY date, e.g. 1/1/2001
-
-    ***/
-    if (typeof(d) == &quot;undefined&quot; || d == null) {
-        return null;
-    }
-    return [d.getMonth() + 1, d.getDate(), d.getFullYear()].join('/');
+MochiKit.DateTime.toAmericanDate=function(d){
+if(typeof (d)==&quot;undefined&quot;||d==null){
+return null;
+}
+return [d.getMonth()+1,d.getDate(),d.getFullYear()].join(&quot;/&quot;);
 };
-
-MochiKit.DateTime.EXPORT = [
-    &quot;isoDate&quot;,
-    &quot;isoTimestamp&quot;,
-    &quot;toISOTime&quot;,
-    &quot;toISOTimestamp&quot;,
-    &quot;toISODate&quot;,
-    &quot;americanDate&quot;,
-    &quot;toPaddedAmericanDate&quot;,
-    &quot;toAmericanDate&quot;
-];
-
-MochiKit.DateTime.EXPORT_OK = [];
-MochiKit.DateTime.EXPORT_TAGS = {
-    &quot;:common&quot;: MochiKit.DateTime.EXPORT,
-    &quot;:all&quot;: MochiKit.DateTime.EXPORT
+MochiKit.DateTime.EXPORT=[&quot;isoDate&quot;,&quot;isoTimestamp&quot;,&quot;toISOTime&quot;,&quot;toISOTimestamp&quot;,&quot;toISODate&quot;,&quot;americanDate&quot;,&quot;toPaddedAmericanDate&quot;,&quot;toAmericanDate&quot;];
+MochiKit.DateTime.EXPORT_OK=[];
+MochiKit.DateTime.EXPORT_TAGS={&quot;:common&quot;:MochiKit.DateTime.EXPORT,&quot;:all&quot;:MochiKit.DateTime.EXPORT};
+MochiKit.DateTime.__new__=function(){
+var base=this.NAME+&quot;.&quot;;
+for(var k in this){
+var o=this[k];
+if(typeof (o)==&quot;function&quot;&amp;&amp;typeof (o.NAME)==&quot;undefined&quot;){
+try{
+o.NAME=base+k;
+}
+catch(e){
+}
+}
+}
 };
-
-MochiKit.DateTime.__new__ = function () {
-    // MochiKit.Base.nameFunctions(this);
-    var base = this.NAME + &quot;.&quot;;
-    for (var k in this) {
-        var o = this[k];
-        if (typeof(o) == 'function' &amp;&amp; typeof(o.NAME) == 'undefined') {
-            try {
-                o.NAME = base + k;
-            } catch (e) {
-                // pass
-            }
-        }
-    }
-};
-
 MochiKit.DateTime.__new__();
-
-if (typeof(MochiKit.Base) != &quot;undefined&quot;) {
-    MochiKit.Base._exportSymbols(this, MochiKit.DateTime);
-} else {
-    (function (globals, module) {
-        if ((typeof(JSAN) == 'undefined' &amp;&amp; typeof(dojo) == 'undefined')
-            || (typeof(MochiKit.__compat__) == 'boolean' &amp;&amp; MochiKit.__compat__)) {
-            var all = module.EXPORT_TAGS[&quot;:all&quot;];
-            for (var i = 0; i &lt; all.length; i++) {
-                globals[all[i]] = module[all[i]];
-            }
-        }
-    })(this, MochiKit.DateTime);
+if(typeof (MochiKit.Base)!=&quot;undefined&quot;){
+MochiKit.Base._exportSymbols(this,MochiKit.DateTime);
+}else{
+(function(_225,_226){
+if((typeof (JSAN)==&quot;undefined&quot;&amp;&amp;typeof (dojo)==&quot;undefined&quot;)||(typeof (MochiKit.__compat__)==&quot;boolean&quot;&amp;&amp;MochiKit.__compat__)){
+var all=_226.EXPORT_TAGS[&quot;:all&quot;];
+for(var i=0;i&lt;all.length;i++){
+_225[all[i]]=_226[all[i]];
 }
-
-/***
-
-MochiKit.Format 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.Format');
 }
-
-if (typeof(MochiKit) == 'undefined') {
-    MochiKit = {};
+})(this,MochiKit.DateTime);
 }
-
-if (typeof(MochiKit.Format) == 'undefined') {
-    MochiKit.Format = {};
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Format&quot;);
 }
-
-MochiKit.Format.NAME = &quot;MochiKit.Format&quot;;
-MochiKit.Format.VERSION = &quot;1.3&quot;;
-MochiKit.Format.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+if(typeof (MochiKit)==&quot;undefined&quot;){
+MochiKit={};
+}
+if(typeof (MochiKit.Format)==&quot;undefined&quot;){
+MochiKit.Format={};
+}
+MochiKit.Format.NAME=&quot;MochiKit.Format&quot;;
+MochiKit.Format.VERSION=&quot;1.3&quot;;
+MochiKit.Format.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-MochiKit.Format.toString = function () {
-    return this.__repr__();
+MochiKit.Format.toString=function(){
+return this.__repr__();
 };
-
-MochiKit.Format._numberFormatter = function (placeholder, header, footer, locale, isPercent, precision, leadingZeros, separatorAt, trailingZeros) {
-    return function (num) {
-        num = parseFloat(num);
-        if (typeof(num) == &quot;undefined&quot; || num == null || isNaN(num)) {
-            return placeholder;
-        }
-        var curheader = header;
-        var curfooter = footer;
-        if (num &lt; 0) {
-            num = -num;
-        } else {
-            curheader = curheader.replace(/-/, &quot;&quot;);
-        }
-        var me = arguments.callee;
-        var fmt = MochiKit.Format.formatLocale(locale);
-        if (isPercent) {
-            num = num * 100.0;
-            curfooter = fmt.percent + curfooter;
-        }
-        num = MochiKit.Format.roundToFixed(num, precision);
-        var parts = num.split(/\./);
-        var whole = parts[0];
-        var frac = (parts.length == 1) ? &quot;&quot; : parts[1];
-        var res = &quot;&quot;;
-        while (whole.length &lt; leadingZeros) {
-            whole = &quot;0&quot; + whole;
-        }
-        if (separatorAt) {
-            while (whole.length &gt; separatorAt) {
-                var i = whole.length - separatorAt;
-                //res = res + fmt.separator + whole.substring(i, whole.length);
-                res = fmt.separator + whole.substring(i, whole.length) + res;
-                whole = whole.substring(0, i);
-            }
-        }
-        res = whole + res;
-        if (precision &gt; 0) {
-            while (frac.length &lt; trailingZeros) {
-                frac = frac + &quot;0&quot;;
-            }
-            res = res + fmt.decimal + frac;
-        }
-        return curheader + res + curfooter;
-    };
+MochiKit.Format._numberFormatter=function(_227,_228,_229,_230,_231,_232,_233,_234,_235){
+return function(num){
+num=parseFloat(num);
+if(typeof (num)==&quot;undefined&quot;||num==null||isNaN(num)){
+return _227;
+}
+var _236=_228;
+var _237=_229;
+if(num&lt;0){
+num=-num;
+}else{
+_236=_236.replace(/-/,&quot;&quot;);
+}
+var me=arguments.callee;
+var fmt=MochiKit.Format.formatLocale(_230);
+if(_231){
+num=num*100;
+_237=fmt.percent+_237;
+}
+num=MochiKit.Format.roundToFixed(num,_232);
+var _239=num.split(/\./);
+var _240=_239[0];
+var frac=(_239.length==1)?&quot;&quot;:_239[1];
+var res=&quot;&quot;;
+while(_240.length&lt;_233){
+_240=&quot;0&quot;+_240;
+}
+if(_234){
+while(_240.length&gt;_234){
+var i=_240.length-_234;
+res=fmt.separator+_240.substring(i,_240.length)+res;
+_240=_240.substring(0,i);
+}
+}
+res=_240+res;
+if(_232&gt;0){
+while(frac.length&lt;_235){
+frac=frac+&quot;0&quot;;
+}
+res=res+fmt.decimal+frac;
+}
+return _236+res+_237;
 };
-
-MochiKit.Format.numberFormatter = function (pattern, placeholder/* = &quot;&quot; */, locale/* = &quot;default&quot; */) {
-    // <A HREF="http://java.sun.com/docs/books/tutorial/i18n/format/numberpattern.html">http://java.sun.com/docs/books/tutorial/i18n/format/numberpattern.html</A>
-    // | 0 | leading or trailing zeros
-    // | # | just the number
-    // | , | separator
-    // | . | decimal separator
-    // | % | Multiply by 100 and format as percent
-    if (typeof(placeholder) == &quot;undefined&quot;) {
-        placeholder = &quot;&quot;;
-    }
-    var match = pattern.match(/((?:[0#]+,)?[0#]+)(?:\.([0#]+))?(%)?/);
-    if (!match) {
-        throw TypeError(&quot;Invalid pattern&quot;);
-    }
-    var header = pattern.substr(0, match.index);
-    var footer = pattern.substr(match.index + match[0].length);
-    if (header.search(/-/) == -1) {
-        header = header + &quot;-&quot;;
-    }
-    var whole = match[1];
-    var frac = (typeof(match[2]) == &quot;string&quot; &amp;&amp; match[2] != &quot;&quot;) ? match[2] : &quot;&quot;;
-    var isPercent = (typeof(match[3]) == &quot;string&quot; &amp;&amp; match[3] != &quot;&quot;);
-    var tmp = whole.split(/,/);
-    var separatorAt;
-    if (typeof(locale) == &quot;undefined&quot;) {
-        locale = &quot;default&quot;;
-    }
-    if (tmp.length == 1) {
-        separatorAt = null;
-    } else {
-        separatorAt = tmp[1].length;
-    }
-    var leadingZeros = whole.length - whole.replace(/0/g, &quot;&quot;).length;
-    var trailingZeros = frac.length - frac.replace(/0/g, &quot;&quot;).length;
-    var precision = frac.length;
-    var rval = MochiKit.Format._numberFormatter(
-        placeholder, header, footer, locale, isPercent, precision,
-        leadingZeros, separatorAt, trailingZeros
-    );
-    var m = MochiKit.Base;
-    if (m) {
-        var fn = arguments.callee;
-        var args = m.concat(arguments);
-        rval.repr = function () {
-            return [
-                self.NAME,
-                &quot;(&quot;,
-                map(m.repr, args).join(&quot;, &quot;),
-                &quot;)&quot;
-            ].join(&quot;&quot;);
-        }
-    }
-    return rval;
 };
-
-MochiKit.Format.formatLocale = function (locale) {
-    if (typeof(locale) == &quot;undefined&quot; || locale == null) {
-        locale = &quot;default&quot;;
-    }
-    if (typeof(locale) == &quot;string&quot;) {
-        var rval = MochiKit.Format.LOCALE[locale];
-        if (typeof(rval) == &quot;string&quot;) {
-            rval = arguments.callee(rval);
-            MochiKit.Format.LOCALE[locale] = rval;
-        }
-        return rval;
-    } else {
-        return locale;
-    }
+MochiKit.Format.numberFormatter=function(_242,_243,_244){
+if(typeof (_243)==&quot;undefined&quot;){
+_243=&quot;&quot;;
+}
+var _245=_242.match(/((?:[0#]+,)?[0#]+)(?:\.([0#]+))?(%)?/);
+if(!_245){
+throw TypeError(&quot;Invalid pattern&quot;);
+}
+var _246=_242.substr(0,_245.index);
+var _247=_242.substr(_245.index+_245[0].length);
+if(_246.search(/-/)==-1){
+_246=_246+&quot;-&quot;;
+}
+var _248=_245[1];
+var frac=(typeof (_245[2])==&quot;string&quot;&amp;&amp;_245[2]!=&quot;&quot;)?_245[2]:&quot;&quot;;
+var _249=(typeof (_245[3])==&quot;string&quot;&amp;&amp;_245[3]!=&quot;&quot;);
+var tmp=_248.split(/,/);
+var _251;
+if(typeof (_244)==&quot;undefined&quot;){
+_244=&quot;default&quot;;
+}
+if(tmp.length==1){
+_251=null;
+}else{
+_251=tmp[1].length;
+}
+var _252=_248.length-_248.replace(/0/g,&quot;&quot;).length;
+var _253=frac.length-frac.replace(/0/g,&quot;&quot;).length;
+var _254=frac.length;
+var rval=MochiKit.Format._numberFormatter(_243,_246,_247,_244,_249,_254,_252,_251,_253);
+var m=MochiKit.Base;
+if(m){
+var fn=arguments.callee;
+var args=m.concat(arguments);
+rval.repr=function(){
+return [self.NAME,&quot;(&quot;,map(m.repr,args).join(&quot;, &quot;),&quot;)&quot;].join(&quot;&quot;);
 };
-
-MochiKit.Format.twoDigitAverage = function (numerator, denominator) {
-    /***
-
-        Calculate an average from a numerator and a denominator and return
-        it as a string with two digits of precision (e.g. &quot;1.23&quot;).
-
-        If the denominator is 0, &quot;0&quot; will be returned instead of NaN.
-
-    ***/
-    if (denominator) {
-        var res = numerator / denominator;
-        if (!isNaN(res)) {
-            return MochiKit.Format.twoDigitFloat(numerator / denominator);
-        }
-    }
-    return &quot;0&quot;;
+}
+return rval;
 };
-
-MochiKit.Format.twoDigitFloat = function (someFloat) {
-    /***
-
-        Roughly equivalent to: sprintf(&quot;%.2f&quot;, someFloat)
-
-    ***/
-    var sign = (someFloat &lt; 0 ? '-' : '');
-    var s = Math.floor(Math.abs(someFloat) * 100).toString();
-    if (s == '0') {
-        return s;
-    }
-    if (s.length &lt; 3) {
-        while (s.charAt(s.length - 1) == '0') {
-            s = s.substring(0, s.length - 1);
-        }
-        return sign + '0.' + s;
-    }
-    var head = sign + s.substring(0, s.length - 2);
-    var tail = s.substring(s.length - 2, s.length);
-    if (tail == '00') {
-        return head;
-    } else if (tail.charAt(1) == '0') {
-        return head + '.' + tail.charAt(0);
-    } else {
-        return head + '.' + tail;
-    }
+MochiKit.Format.formatLocale=function(_256){
+if(typeof (_256)==&quot;undefined&quot;||_256==null){
+_256=&quot;default&quot;;
+}
+if(typeof (_256)==&quot;string&quot;){
+var rval=MochiKit.Format.LOCALE[_256];
+if(typeof (rval)==&quot;string&quot;){
+rval=arguments.callee(rval);
+MochiKit.Format.LOCALE[_256]=rval;
+}
+return rval;
+}else{
+return _256;
+}
 };
-
-MochiKit.Format.lstrip = function (str, /* optional */chars) {
-    str = str + &quot;&quot;;
-    if (typeof(str) != &quot;string&quot;) {
-        return null;
-    }
-    if (!chars) {
-        return str.replace(/^\s+/, &quot;&quot;);
-    } else {
-        return str.replace(new RegExp(&quot;^[&quot; + chars + &quot;]+&quot;), &quot;&quot;);
-    }
+MochiKit.Format.twoDigitAverage=function(_257,_258){
+if(_258){
+var res=_257/_258;
+if(!isNaN(res)){
+return MochiKit.Format.twoDigitFloat(_257/_258);
+}
+}
+return &quot;0&quot;;
 };
-
-MochiKit.Format.rstrip = function (str, /* optional */chars) {
-    str = str + &quot;&quot;;
-    if (typeof(str) != &quot;string&quot;) {
-        return null;
-    }
-    if (!chars) {
-        return str.replace(/\s+$/, &quot;&quot;);
-    } else {
-        return str.replace(new RegExp(&quot;[&quot; + chars + &quot;]+$&quot;), &quot;&quot;);
-    }
+MochiKit.Format.twoDigitFloat=function(_259){
+var sign=(_259&lt;0?&quot;-&quot;:&quot;&quot;);
+var s=Math.floor(Math.abs(_259)*100).toString();
+if(s==&quot;0&quot;){
+return s;
+}
+if(s.length&lt;3){
+while(s.charAt(s.length-1)==&quot;0&quot;){
+s=s.substring(0,s.length-1);
+}
+return sign+&quot;0.&quot;+s;
+}
+var head=sign+s.substring(0,s.length-2);
+var tail=s.substring(s.length-2,s.length);
+if(tail==&quot;00&quot;){
+return head;
+}else{
+if(tail.charAt(1)==&quot;0&quot;){
+return head+&quot;.&quot;+tail.charAt(0);
+}else{
+return head+&quot;.&quot;+tail;
+}
+}
 };
-
-MochiKit.Format.strip = function (str, /* optional */chars) {
-    var self = MochiKit.Format;
-    return self.rstrip(self.lstrip(str, chars), chars);
+MochiKit.Format.lstrip=function(str,_264){
+str=str+&quot;&quot;;
+if(typeof (str)!=&quot;string&quot;){
+return null;
+}
+if(!_264){
+return str.replace(/^\s+/,&quot;&quot;);
+}else{
+return str.replace(new RegExp(&quot;^[&quot;+_264+&quot;]+&quot;),&quot;&quot;);
+}
 };
-
-MochiKit.Format.truncToFixed = function (aNumber, precision) {
-    aNumber = Math.floor(aNumber * Math.pow(10, precision));
-    var res = (aNumber * Math.pow(10, -precision)).toFixed(precision);
-    if (res.charAt(0) == &quot;.&quot;) {
-        res = &quot;0&quot; + res;
-    }
-    return res;
+MochiKit.Format.rstrip=function(str,_265){
+str=str+&quot;&quot;;
+if(typeof (str)!=&quot;string&quot;){
+return null;
+}
+if(!_265){
+return str.replace(/\s+$/,&quot;&quot;);
+}else{
+return str.replace(new RegExp(&quot;[&quot;+_265+&quot;]+$&quot;),&quot;&quot;);
+}
 };
-
-MochiKit.Format.roundToFixed = function (aNumber, precision) {
-    return MochiKit.Format.truncToFixed(
-        aNumber + 0.5 * Math.pow(10, -precision),
-        precision
-    );
+MochiKit.Format.strip=function(str,_266){
+var self=MochiKit.Format;
+return self.rstrip(self.lstrip(str,_266),_266);
 };
-
-MochiKit.Format.percentFormat = function (someFloat) {
-    /***
-
-        Roughly equivalent to: sprintf(&quot;%.2f%%&quot;, someFloat * 100)
-
-    ***/
-    return MochiKit.Format.twoDigitFloat(100 * someFloat) + '%';
+MochiKit.Format.truncToFixed=function(_267,_268){
+_267=Math.floor(_267*Math.pow(10,_268));
+var res=(_267*Math.pow(10,-_268)).toFixed(_268);
+if(res.charAt(0)==&quot;.&quot;){
+res=&quot;0&quot;+res;
+}
+return res;
 };
-
-MochiKit.Format.EXPORT = [
-    &quot;truncToFixed&quot;,
-    &quot;roundToFixed&quot;,
-    &quot;numberFormatter&quot;,
-    &quot;formatLocale&quot;,
-    &quot;twoDigitAverage&quot;,
-    &quot;twoDigitFloat&quot;,
-    &quot;percentFormat&quot;,
-    &quot;lstrip&quot;,
-    &quot;rstrip&quot;,
-    &quot;strip&quot;
-];
-
-MochiKit.Format.LOCALE = {
-    en_US: {separator: &quot;,&quot;, decimal: &quot;.&quot;, percent: &quot;%&quot;},
-    de_DE: {separator: &quot;.&quot;, decimal: &quot;,&quot;, percent: &quot;%&quot;},
-    fr_FR: {separator: &quot; &quot;, decimal: &quot;,&quot;, percent: &quot;%&quot;},
-    &quot;default&quot;: &quot;en_US&quot;
+MochiKit.Format.roundToFixed=function(_269,_270){
+return MochiKit.Format.truncToFixed(_269+0.5*Math.pow(10,-_270),_270);
 };
-
-MochiKit.Format.EXPORT_OK = [];
-MochiKit.Format.EXPORT_TAGS = {
-    ':all': MochiKit.Format.EXPORT,
-    ':common': MochiKit.Format.EXPORT
+MochiKit.Format.percentFormat=function(_271){
+return MochiKit.Format.twoDigitFloat(100*_271)+&quot;%&quot;;
 };
-
-MochiKit.Format.__new__ = function () {
-    // MochiKit.Base.nameFunctions(this);
-    var base = this.NAME + &quot;.&quot;;
-    var k, v, o;
-    for (k in this.LOCALE) {
-        o = this.LOCALE[k];
-        if (typeof(o) == &quot;object&quot;) {
-            o.repr = function () { return this.NAME; };
-            o.NAME = base + &quot;LOCALE.&quot; + k;
-        }
-    }
-    for (k in this) {
-        o = this[k];
-        if (typeof(o) == 'function' &amp;&amp; typeof(o.NAME) == 'undefined') {
-            try {
-                o.NAME = base + k;
-            } catch (e) {
-                // pass
-            }
-        }
-    }
+MochiKit.Format.EXPORT=[&quot;truncToFixed&quot;,&quot;roundToFixed&quot;,&quot;numberFormatter&quot;,&quot;formatLocale&quot;,&quot;twoDigitAverage&quot;,&quot;twoDigitFloat&quot;,&quot;percentFormat&quot;,&quot;lstrip&quot;,&quot;rstrip&quot;,&quot;strip&quot;];
+MochiKit.Format.LOCALE={en_US:{separator:&quot;,&quot;,decimal:&quot;.&quot;,percent:&quot;%&quot;},de_DE:{separator:&quot;.&quot;,decimal:&quot;,&quot;,percent:&quot;%&quot;},fr_FR:{separator:&quot; &quot;,decimal:&quot;,&quot;,percent:&quot;%&quot;},&quot;default&quot;:&quot;en_US&quot;};
+MochiKit.Format.EXPORT_OK=[];
+MochiKit.Format.EXPORT_TAGS={&quot;:all&quot;:MochiKit.Format.EXPORT,&quot;:common&quot;:MochiKit.Format.EXPORT};
+MochiKit.Format.__new__=function(){
+var base=this.NAME+&quot;.&quot;;
+var k,v,o;
+for(k in this.LOCALE){
+o=this.LOCALE[k];
+if(typeof (o)==&quot;object&quot;){
+o.repr=function(){
+return this.NAME;
 };
-
+o.NAME=base+&quot;LOCALE.&quot;+k;
+}
+}
+for(k in this){
+o=this[k];
+if(typeof (o)==&quot;function&quot;&amp;&amp;typeof (o.NAME)==&quot;undefined&quot;){
+try{
+o.NAME=base+k;
+}
+catch(e){
+}
+}
+}
+};
 MochiKit.Format.__new__();
-
-if (typeof(MochiKit.Base) != &quot;undefined&quot;) {
-    MochiKit.Base._exportSymbols(this, MochiKit.Format);
-} else {
-    (function (globals, module) {
-        if ((typeof(JSAN) == 'undefined' &amp;&amp; typeof(dojo) == 'undefined')
-            || (typeof(MochiKit.__compat__) == 'boolean' &amp;&amp; MochiKit.__compat__)) {
-            var all = module.EXPORT_TAGS[&quot;:all&quot;];
-            for (var i = 0; i &lt; all.length; i++) {
-                globals[all[i]] = module[all[i]];
-            }
-        }
-    })(this, MochiKit.Format);
+if(typeof (MochiKit.Base)!=&quot;undefined&quot;){
+MochiKit.Base._exportSymbols(this,MochiKit.Format);
+}else{
+(function(_272,_273){
+if((typeof (JSAN)==&quot;undefined&quot;&amp;&amp;typeof (dojo)==&quot;undefined&quot;)||(typeof (MochiKit.__compat__)==&quot;boolean&quot;&amp;&amp;MochiKit.__compat__)){
+var all=_273.EXPORT_TAGS[&quot;:all&quot;];
+for(var i=0;i&lt;all.length;i++){
+_272[all[i]]=_273[all[i]];
 }
-
-/***
-
-MochiKit.Async 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide(&quot;MochiKit.Async&quot;);
-    dojo.require(&quot;MochiKit.Base&quot;);
 }
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Base&quot;, []);
+})(this,MochiKit.Format);
 }
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.Async depends on MochiKit.Base!&quot;;
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Async&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
 }
-
-if (typeof(MochiKit.Async) == 'undefined') {
-    MochiKit.Async = {};
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
 }
-
-MochiKit.Async.NAME = &quot;MochiKit.Async&quot;;
-MochiKit.Async.VERSION = &quot;1.3&quot;;
-MochiKit.Async.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;){
+throw &quot;&quot;;
+}
+}
+catch(e){
+throw &quot;MochiKit.Async depends on MochiKit.Base!&quot;;
+}
+if(typeof (MochiKit.Async)==&quot;undefined&quot;){
+MochiKit.Async={};
+}
+MochiKit.Async.NAME=&quot;MochiKit.Async&quot;;
+MochiKit.Async.VERSION=&quot;1.3&quot;;
+MochiKit.Async.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-MochiKit.Async.toString = function () {
-    return this.__repr__();
+MochiKit.Async.toString=function(){
+return this.__repr__();
 };
-
-MochiKit.Async.Deferred = function (/* optional */ canceller) {
-    /***
-
-    Encapsulates a sequence of callbacks in response to a value that
-    may not yet be available.  This is modeled after the Deferred class
-    from Twisted &lt;<A HREF="http://twistedmatrix.com">http://twistedmatrix.com</A>&gt;.
-
-    Why do we want this?  JavaScript has no threads, and even if it did,
-    threads are hard.  Deferreds are a way of abstracting non-blocking
-    events, such as the final response to an XMLHttpRequest.
-
-    The sequence of callbacks is internally represented as a list
-    of 2-tuples containing the callback/errback pair.  For example,
-    the following call sequence::
-
-        var d = new Deferred();
-        d.addCallback(myCallback);
-        d.addErrback(myErrback);
-        d.addBoth(myBoth);
-        d.addCallbacks(myCallback, myErrback);
-
-    is translated into a Deferred with the following internal
-    representation::
-
-        [
-            [myCallback, null],
-            [null, myErrback],
-            [myBoth, myBoth],
-            [myCallback, myErrback]
-        ]
-
-    The Deferred also keeps track of its current status (fired).
-    Its status may be one of three things:
-
-        -1: no value yet (initial condition)
-         0: success
-         1: error
-
-    A Deferred will be in the error state if one of the following
-    three conditions are met:
-
-    1. The result given to callback or errback is &quot;instanceof&quot; Error
-    2. The previous callback or errback raised an exception while executing
-    3. The previous callback or errback returned a value &quot;instanceof&quot; Error
-
-    Otherwise, the Deferred will be in the success state.  The state of the
-    Deferred determines the next element in the callback sequence to run.
-
-    When a callback or errback occurs with the example deferred chain, something
-    equivalent to the following will happen (imagine that exceptions are caught
-    and returned)::
-
-        // d.callback(result) or d.errback(result)
-        if (!(result instanceof Error)) {
-            result = myCallback(result);
-        }
-        if (result instanceof Error) {
-            result = myErrback(result);
-        }
-        result = myBoth(result);
-        if (result instanceof Error) {
-            result = myErrback(result);
-        } else {
-            result = myCallback(result);
-        }
-
-    The result is then stored away in case another step is added to the
-    callback sequence.  Since the Deferred already has a value available,
-    any new callbacks added will be called immediately.
-
-    There are two other &quot;advanced&quot; details about this implementation that are
-    useful:
-
-    Callbacks are allowed to return Deferred instances themselves, so
-    you can build complicated sequences of events with ease.
-
-    The creator of the Deferred may specify a canceller.  The canceller
-    is a function that will be called if Deferred.cancel is called before
-    the Deferred fires.  You can use this to implement clean aborting of an
-    XMLHttpRequest, etc.  Note that cancel will fire the deferred with a
-    CancelledError (unless your canceller returns another kind of error),
-    so the errbacks should be prepared to handle that error for cancellable
-    Deferreds.
-
-    ***/
-
-
-    this.chain = [];
-    this.id = this._nextId();
-    this.fired = -1;
-    this.paused = 0;
-    this.results = [null, null];
-    this.canceller = canceller;
-    this.silentlyCancelled = false;
+MochiKit.Async.Deferred=function(_274){
+this.chain=[];
+this.id=this._nextId();
+this.fired=-1;
+this.paused=0;
+this.results=[null,null];
+this.canceller=_274;
+this.silentlyCancelled=false;
 };
-
-MochiKit.Async.Deferred.prototype = {
-    repr: function () {
-        var state;
-        if (this.fired == -1) {
-            state = 'unfired';
-        } else if (this.fired == 0) {
-            state = 'success';
-        } else {
-            state = 'error';
-        }
-        return 'Deferred(' + this.id + ', ' + state + ')';
-    },
-
-    toString: MochiKit.Base.forward(&quot;repr&quot;),
-
-    _nextId: MochiKit.Base.counter(),
-
-    cancel: function () {
-        /***
-
-        Cancels a Deferred that has not yet received a value,
-        or is waiting on another Deferred as its value.
-
-        If a canceller is defined, the canceller is called.
-        If the canceller did not return an error, or there
-        was no canceller, then the errback chain is started
-        with CancelledError.
-
-        ***/
-        var self = MochiKit.Async;
-        if (this.fired == -1) {
-            if (this.canceller) {
-                this.canceller(this);
-            } else {
-                this.silentlyCancelled = true;
-            }
-            if (this.fired == -1) {
-                this.errback(new self.CancelledError(this));
-            }
-        } else if ((this.fired == 0) &amp;&amp; (this.results[0] instanceof self.Deferred)) {
-            this.results[0].cancel();
-        }
-    },
-
-
-    _pause: function () {
-        /***
-
-        Used internally to signal that it's waiting on another Deferred
-
-        ***/
-        this.paused++;
-    },
-
-    _unpause: function () {
-        /***
-
-        Used internally to signal that it's no longer waiting on another
-        Deferred.
-
-        ***/
-        this.paused--;
-        if ((this.paused == 0) &amp;&amp; (this.fired &gt;= 0)) {
-            this._fire();
-        }
-    },
-
-    _continue: function (res) {
-        /***
-
-        Used internally when a dependent deferred fires.
-
-        ***/
-        this._resback(res);
-        this._unpause();
-    },
-
-    _resback: function (res) {
-        /***
-
-        The primitive that means either callback or errback
-
-        ***/
-        this.fired = ((res instanceof Error) ? 1 : 0);
-        this.results[this.fired] = res;
-        this._fire();
-    },
-
-    _check: function () {
-        if (this.fired != -1) {
-            if (!this.silentlyCancelled) {
-                throw new MochiKit.Async.AlreadyCalledError(this);
-            }
-            this.silentlyCancelled = false;
-            return;
-        }
-    },
-
-    callback: function (res) {
-        /***
-
-        Begin the callback sequence with a non-error value.
-
-        callback or errback should only be called once
-        on a given Deferred.
-
-        ***/
-        this._check();
-        this._resback(res);
-    },
-
-    errback: function (res) {
-        /***
-
-        Begin the callback sequence with an error result.
-
-        callback or errback should only be called once
-        on a given Deferred.
-
-        ***/
-        this._check();
-        if (!(res instanceof Error)) {
-            res = new MochiKit.Async.GenericError(res);
-        }
-        this._resback(res);
-    },
-
-    addBoth: function (fn) {
-        /***
-
-        Add the same function as both a callback and an errback as the
-        next element on the callback sequence.  This is useful for code
-        that you want to guarantee to run, e.g. a finalizer.
-
-        ***/
-        if (arguments.length &gt; 1) {
-            fn = MochiKit.Base.partial.apply(null, arguments);
-        }
-        return this.addCallbacks(fn, fn);
-    },
-
-    addCallback: function (fn) {
-        /***
-
-        Add a single callback to the end of the callback sequence.
-
-        ***/
-        if (arguments.length &gt; 1) {
-            fn = MochiKit.Base.partial.apply(null, arguments);
-        }
-        return this.addCallbacks(fn, null);
-    },
-
-    addErrback: function (fn) {
-        /***
-
-        Add a single errback to the end of the callback sequence.
-
-        ***/
-        if (arguments.length &gt; 1) {
-            fn = MochiKit.Base.partial.apply(null, arguments);
-        }
-        return this.addCallbacks(null, fn);
-    },
-
-    addCallbacks: function (cb, eb) {
-        /***
-
-        Add separate callback and errback to the end of the callback
-        sequence.
-
-        ***/
-        this.chain.push([cb, eb])
-        if (this.fired &gt;= 0) {
-            this._fire();
-        }
-        return this;
-    },
-
-    _fire: function () {
-        /***
-
-        Used internally to exhaust the callback sequence when a result
-        is available.
-
-        ***/
-        var chain = this.chain;
-        var fired = this.fired;
-        var res = this.results[fired];
-        var self = this;
-        var cb = null;
-        while (chain.length &gt; 0 &amp;&amp; this.paused == 0) {
-            // Array
-            var pair = chain.shift();
-            var f = pair[fired];
-            if (f == null) {
-                continue;
-            }
-            try {
-                res = f(res);
-                fired = ((res instanceof Error) ? 1 : 0);
-                if (res instanceof MochiKit.Async.Deferred) {
-                    cb = function (res) {
-                        self._continue(res);
-                    }
-                    this._pause();
-                }
-            } catch (err) {
-                fired = 1;
-                if (!(err instanceof Error)) {
-                    err = new MochiKit.Async.GenericError(err);
-                }
-                res = err;
-            }
-        }
-        this.fired = fired;
-        this.results[fired] = res;
-        if (cb &amp;&amp; this.paused) {
-            // this is for &quot;tail recursion&quot; in case the dependent deferred
-            // is already fired
-            res.addBoth(cb);
-        }
-    }
+MochiKit.Async.Deferred.prototype={repr:function(){
+var _275;
+if(this.fired==-1){
+_275=&quot;unfired&quot;;
+}else{
+if(this.fired==0){
+_275=&quot;success&quot;;
+}else{
+_275=&quot;error&quot;;
+}
+}
+return &quot;Deferred(&quot;+this.id+&quot;, &quot;+_275+&quot;)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;),_nextId:MochiKit.Base.counter(),cancel:function(){
+var self=MochiKit.Async;
+if(this.fired==-1){
+if(this.canceller){
+this.canceller(this);
+}else{
+this.silentlyCancelled=true;
+}
+if(this.fired==-1){
+this.errback(new self.CancelledError(this));
+}
+}else{
+if((this.fired==0)&amp;&amp;(this.results[0] instanceof self.Deferred)){
+this.results[0].cancel();
+}
+}
+},_pause:function(){
+this.paused++;
+},_unpause:function(){
+this.paused--;
+if((this.paused==0)&amp;&amp;(this.fired&gt;=0)){
+this._fire();
+}
+},_continue:function(res){
+this._resback(res);
+this._unpause();
+},_resback:function(res){
+this.fired=((res instanceof Error)?1:0);
+this.results[this.fired]=res;
+this._fire();
+},_check:function(){
+if(this.fired!=-1){
+if(!this.silentlyCancelled){
+throw new MochiKit.Async.AlreadyCalledError(this);
+}
+this.silentlyCancelled=false;
+return;
+}
+},callback:function(res){
+this._check();
+this._resback(res);
+},errback:function(res){
+this._check();
+if(!(res instanceof Error)){
+res=new MochiKit.Async.GenericError(res);
+}
+this._resback(res);
+},addBoth:function(fn){
+if(arguments.length&gt;1){
+fn=MochiKit.Base.partial.apply(null,arguments);
+}
+return this.addCallbacks(fn,fn);
+},addCallback:function(fn){
+if(arguments.length&gt;1){
+fn=MochiKit.Base.partial.apply(null,arguments);
+}
+return this.addCallbacks(fn,null);
+},addErrback:function(fn){
+if(arguments.length&gt;1){
+fn=MochiKit.Base.partial.apply(null,arguments);
+}
+return this.addCallbacks(null,fn);
+},addCallbacks:function(cb,eb){
+this.chain.push([cb,eb]);
+if(this.fired&gt;=0){
+this._fire();
+}
+return this;
+},_fire:function(){
+var _278=this.chain;
+var _279=this.fired;
+var res=this.results[_279];
+var self=this;
+var cb=null;
+while(_278.length&gt;0&amp;&amp;this.paused==0){
+var pair=_278.shift();
+var f=pair[_279];
+if(f==null){
+continue;
+}
+try{
+res=f(res);
+_279=((res instanceof Error)?1:0);
+if(res instanceof MochiKit.Async.Deferred){
+cb=function(res){
+self._continue(res);
 };
-
-MochiKit.Base.update(MochiKit.Async, {
-    evalJSONRequest: function (/* req */) {
-        /***
-
-        Evaluate a JSON (JavaScript Object Notation) XMLHttpRequest
-
-        @param req: The request whose responseText is to be evaluated
-
-        @rtype: L{Object}
-
-        ***/
-        return eval('(' + arguments[0].responseText + ')');
-    },
-
-    succeed: function (/* optional */result) {
-        /***
-
-        Return a Deferred that has already had '.callback(result)' called.
-
-        This is useful when you're writing synchronous code to an asynchronous
-        interface: i.e., some code is calling you expecting a Deferred result,
-        but you don't actually need to do anything asynchronous.  Just return
-        succeed(theResult).
-
-        See L{fail} for a version of this function that uses a failing Deferred
-        rather than a successful one.
-
-        @param result: The result to give to the Deferred's 'callback' method.
-
-        @rtype: L{Deferred}
-
-        ***/
-        var d = new MochiKit.Async.Deferred();
-        d.callback.apply(d, arguments);
-        return d;
-    },
-
-    fail: function (/* optional */result) {
-        /***
-
-        Return a Deferred that has already had '.errback(result)' called.
-
-        See L{succeed}'s docstring for rationale.
-
-        @param result: The same argument that L{Deferred.errback} takes.
-
-        @rtype: L{Deferred}
-
-        ***/
-        var d = new MochiKit.Async.Deferred();
-        d.errback.apply(d, arguments);
-        return d;
-    },
-
-    getXMLHttpRequest: function () {
-        var self = arguments.callee;
-        if (!self.XMLHttpRequest) {
-            var tryThese = [
-                function () { return new XMLHttpRequest(); },
-                function () { return new ActiveXObject('Msxml2.XMLHTTP'); },
-                function () { return new ActiveXObject('Microsoft.XMLHTTP'); },
-                function () { return new ActiveXObject('Msxml2.XMLHTTP.4.0'); },
-                function () {
-                    throw new MochiKit.Async.BrowserComplianceError(&quot;Browser does not support XMLHttpRequest&quot;);
-                }
-            ];
-            for (var i = 0; i &lt; tryThese.length; i++) {
-                var func = tryThese[i];
-                try {
-                    self.XMLHttpRequest = func;
-                    return func();
-                } catch (e) {
-                    // pass
-                }
-            }
-        }
-        return self.XMLHttpRequest();
-    },
-
-    sendXMLHttpRequest: function (req, /* optional */ sendContent) {
-        if (typeof(sendContent) == 'undefined') {
-            sendContent = &quot;&quot;;
-        }
-
-        var canceller = function () {
-            // IE SUCKS
-            try {
-                req.onreadystatechange = null;
-            } catch (e) {
-                try {
-                    req.onreadystatechange = function () {};
-                } catch (e) {
-                }
-            }
-            req.abort();
-        };
-
-        var self = MochiKit.Async;
-        var d = new self.Deferred(canceller);
-
-        var onreadystatechange = function () {
-            // MochiKit.Logging.logDebug('req.readyState', req.readyState);
-            if (req.readyState == 4) {
-                // IE SUCKS
-                try {
-                    req.onreadystatechange = null;
-                } catch (e) {
-                    try {
-                        req.onreadystatechange = function () {};
-                    } catch (e) {
-                    }
-                }
-                var status = null;
-                try {
-                    status = req.status;
-                    if (!status &amp;&amp; MochiKit.Base.isNotEmpty(req.responseText)) {
-                        // 0 or undefined seems to mean cached or local
-                        status = 304;
-                    }
-                } catch (e) {
-                    // pass
-                    // MochiKit.Logging.logDebug('error getting status?', repr(items(e)));
-                }
-                //  200 is OK, 304 is NOT_MODIFIED
-                if (status == 200 || status == 304) { // OK
-                    d.callback(req);
-                } else {
-                    var err = new self.XMLHttpRequestError(req, &quot;Request failed:&quot; + status);
-                    if (err.number) {
-                        // XXX: This seems to happen on page change
-                        d.errback(err);
-                    } else {
-                        // XXX: this seems to happen when the server is unreachable
-                        d.errback(err);
-                    }
-                }
-            }
-        }
-        try {
-            req.onreadystatechange = onreadystatechange;
-            req.send(sendContent);
-        } catch (e) {
-            try {
-                req.onreadystatechange = null;
-            } catch (ignore) {
-                // pass
-            }
-            d.errback(e);
-        }
-
-        return d;
-
-    },
-
-    doSimpleXMLHttpRequest: function (url/*, ...*/) {
-        var self = MochiKit.Async;
-        var req = self.getXMLHttpRequest();
-        if (arguments.length &gt; 1) {
-            var m = MochiKit.Base;
-            var qs = m.queryString.apply(null, m.extend(null, arguments, 1));
-            if (qs) {
-                url += &quot;?&quot; + qs;
-            }
-        }
-        req.open(&quot;GET&quot;, url, true);
-        return self.sendXMLHttpRequest(req);
-    },
-
-    loadJSONDoc: function (url) {
-        /***
-
-        Do a simple XMLHttpRequest to a URL and get the response
-        as a JSON document.
-
-        @param url: The URL to GET
-
-        @rtype: L{Deferred} returning the evaluated JSON response
-
-        ***/
-
-        var self = MochiKit.Async;
-        var d = self.doSimpleXMLHttpRequest.apply(self, arguments);
-        d = d.addCallback(self.evalJSONRequest);
-        return d;
-    },
-
-    wait: function (seconds, /* optional */value) {
-        var d = new MochiKit.Async.Deferred();
-        var m = MochiKit.Base;
-        if (typeof(value) != 'undefined') {
-            d.addCallback(function () { return value; });
-        }
-        var timeout = setTimeout(
-            m.bind(&quot;callback&quot;, d),
-            Math.floor(seconds * 1000));
-        d.canceller = function () {
-            try {
-                clearTimeout(timeout);
-            } catch (e) {
-                // pass
-            }
-        };
-        return d;
-    },
-
-    callLater: function (seconds, func) {
-        var m = MochiKit.Base;
-        var pfunc = m.partial.apply(m, m.extend(null, arguments, 1));
-        return MochiKit.Async.wait(seconds).addCallback(
-            function (res) { return pfunc(); }
-        );
-    }
+this._pause();
+}
+}
+catch(err){
+_279=1;
+if(!(err instanceof Error)){
+err=new MochiKit.Async.GenericError(err);
+}
+res=err;
+}
+}
+this.fired=_279;
+this.results[_279]=res;
+if(cb&amp;&amp;this.paused){
+res.addBoth(cb);
+}
+}};
+MochiKit.Base.update(MochiKit.Async,{evalJSONRequest:function(){
+return eval(&quot;(&quot;+arguments[0].responseText+&quot;)&quot;);
+},succeed:function(_281){
+var d=new MochiKit.Async.Deferred();
+d.callback.apply(d,arguments);
+return d;
+},fail:function(_282){
+var d=new MochiKit.Async.Deferred();
+d.errback.apply(d,arguments);
+return d;
+},getXMLHttpRequest:function(){
+var self=arguments.callee;
+if(!self.XMLHttpRequest){
+var _283=[function(){
+return new XMLHttpRequest();
+},function(){
+return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
+},function(){
+return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
+},function(){
+return new ActiveXObject(&quot;Msxml2.XMLHTTP.4.0&quot;);
+},function(){
+throw new MochiKit.Async.BrowserComplianceError(&quot;Browser does not support XMLHttpRequest&quot;);
+}];
+for(var i=0;i&lt;_283.length;i++){
+var func=_283[i];
+try{
+self.XMLHttpRequest=func;
+return func();
+}
+catch(e){
+}
+}
+}
+return self.XMLHttpRequest();
+},sendXMLHttpRequest:function(req,_285){
+if(typeof (_285)==&quot;undefined&quot;){
+_285=&quot;&quot;;
+}
+var _286=function(){
+try{
+req.onreadystatechange=null;
+}
+catch(e){
+try{
+req.onreadystatechange=function(){
+};
+}
+catch(e){
+}
+}
+req.abort();
+};
+var self=MochiKit.Async;
+var d=new self.Deferred(_286);
+var _287=function(){
+if(req.readyState==4){
+try{
+req.onreadystatechange=null;
+}
+catch(e){
+try{
+req.onreadystatechange=function(){
+};
+}
+catch(e){
+}
+}
+var _288=null;
+try{
+_288=req.status;
+if(!_288&amp;&amp;MochiKit.Base.isNotEmpty(req.responseText)){
+_288=304;
+}
+}
+catch(e){
+}
+if(_288==200||_288==304){
+d.callback(req);
+}else{
+var err=new self.XMLHttpRequestError(req,&quot;Request failed&quot;);
+if(err.number){
+d.errback(err);
+}else{
+d.errback(err);
+}
+}
+}
+};
+try{
+req.onreadystatechange=_287;
+req.send(_285);
+}
+catch(e){
+try{
+req.onreadystatechange=null;
+}
+catch(ignore){
+}
+d.errback(e);
+}
+return d;
+},doSimpleXMLHttpRequest:function(url){
+var self=MochiKit.Async;
+var req=self.getXMLHttpRequest();
+if(arguments.length&gt;1){
+var m=MochiKit.Base;
+var qs=m.queryString.apply(null,m.extend(null,arguments,1));
+if(qs){
+url+=&quot;?&quot;+qs;
+}
+}
+req.open(&quot;GET&quot;,url,true);
+return self.sendXMLHttpRequest(req);
+},loadJSONDoc:function(url){
+var self=MochiKit.Async;
+var d=self.doSimpleXMLHttpRequest.apply(self,arguments);
+d=d.addCallback(self.evalJSONRequest);
+return d;
+},wait:function(_292,_293){
+var d=new MochiKit.Async.Deferred();
+var m=MochiKit.Base;
+if(typeof (_293)!=&quot;undefined&quot;){
+d.addCallback(function(){
+return _293;
 });
-
-
-MochiKit.Async.DeferredLock = function () {
-    this.waiting = [];
-    this.locked = false;
-    this.id = this._nextId();
+}
+var _294=setTimeout(m.bind(&quot;callback&quot;,d),Math.floor(_292*1000));
+d.canceller=function(){
+try{
+clearTimeout(_294);
+}
+catch(e){
+}
 };
-
-MochiKit.Async.DeferredLock.prototype = {
-    __class__: MochiKit.Async.DeferredLock,
-    acquire: function () {
-        d = new MochiKit.Async.Deferred();
-        if (this.locked) {
-            this.waiting.push(d);
-        } else {
-            this.locked = true;
-            d.callback(this);
-        }
-        return d;
-    },
-    release: function () {
-        if (!this.locked) {
-            throw TypeError(&quot;Tried to release an unlocked DeferredLock&quot;);
-        }
-        this.locked = false;
-        if (this.waiting.length &gt; 0) {
-            this.locked = true;
-            this.waiting.shift().callback(this);
-        }
-    },
-    _nextId: MochiKit.Base.counter(),
-    repr: function () {
-        var state;
-        if (this.locked) {
-            state = 'locked, ' + this.waiting.length + ' waiting'
-        } else {
-            state = 'unlocked';
-        }
-        return 'DeferredLock(' + this.id + ', ' + state + ')';
-    },
-    toString: MochiKit.Base.forward(&quot;repr&quot;)
-
+return d;
+},callLater:function(_295,func){
+var m=MochiKit.Base;
+var _296=m.partial.apply(m,m.extend(null,arguments,1));
+return MochiKit.Async.wait(_295).addCallback(function(res){
+return _296();
+});
+}});
+MochiKit.Async.DeferredLock=function(){
+this.waiting=[];
+this.locked=false;
+this.id=this._nextId();
 };
-
-
-MochiKit.Async.EXPORT = [
-    &quot;AlreadyCalledError&quot;,
-    &quot;CancelledError&quot;,
-    &quot;BrowserComplianceError&quot;,
-    &quot;GenericError&quot;,
-    &quot;XMLHttpRequestError&quot;,
-    &quot;Deferred&quot;,
-    &quot;succeed&quot;,
-    &quot;fail&quot;,
-    &quot;getXMLHttpRequest&quot;,
-    &quot;doSimpleXMLHttpRequest&quot;,
-    &quot;loadJSONDoc&quot;,
-    &quot;wait&quot;,
-    &quot;callLater&quot;,
-    &quot;sendXMLHttpRequest&quot;,
-    &quot;DeferredLock&quot;
-];
-
-MochiKit.Async.EXPORT_OK = [
-    &quot;evalJSONRequest&quot;
-];
-
-MochiKit.Async.__new__ = function () {
-    var m = MochiKit.Base;
-    var ne = m.partial(m._newNamedError, this);
-    ne(&quot;AlreadyCalledError&quot;,
-        function (deferred) {
-            /***
-
-            Raised by the Deferred if callback or errback happens
-            after it was already fired.
-
-            ***/
-            this.deferred = deferred;
-        }
-    );
-
-    ne(&quot;CancelledError&quot;,
-        function (deferred) {
-            /***
-
-            Raised by the Deferred cancellation mechanism.
-
-            ***/
-            this.deferred = deferred;
-        }
-    );
-
-    ne(&quot;BrowserComplianceError&quot;,
-        function (msg) {
-            /***
-
-            Raised when the JavaScript runtime is not capable of performing
-            the given function.  Technically, this should really never be
-            raised because a non-conforming JavaScript runtime probably
-            isn't going to support exceptions in the first place.
-
-            ***/
-            this.message = msg;
-        }
-    );
-
-    ne(&quot;GenericError&quot;,
-        function (msg) {
-            this.message = msg;
-        }
-    );
-
-    ne(&quot;XMLHttpRequestError&quot;,
-        function (req, msg) {
-            /***
-
-            Raised when an XMLHttpRequest does not complete for any reason.
-
-            ***/
-            this.req = req;
-            this.message = msg;
-            try {
-                // Strange but true that this can raise in some cases.
-                this.number = req.status;
-            } catch (e) {
-                // pass
-            }
-        }
-    );
-
-
-    this.EXPORT_TAGS = {
-        &quot;:common&quot;: this.EXPORT,
-        &quot;:all&quot;: m.concat(this.EXPORT, this.EXPORT_OK)
-    };
-
-    m.nameFunctions(this);
-
+MochiKit.Async.DeferredLock.prototype={__class__:MochiKit.Async.DeferredLock,acquire:function(){
+d=new MochiKit.Async.Deferred();
+if(this.locked){
+this.waiting.push(d);
+}else{
+this.locked=true;
+d.callback(this);
+}
+return d;
+},release:function(){
+if(!this.locked){
+throw TypeError(&quot;Tried to release an unlocked DeferredLock&quot;);
+}
+this.locked=false;
+if(this.waiting.length&gt;0){
+this.locked=true;
+this.waiting.shift().callback(this);
+}
+},_nextId:MochiKit.Base.counter(),repr:function(){
+var _297;
+if(this.locked){
+_297=&quot;locked, &quot;+this.waiting.length+&quot; waiting&quot;;
+}else{
+_297=&quot;unlocked&quot;;
+}
+return &quot;DeferredLock(&quot;+this.id+&quot;, &quot;+_297+&quot;)&quot;;
+},toString:MochiKit.Base.forward(&quot;repr&quot;)};
+MochiKit.Async.EXPORT=[&quot;AlreadyCalledError&quot;,&quot;CancelledError&quot;,&quot;BrowserComplianceError&quot;,&quot;GenericError&quot;,&quot;XMLHttpRequestError&quot;,&quot;Deferred&quot;,&quot;succeed&quot;,&quot;fail&quot;,&quot;getXMLHttpRequest&quot;,&quot;doSimpleXMLHttpRequest&quot;,&quot;loadJSONDoc&quot;,&quot;wait&quot;,&quot;callLater&quot;,&quot;sendXMLHttpRequest&quot;,&quot;DeferredLock&quot;];
+MochiKit.Async.EXPORT_OK=[&quot;evalJSONRequest&quot;];
+MochiKit.Async.__new__=function(){
+var m=MochiKit.Base;
+var ne=m.partial(m._newNamedError,this);
+ne(&quot;AlreadyCalledError&quot;,function(_299){
+this.deferred=_299;
+});
+ne(&quot;CancelledError&quot;,function(_300){
+this.deferred=_300;
+});
+ne(&quot;BrowserComplianceError&quot;,function(msg){
+this.message=msg;
+});
+ne(&quot;GenericError&quot;,function(msg){
+this.message=msg;
+});
+ne(&quot;XMLHttpRequestError&quot;,function(req,msg){
+this.req=req;
+this.message=msg;
+try{
+this.number=req.status;
+}
+catch(e){
+}
+});
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+m.nameFunctions(this);
 };
-
 MochiKit.Async.__new__();
-
-MochiKit.Base._exportSymbols(this, MochiKit.Async);
-
-/***
-
-MochiKit.DOM 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide(&quot;MochiKit.DOM&quot;);
-    dojo.require(&quot;MochiKit.Iter&quot;);
+MochiKit.Base._exportSymbols(this,MochiKit.Async);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.DOM&quot;);
+dojo.require(&quot;MochiKit.Iter&quot;);
 }
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Iter&quot;, []);
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Iter&quot;,[]);
 }
-
-try {
-    if (typeof(MochiKit.Iter) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.DOM depends on MochiKit.Iter!&quot;;
+try{
+if(typeof (MochiKit.Iter)==&quot;undefined&quot;){
+throw &quot;&quot;;
 }
-
-if (typeof(MochiKit.DOM) == 'undefined') {
-    MochiKit.DOM = {};
 }
-
-MochiKit.DOM.NAME = &quot;MochiKit.DOM&quot;;
-MochiKit.DOM.VERSION = &quot;1.3&quot;;
-MochiKit.DOM.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+catch(e){
+throw &quot;MochiKit.DOM depends on MochiKit.Iter!&quot;;
+}
+if(typeof (MochiKit.DOM)==&quot;undefined&quot;){
+MochiKit.DOM={};
+}
+MochiKit.DOM.NAME=&quot;MochiKit.DOM&quot;;
+MochiKit.DOM.VERSION=&quot;1.3&quot;;
+MochiKit.DOM.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-MochiKit.DOM.toString = function () {
-    return this.__repr__();
+MochiKit.DOM.toString=function(){
+return this.__repr__();
 };
-
-MochiKit.DOM.EXPORT = [
-    &quot;formContents&quot;,
-    &quot;currentWindow&quot;,
-    &quot;currentDocument&quot;,
-    &quot;withWindow&quot;,
-    &quot;withDocument&quot;,
-    &quot;registerDOMConverter&quot;,
-    &quot;coerceToDOM&quot;,
-    &quot;createDOM&quot;,
-    &quot;createDOMFunc&quot;,
-    &quot;getNodeAttribute&quot;,
-    &quot;setNodeAttribute&quot;,
-    &quot;updateNodeAttributes&quot;,
-    &quot;appendChildNodes&quot;,
-    &quot;replaceChildNodes&quot;,
-    &quot;removeElement&quot;,
-    &quot;swapDOM&quot;,
-    &quot;BUTTON&quot;,
-    &quot;TT&quot;,
-    &quot;PRE&quot;,
-    &quot;H1&quot;,
-    &quot;H2&quot;,
-    &quot;H3&quot;,
-    &quot;BR&quot;,
-    &quot;CANVAS&quot;,
-    &quot;HR&quot;,
-    &quot;LABEL&quot;,
-    &quot;TEXTAREA&quot;,
-    &quot;FORM&quot;,
-    &quot;STRONG&quot;,
-    &quot;SELECT&quot;,
-    &quot;OPTION&quot;,
-    &quot;OPTGROUP&quot;,
-    &quot;LEGEND&quot;,
-    &quot;FIELDSET&quot;,
-    &quot;P&quot;,
-    &quot;UL&quot;,
-    &quot;OL&quot;,
-    &quot;LI&quot;,
-    &quot;TD&quot;,
-    &quot;TR&quot;,
-    &quot;THEAD&quot;,
-    &quot;TBODY&quot;,
-    &quot;TFOOT&quot;,
-    &quot;TABLE&quot;,
-    &quot;TH&quot;,
-    &quot;INPUT&quot;,
-    &quot;SPAN&quot;,
-    &quot;A&quot;,
-    &quot;DIV&quot;,
-    &quot;IMG&quot;,
-    &quot;getElement&quot;,
-    &quot;$&quot;,
-    &quot;computedStyle&quot;,
-    &quot;getElementsByTagAndClassName&quot;,
-    &quot;addToCallStack&quot;,
-    &quot;addLoadEvent&quot;,
-    &quot;focusOnLoad&quot;,
-    &quot;setElementClass&quot;,
-    &quot;toggleElementClass&quot;,
-    &quot;addElementClass&quot;,
-    &quot;removeElementClass&quot;,
-    &quot;swapElementClass&quot;,
-    &quot;hasElementClass&quot;,
-    &quot;escapeHTML&quot;,
-    &quot;toHTML&quot;,
-    &quot;emitHTML&quot;,
-    &quot;setDisplayForElement&quot;,
-    &quot;hideElement&quot;,
-    &quot;showElement&quot;,
-    &quot;scrapeText&quot;,
-    &quot;elementDimensions&quot;,
-    &quot;elementPosition&quot;,
-    &quot;setElementDimensions&quot;,
-    &quot;setElementPosition&quot;,
-    &quot;getViewportDimensions&quot;,
-    &quot;setOpacity&quot;
-];
-
-MochiKit.DOM.EXPORT_OK = [
-    &quot;domConverters&quot;
-];
-
-MochiKit.DOM.Dimensions = function (w, h) {
-    this.w = w;
-    this.h = h;
+MochiKit.DOM.EXPORT=[&quot;formContents&quot;,&quot;currentWindow&quot;,&quot;currentDocument&quot;,&quot;withWindow&quot;,&quot;withDocument&quot;,&quot;registerDOMConverter&quot;,&quot;coerceToDOM&quot;,&quot;createDOM&quot;,&quot;createDOMFunc&quot;,&quot;getNodeAttribute&quot;,&quot;setNodeAttribute&quot;,&quot;updateNodeAttributes&quot;,&quot;appendChildNodes&quot;,&quot;replaceChildNodes&quot;,&quot;removeElement&quot;,&quot;swapDOM&quot;,&quot;BUTTON&quot;,&quot;TT&quot;,&quot;PRE&quot;,&quot;H1&quot;,&quot;H2&quot;,&quot;H3&quot;,&quot;BR&quot;,&quot;CANVAS&quot;,&quot;HR&quot;,&quot;LABEL&quot;,&quot;TEXTAREA&quot;,&quot;FORM&quot;,&quot;STRONG&quot;,&quot;SELECT&quot;,&quot;OPTION&quot;,&quot;OPTGROUP&quot;,&quot;LEGEND&quot;,&quot;FIELDSET&quot;,&quot;P&quot;,&quot;UL&quot;,&quot;OL&quot;,&quot;LI&quot;,&quot;TD&quot;,&quot;TR&quot;,&quot;THEAD&quot;,&quot;TBODY&quot;,&quot;TFOOT&quot;,&quot;TABLE&quot;,&quot;TH&quot;,&quot;INPUT&quot;,&quot;SPAN&quot;,&quot;A&quot;,&quot;DIV&quot;,&quot;IMG&quot;,&quot;getElement&quot;,&quot;$&quot;,&quot;computedStyle&quot;,&quot;getElementsByTagAndClassName&quot;,&quot;addToCallStack&quot;,&quot;addLoadEvent&quot;,&quot;focusOnLoad&quot;,&quot;setElementClass&quot;,&quot;toggleElementClass&quot;,&quot;addElementClass&quot;,&quot;removeElementClass&quot;,&quot;swapElementClass&quot;,&quot;hasElementClass&quot;,&quot;escapeHTML&quot;,&quot;toHTML&quot;,&quot;emitHTML&quot;,&quot;setDisplayForElement&quot;,&quot;hideElement&quot;,&quot;showElement&quot;,&quot;scrapeText&quot;,&quot;elementDimensions&quot;,&quot;elementPosition&quot;,&quot;setElementDimensions&quot;,&quot;setElementPosition&quot;,&quot;getViewportDimensions&quot;,&quot;setOpacity&quot;];
+MochiKit.DOM.EXPORT_OK=[&quot;domConverters&quot;];
+MochiKit.DOM.Dimensions=function(w,h){
+this.w=w;
+this.h=h;
 };
-
-MochiKit.DOM.Dimensions.prototype.repr = function () {
-    var repr = MochiKit.Base.repr;
-    return &quot;{w: &quot;  + repr(this.w) + &quot;, h: &quot; + repr(this.h) + &quot;}&quot;;
+MochiKit.DOM.Dimensions.prototype.repr=function(){
+var repr=MochiKit.Base.repr;
+return &quot;{w: &quot;+repr(this.w)+&quot;, h: &quot;+repr(this.h)+&quot;}&quot;;
 };
-
-MochiKit.DOM.Coordinates = function (x, y) {
-    this.x = x;
-    this.y = y;
+MochiKit.DOM.Coordinates=function(x,y){
+this.x=x;
+this.y=y;
 };
-
-MochiKit.DOM.Coordinates.prototype.repr = function () {
-    var repr = MochiKit.Base.repr;
-    return &quot;{x: &quot;  + repr(this.x) + &quot;, y: &quot; + repr(this.y) + &quot;}&quot;;
+MochiKit.DOM.Coordinates.prototype.repr=function(){
+var repr=MochiKit.Base.repr;
+return &quot;{x: &quot;+repr(this.x)+&quot;, y: &quot;+repr(this.y)+&quot;}&quot;;
 };
-
-MochiKit.Base.update(MochiKit.DOM, {
-
-    setOpacity: function(elem, o) {
-        elem = MochiKit.DOM.getElement(elem);
-        MochiKit.DOM.updateNodeAttributes(elem, {'style': {
-                'opacity': o,
-                '-moz-opacity': o,
-                '-khtml-opacity': o,
-                'filter':' alpha(opacity=' + (o * 100) + ')'
-            }});
-    },
-
-    getViewportDimensions: function() {
-        var d = new MochiKit.DOM.Dimensions();
-
-        var w = MochiKit.DOM._window;
-        var b = MochiKit.DOM._document.body;
-
-        if (w.innerWidth) {
-            d.w = w.innerWidth;
-            d.h = w.innerHeight;
-        } else if (b.parentElement.clientWidth) {
-            d.w = b.parentElement.clientWidth;
-            d.h = b.parentElement.clientHeight;
-        } else if (b &amp;&amp; b.clientWidth) {
-            d.w = b.clientWidth;
-            d.h = b.clientHeight;
-        }
-        return d;
-    },
-
-    elementDimensions: function (elem) {
-        var self = MochiKit.DOM;
-        if (typeof(elem.w) == 'number' || typeof(elem.h) == 'number') {
-            return new self.Dimensions(elem.w || 0, elem.h || 0);
-        }
-        elem = self.getElement(elem);
-        if (!elem) {
-            return undefined;
-        }
-        if (self.computedStyle(elem, 'display') != 'none') {
-            return new self.Dimensions(elem.offsetWidth || 0,
-                elem.offsetHeight || 0);
-        }
-        var s = elem.style;
-        var originalVisibility = s.visibility;
-        var originalPosition = s.position;
-        s.visibility = 'hidden';
-        s.position = 'absolute';
-        s.display = '';
-        var originalWidth = elem.offsetWidth;
-        var originalHeight = elem.offsetHeight;
-        s.display = 'none';
-        s.position = originalPosition;
-        s.visibility = originalVisibility;
-        return new self.Dimensions(originalWidth, originalHeight);
-    },
-
-    /*
-    elementPosition is adapted from YAHOO.util.Dom.getXY, version 0.9.0.
-    Copyright: Copyright (c) 2006, Yahoo! Inc. All rights reserved.
-    BSD License: <A HREF="http://developer.yahoo.net/yui/license.txt">http://developer.yahoo.net/yui/license.txt</A>
-    */
-    elementPosition: function (elem, /* optional */relativeTo) {
-        var self = MochiKit.DOM;
-        elem = self.getElement(elem);
-
-        if (!elem ||
-            elem.parentNode === null ||
-            self.computedStyle(elem, 'display') == 'none') {
-            return undefined;
-        }
-
-        var c = new self.Coordinates(0, 0);
-        var box = null;
-        var parent = null;
-
-        var d = MochiKit.DOM._document;
-
-        if (typeof(relativeTo) != 'undefined') {
-            relativeTo = arguments.callee(relativeTo);
-            if (relativeTo) {
-                c.x -= (relativeTo.x || 0);
-                c.y -= (relativeTo.y || 0);
-            }
-        }
-
-        if (elem.getBoundingClientRect) { // IE shortcut
-            box = elem.getBoundingClientRect();
-
-            c.x += box.left +
-                (d.documentElement.scrollLeft ||
-                d.body.scrollLeft);
-
-            c.y += box.top +
-                (d.documentElement.scrollTop ||
-                d.body.scrollTop);
-
-            return c;
-        } else if (d.getBoxObjectFor) { // Gecko shortcut
-            box = d.getBoxObjectFor(elem);
-            c.x += box.x;
-            c.y += box.y;
-        } else if (elem.offsetParent) {
-            c.x += elem.offsetLeft;
-            c.y += elem.offsetTop;
-            parent = elem.offsetParent;
-
-            if (parent != elem) {
-                while (parent) {
-                    c.x += parent.offsetLeft;
-                    c.y += parent.offsetTop;
-                    parent = parent.offsetParent;
-                }
-            }
-
-            // opera &amp; (safari absolute) incorrectly account for body offsetTop
-            var ua = navigator.userAgent.toLowerCase();
-            if (ua.indexOf('opera') != -1 ||
-                (ua.indexOf('safari') != -1 &amp;&amp;
-                self.computedStyle(elem, 'position') == 'absolute')) {
-
-                c.y -= d.body.offsetTop;
-
-            }
-        } else {
-            /* it's just a MochiKit.DOM.Coordinates object */
-            c.x += elem.x || 0;
-            c.y += elem.y || 0;
-            return c;
-        }
-
-        if (elem.parentNode) {
-            parent = elem.parentNode;
-        } else {
-            parent = null;
-        }
-
-        while (parent &amp;&amp; parent.tagName != 'BODY' &amp;&amp; parent.tagName != 'HTML') {
-            c.x -= parent.scrollLeft;
-            c.y -= parent.scrollTop;
-            if (parent.parentNode) {
-                parent = parent.parentNode;
-            } else {
-                parent = null;
-            }
-        }
-
-        return c;
-    },
-
-    setElementDimensions: function (elem, newSize/* optional */, units) {
-        elem = MochiKit.DOM.getElement(elem);
-        if (typeof(units) == 'undefined') {
-            units = 'px';
-        }
-        MochiKit.DOM.updateNodeAttributes(elem, {'style': {
-            'width': newSize.w + units,
-            'height': newSize.h + units
-        }});
-    },
-
-    setElementPosition: function (elem, newPos/* optional */, units) {
-        elem = MochiKit.DOM.getElement(elem);
-        if (typeof(units) == 'undefined') {
-            units = 'px';
-        }
-        MochiKit.DOM.updateNodeAttributes(elem, {'style': {
-            'left': newPos.x + units,
-            'top': newPos.y + units
-        }});
-    },
-
-    currentWindow: function () {
-        return MochiKit.DOM._window;
-    },
-
-    currentDocument: function () {
-        return MochiKit.DOM._document;
-    },
-
-    withWindow: function (win, func) {
-        var self = MochiKit.DOM;
-        var oldDoc = self._document;
-        var oldWin = self._win;
-        var rval;
-        try {
-            self._window = win;
-            self._document = win.document;
-            rval = func();
-        } catch (e) {
-            self._window = oldWin;
-            self._document = oldDoc;
-            throw e;
-        }
-        self._window = oldWin;
-        self._document = oldDoc;
-        return rval;
-    },
-
-    formContents: function (elem/* = document */) {
-        var names = [];
-        var values = [];
-        var m = MochiKit.Base;
-        var self = MochiKit.DOM;
-        if (typeof(elem) == &quot;undefined&quot; || elem === null) {
-            elem = self._document;
-        } else {
-            elem = self.getElement(elem);
-        }
-        m.nodeWalk(elem, function (elem) {
-            var name = elem.name;
-            if (m.isNotEmpty(name)) {
-                var tagName = elem.nodeName;
-                if (tagName == &quot;INPUT&quot;
-                    &amp;&amp; (elem.type == &quot;radio&quot; || elem.type == &quot;checkbox&quot;)
-                    &amp;&amp; !elem.checked
-                ) {
-                    return null;
-                }
-                if (tagName == &quot;SELECT&quot;) {
-                    if (elem.selectedIndex &gt;= 0) {
-                        var opt = elem.options[elem.selectedIndex];
-                        names.push(name);
-                        values.push((opt.value) ? opt.value : opt.text);
-                        return null;
-                    }
-                    // no form elements?
-                    names.push(name);
-                    values.push(&quot;&quot;);
-                    return null;
-                }
-                if (tagName == &quot;FORM&quot; || tagName == &quot;P&quot; || tagName == &quot;SPAN&quot;
-                    || tagName == &quot;DIV&quot;
-                ) {
-                    return elem.childNodes;
-                }
-                names.push(name);
-                values.push(elem.value || '');
-                return null;
-            }
-            return elem.childNodes;
-        });
-        return [names, values];
-    },
-
-    withDocument: function (doc, func) {
-        var self = MochiKit.DOM;
-        var oldDoc = self._document;
-        var rval;
-        try {
-            self._document = doc;
-            rval = func();
-        } catch (e) {
-            self._document = oldDoc;
-            throw e;
-        }
-        self._document = oldDoc;
-        return rval;
-    },
-
-    registerDOMConverter: function (name, check, wrap, /* optional */override) {
-        /***
-
-            Register an adapter to convert objects that match check(obj, ctx)
-            to a DOM element, or something that can be converted to a DOM
-            element (i.e. number, bool, string, function, iterable).
-
-        ***/
-        MochiKit.DOM.domConverters.register(name, check, wrap, override);
-    },
-
-    coerceToDOM: function (node, ctx) {
-        /***
-
-            Used internally by createDOM, coerces a node to null, a DOM object,
-            or an iterable.
-
-        ***/
-
-        var im = MochiKit.Iter;
-        var self = MochiKit.DOM;
-        var iter = im.iter;
-        var repeat = im.repeat;
-        var imap = im.imap;
-        var domConverters = self.domConverters;
-        var coerceToDOM = self.coerceToDOM;
-        var NotFound = MochiKit.Base.NotFound;
-        while (true) {
-            if (typeof(node) == 'undefined' || node === null) {
-                return null;
-            }
-            if (typeof(node.nodeType) != 'undefined' &amp;&amp; node.nodeType &gt; 0) {
-                return node;
-            }
-            if (typeof(node) == 'number' || typeof(node) == 'bool') {
-                node = node.toString();
-                // FALL THROUGH
-            }
-            if (typeof(node) == 'string') {
-                return self._document.createTextNode(node);
-            }
-            if (typeof(node.toDOM) == 'function') {
-                node = node.toDOM(ctx);
-                continue;
-            }
-            if (typeof(node) == 'function') {
-                node = node(ctx);
-                continue;
-            }
-
-            // iterable
-            var iterNodes = null;
-            try {
-                iterNodes = iter(node);
-            } catch (e) {
-                // pass
-            }
-            if (iterNodes) {
-                return imap(
-                    coerceToDOM,
-                    iterNodes,
-                    repeat(ctx)
-                );
-            }
-
-            // adapter
-            try {
-                node = domConverters.match(node, ctx);
-                continue;
-            } catch (e) {
-                if (e != NotFound) {
-                    throw e;
-                }
-            }
-
-            // fallback
-            return self._document.createTextNode(node.toString());
-        }
-        // mozilla warnings aren't too bright
-        return undefined;
-    },
-
-    setNodeAttribute: function (node, attr, value) {
-        var o = {};
-        o[attr] = value;
-        try {
-            return MochiKit.DOM.updateNodeAttributes(node, o);
-        } catch (e) {
-            // pass
-        }
-        return null;
-    },
-
-    getNodeAttribute: function (node, attr) {
-        var self = MochiKit.DOM;
-        var rename = self.attributeArray.renames[attr];
-        node = self.getElement(node);
-        try {
-            if (rename) {
-                return node[rename];
-            }
-            return node.getAttribute(attr);
-        } catch (e) {
-            // pass
-        }
-        return null;
-    },
-
-    updateNodeAttributes: function (node, attrs) {
-        var elem = node;
-        var self = MochiKit.DOM;
-        if (typeof(node) == 'string') {
-            elem = self.getElement(node);
-        }
-        if (attrs) {
-            var updatetree = MochiKit.Base.updatetree;
-            if (self.attributeArray.compliant) {
-                // not IE, good.
-                for (var k in attrs) {
-                    var v = attrs[k];
-                    if (typeof(v) == 'object' &amp;&amp; typeof(elem[k]) == 'object') {
-                        updatetree(elem[k], v);
-                    } else if (k.substring(0, 2) == &quot;on&quot;) {
-                        if (typeof(v) == &quot;string&quot;) {
-                            v = new Function(v);
-                        }
-                        elem[k] = v;
-                    } else {
-                        elem.setAttribute(k, v);
-                    }
-                }
-            } else {
-                // IE is insane in the membrane
-                var renames = self.attributeArray.renames;
-                for (k in attrs) {
-                    v = attrs[k];
-                    var renamed = renames[k];
-                    if (k == &quot;style&quot; &amp;&amp; typeof(v) == &quot;string&quot;) {
-                        elem.style.cssText = v;
-                    } else if (typeof(renamed) == &quot;string&quot;) {
-                        elem[renamed] = v;
-                    } else if (typeof(elem[k]) == 'object'
-                            &amp;&amp; typeof(v) == 'object') {
-                        updatetree(elem[k], v);
-                    } else if (k.substring(0, 2) == &quot;on&quot;) {
-                        if (typeof(v) == &quot;string&quot;) {
-                            v = new Function(v);
-                        }
-                        elem[k] = v;
-                    } else {
-                        elem.setAttribute(k, v);
-                    }
-                }
-            }
-        }
-        return elem;
-    },
-
-    appendChildNodes: function (node/*, nodes...*/) {
-        var elem = node;
-        var self = MochiKit.DOM;
-        if (typeof(node) == 'string') {
-            elem = self.getElement(node);
-        }
-        var nodeStack = [
-            self.coerceToDOM(
-                MochiKit.Base.extend(null, arguments, 1),
-                elem
-            )
-        ];
-        var concat = MochiKit.Base.concat;
-        while (nodeStack.length) {
-            var n = nodeStack.shift();
-            if (typeof(n) == 'undefined' || n === null) {
-                // pass
-            } else if (typeof(n.nodeType) == 'number') {
-                elem.appendChild(n);
-            } else {
-                nodeStack = concat(n, nodeStack);
-            }
-        }
-        return elem;
-    },
-
-    replaceChildNodes: function (node/*, nodes...*/) {
-        var elem = node;
-        var self = MochiKit.DOM;
-        if (typeof(node) == 'string') {
-            elem = self.getElement(node);
-            arguments[0] = elem;
-        }
-        var child;
-        while ((child = elem.firstChild)) {
-            elem.removeChild(child);
-        }
-        if (arguments.length &lt; 2) {
-            return elem;
-        } else {
-            return self.appendChildNodes.apply(this, arguments);
-        }
-    },
-
-    createDOM: function (name, attrs/*, nodes... */) {
-        /*
-
-            Create a DOM fragment in a really convenient manner, much like
-            Nevow's &lt;<A HREF="http://nevow.com">http://nevow.com</A>&gt; stan.
-
-        */
-
-        var elem;
-        var self = MochiKit.DOM;
-        if (typeof(name) == 'string') {
-            // Internet Explorer is dumb
-            if (attrs &amp;&amp; &quot;name&quot; in attrs &amp;&amp; !self.attributeArray.compliant) {
-                // <A HREF="http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/name_2.asp">http://msdn.microsoft.com/workshop/author/dhtml/reference/properties/name_2.asp</A>
-                name = ('&lt;' + name + ' name=&quot;' + self.escapeHTML(attrs.name)
-                    + '&quot;&gt;');
-            }
-            elem = self._document.createElement(name);
-        } else {
-            elem = name;
-        }
-        if (attrs) {
-            self.updateNodeAttributes(elem, attrs);
-        }
-        if (arguments.length &lt;= 2) {
-            return elem;
-        } else {
-            var args = MochiKit.Base.extend([elem], arguments, 2);
-            return self.appendChildNodes.apply(this, args);
-        }
-    },
-
-    createDOMFunc: function (/* tag, attrs, *nodes */) {
-        /***
-
-            Convenience function to create a partially applied createDOM
-
-            @param tag: The name of the tag
-
-            @param attrs: Optionally specify the attributes to apply
-
-            @param *notes: Optionally specify any children nodes it should have
-
-            @rtype: function
-
-        ***/
-        var m = MochiKit.Base;
-        return m.partial.apply(
-            this,
-            m.extend([MochiKit.DOM.createDOM], arguments)
-        );
-    },
-
-    swapDOM: function (dest, src) {
-        /***
-
-            Replace dest in a DOM tree with src, returning src
-
-            @param dest: a DOM element to be replaced
-
-            @param src: the DOM element to replace it with
-                        or null if the DOM element should be removed
-
-            @rtype: a DOM element (src)
-
-        ***/
-        var self = MochiKit.DOM;
-        dest = self.getElement(dest);
-        var parent = dest.parentNode;
-        if (src) {
-            src = self.getElement(src);
-            parent.replaceChild(src, dest);
-        } else {
-            parent.removeChild(dest);
-        }
-        return src;
-    },
-
-    getElement: function (id) {
-        /***
-
-            A small quick little function to encapsulate the getElementById
-            method.  It includes a check to ensure we can use that method.
-
-            If the id isn't a string, it will be returned as-is.
-
-            Also available as $(...) for compatibility/convenience with &quot;other&quot;
-            js frameworks (bah).
-
-        ***/
-        var self = MochiKit.DOM;
-        if (arguments.length == 1) {
-            return ((typeof(id) == &quot;string&quot;) ?
-                self._document.getElementById(id) : id);
-        } else {
-            return MochiKit.Base.map(self.getElement, arguments);
-        }
-    },
-
-    computedStyle: function (htmlElement, cssProperty, mozillaEquivalentCSS) {
-        if (arguments.length == 2) {
-            mozillaEquivalentCSS = cssProperty;
-        }
-        var self = MochiKit.DOM;
-        var el = self.getElement(htmlElement);
-        var document = self._document;
-        if (!el || el == document) {
-            return undefined;
-        }
-        if (el.currentStyle) {
-            return el.currentStyle[cssProperty];
-        }
-        if (typeof(document.defaultView) == 'undefined') {
-            return undefined;
-        }
-        if (document.defaultView === null) {
-            return undefined;
-        }
-        var style = document.defaultView.getComputedStyle(el, null);
-        if (typeof(style) == &quot;undefined&quot; || style === null) {
-            return undefined;
-        }
-        return style.getPropertyValue(mozillaEquivalentCSS);
-    },
-
-    getElementsByTagAndClassName: function (tagName, className,
-            /* optional */parent) {
-        var self = MochiKit.DOM;
-        if (typeof(tagName) == 'undefined' || tagName === null) {
-            tagName = '*';
-        }
-        if (typeof(parent) == 'undefined' || parent === null) {
-            parent = self._document;
-        }
-        parent = self.getElement(parent);
-        var children = (parent.getElementsByTagName(tagName)
-            || self._document.all);
-        if (typeof(className) == 'undefined' || className === null) {
-            return MochiKit.Base.extend(null, children);
-        }
-
-        var elements = [];
-        for (var i = 0; i &lt; children.length; i++) {
-            var child = children[i];
-            var classNames = child.className.split(' ');
-            for (var j = 0; j &lt; classNames.length; j++) {
-                if (classNames[j] == className) {
-                    elements.push(child);
-                    break;
-                }
-            }
-        }
-
-        return elements;
-    },
-
-    _newCallStack: function (path, once) {
-        var rval = function () {
-            var callStack = arguments.callee.callStack;
-            for (var i = 0; i &lt; callStack.length; i++) {
-                if (callStack[i].apply(this, arguments) === false) {
-                    break;
-                }
-            }
-            if (once) {
-                try {
-                    this[path] = null;
-                } catch (e) {
-                    // pass
-                }
-            }
-        };
-        rval.callStack = [];
-        return rval;
-    },
-
-    addToCallStack: function (target, path, func, once) {
-        var self = MochiKit.DOM;
-        var existing = target[path];
-        var regfunc = existing;
-        if (!(typeof(existing) == 'function'
-                &amp;&amp; typeof(existing.callStack) == &quot;object&quot;
-                &amp;&amp; existing.callStack !== null)) {
-            regfunc = self._newCallStack(path, once);
-            if (typeof(existing) == 'function') {
-                regfunc.callStack.push(existing);
-            }
-            target[path] = regfunc;
-        }
-        regfunc.callStack.push(func);
-    },
-
-    addLoadEvent: function (func) {
-        /***
-
-            This will stack load functions on top of each other.
-            Each function added will be called after onload in the
-            order that they were added.
-
-        ***/
-        var self = MochiKit.DOM;
-        self.addToCallStack(self._window, &quot;onload&quot;, func, true);
-
-    },
-
-    focusOnLoad: function (element) {
-        var self = MochiKit.DOM;
-        self.addLoadEvent(function () {
-            element = self.getElement(element);
-            if (element) {
-                element.focus();
-            }
-        });
-    },
-
-    setElementClass: function (element, className) {
-        /***
-
-            Set the entire class attribute of an element to className.
-
-        ***/
-        var self = MochiKit.DOM;
-        var obj = self.getElement(element);
-        if (self.attributeArray.compliant) {
-            obj.setAttribute(&quot;class&quot;, className);
-        } else {
-            obj.setAttribute(&quot;className&quot;, className);
-        }
-    },
-
-    toggleElementClass: function (className/*, element... */) {
-        /***
-
-            Toggle the presence of a given className in the class attribute
-            of all given elements.
-
-        ***/
-        var self = MochiKit.DOM;
-        for (var i = 1; i &lt; arguments.length; i++) {
-            var obj = self.getElement(arguments[i]);
-            if (!self.addElementClass(obj, className)) {
-                self.removeElementClass(obj, className);
-            }
-        }
-    },
-
-    addElementClass: function (element, className) {
-        /***
-
-            Ensure that the given element has className set as part of its
-            class attribute.  This will not disturb other class names.
-
-        ***/
-        var self = MochiKit.DOM;
-        var obj = self.getElement(element);
-        var cls = obj.className;
-        // trivial case, no className yet
-        if (cls.length === 0) {
-            self.setElementClass(obj, className);
-            return true;
-        }
-        // the other trivial case, already set as the only class
-        if (cls == className) {
-            return false;
-        }
-        var classes = obj.className.split(&quot; &quot;);
-        for (var i = 0; i &lt; classes.length; i++) {
-            // already present
-            if (classes[i] == className) {
-                return false;
-            }
-        }
-        // append class
-        self.setElementClass(obj, cls + &quot; &quot; + className);
-        return true;
-    },
-
-    removeElementClass: function (element, className) {
-        /***
-
-            Ensure that the given element does not have className set as part
-            of its class attribute.  This will not disturb other class names.
-
-        ***/
-        var self = MochiKit.DOM;
-        var obj = self.getElement(element);
-        var cls = obj.className;
-        // trivial case, no className yet
-        if (cls.length === 0) {
-            return false;
-        }
-        // other trivial case, set only to className
-        if (cls == className) {
-            self.setElementClass(obj, &quot;&quot;);
-            return true;
-        }
-        var classes = obj.className.split(&quot; &quot;);
-        for (var i = 0; i &lt; classes.length; i++) {
-            // already present
-            if (classes[i] == className) {
-                // only check sane case where the class is used once
-                classes.splice(i, 1);
-                self.setElementClass(obj, classes.join(&quot; &quot;));
-                return true;
-            }
-        }
-        // not found
-        return false;
-    },
-
-    swapElementClass: function (element, fromClass, toClass) {
-        /***
-
-            If fromClass is set on element, replace it with toClass.  This
-            will not disturb other classes on that element.
-
-        ***/
-        var obj = MochiKit.DOM.getElement(element);
-        var res = MochiKit.DOM.removeElementClass(obj, fromClass);
-        if (res) {
-            MochiKit.DOM.addElementClass(obj, toClass);
-        }
-        return res;
-    },
-
-    hasElementClass: function (element, className/*...*/) {
-        /***
-
-          Return true if className is found in the element
-
-        ***/
-        var obj = MochiKit.DOM.getElement(element);
-        var classes = obj.className.split(&quot; &quot;);
-        for (var i = 1; i &lt; arguments.length; i++) {
-            var good = false;
-            for (var j = 0; j &lt; classes.length; j++) {
-                if (classes[j] == arguments[i]) {
-                    good = true;
-                    break;
-                }
-            }
-            if (!good) {
-                return false;
-            }
-        }
-        return true;
-    },
-
-    escapeHTML: function (s) {
-        /***
-
-            Make a string safe for HTML, converting the usual suspects (lt,
-            gt, quot, amp)
-
-        ***/
-        return s.replace(/&amp;/g, &quot;&amp;&quot;
-            ).replace(/&quot;/g, &quot;&quot;&quot;
-            ).replace(/&lt;/g, &quot;&lt;&quot;
-            ).replace(/&gt;/g, &quot;&gt;&quot;);
-    },
-
-    toHTML: function (dom) {
-        /***
-
-            Convert a DOM tree to a HTML string using emitHTML
-
-        ***/
-        return MochiKit.DOM.emitHTML(dom).join(&quot;&quot;);
-    },
-
-    emitHTML: function (dom, /* optional */lst) {
-        /***
-
-            Convert a DOM tree to a list of HTML string fragments
-
-            You probably want to use toHTML instead.
-
-        ***/
-
-        if (typeof(lst) == 'undefined' || lst === null) {
-            lst = [];
-        }
-        // queue is the call stack, we're doing this non-recursively
-        var queue = [dom];
-        var self = MochiKit.DOM;
-        var escapeHTML = self.escapeHTML;
-        var attributeArray = self.attributeArray;
-        while (queue.length) {
-            dom = queue.pop();
-            if (typeof(dom) == 'string') {
-                lst.push(dom);
-            } else if (dom.nodeType == 1) {
-                // we're not using higher order stuff here
-                // because safari has heisenbugs.. argh.
-                //
-                // I think it might have something to do with
-                // garbage collection and function calls.
-                lst.push('&lt;' + dom.nodeName.toLowerCase());
-                var attributes = [];
-                var domAttr = attributeArray(dom);
-                for (var i = 0; i &lt; domAttr.length; i++) {
-                    var a = domAttr[i];
-                    attributes.push([
-                        &quot; &quot;,
-                        a.name,
-                        '=&quot;',
-                        escapeHTML(a.value),
-                        '&quot;'
-                    ]);
-                }
-                attributes.sort();
-                for (i = 0; i &lt; attributes.length; i++) {
-                    var attrs = attributes[i];
-                    for (var j = 0; j &lt; attrs.length; j++) {
-                        lst.push(attrs[j]);
-                    }
-                }
-                if (dom.hasChildNodes()) {
-                    lst.push(&quot;&gt;&quot;);
-                    // queue is the FILO call stack, so we put the close tag
-                    // on first
-                    queue.push(&quot;&lt;/&quot; + dom.nodeName.toLowerCase() + &quot;&gt;&quot;);
-                    var cnodes = dom.childNodes;
-                    for (i = cnodes.length - 1; i &gt;= 0; i--) {
-                        queue.push(cnodes[i]);
-                    }
-                } else {
-                    lst.push('/&gt;');
-                }
-            } else if (dom.nodeType == 3) {
-                lst.push(escapeHTML(dom.nodeValue));
-            }
-        }
-        return lst;
-    },
-
-    setDisplayForElement: function (display, element/*, ...*/) {
-        /***
-
-            Change the style.display for the given element(s).  Usually
-            used as the partial forms:
-
-                showElement(element, ...);
-                hideElement(element, ...);
-
-        ***/
-        var m = MochiKit.Base;
-        var elements = m.extend(null, arguments, 1);
-        MochiKit.Iter.forEach(
-            m.filter(null, m.map(MochiKit.DOM.getElement, elements)),
-            function (element) {
-                element.style.display = display;
-            }
-        );
-    },
-
-    scrapeText: function (node, /* optional */asArray) {
-        /***
-
-            Walk a DOM tree in-order and scrape all of the text out of it as a
-            string or an Array
-
-        ***/
-        var rval = [];
-        (function (node) {
-            var cn = node.childNodes;
-            if (cn) {
-                for (var i = 0; i &lt; cn.length; i++) {
-                    arguments.callee.call(this, cn[i]);
-                }
-            }
-            var nodeValue = node.nodeValue;
-            if (typeof(nodeValue) == 'string') {
-                rval.push(nodeValue);
-            }
-        })(MochiKit.DOM.getElement(node));
-        if (asArray) {
-            return rval;
-        } else {
-            return rval.join(&quot;&quot;);
-        }
-    },
-
-
-    __new__: function (win) {
-
-        var m = MochiKit.Base;
-        this._document = document;
-        this._window = win;
-
-        this.domConverters = new m.AdapterRegistry();
-
-        var __tmpElement = this._document.createElement(&quot;span&quot;);
-        var attributeArray;
-        if (__tmpElement &amp;&amp; __tmpElement.attributes &amp;&amp;
-                __tmpElement.attributes.length &gt; 0) {
-            // for braindead browsers (IE) that insert extra junk
-            var filter = m.filter;
-            attributeArray = function (node) {
-                return filter(attributeArray.ignoreAttrFilter, node.attributes);
-            };
-            attributeArray.ignoreAttr = {};
-            MochiKit.Iter.forEach(__tmpElement.attributes, function (a) {
-                attributeArray.ignoreAttr[a.name] = a.value;
-            });
-            attributeArray.ignoreAttrFilter = function (a) {
-                return (attributeArray.ignoreAttr[a.name] != a.value);
-            };
-            attributeArray.compliant = false;
-            attributeArray.renames = {
-                &quot;class&quot;: &quot;className&quot;,
-                &quot;checked&quot;: &quot;defaultChecked&quot;,
-                &quot;usemap&quot;: &quot;useMap&quot;,
-                &quot;for&quot;: &quot;htmlFor&quot;
-            };
-        } else {
-            attributeArray = function (node) {
-                /***
-
-                    Return an array of attributes for a given node,
-                    filtering out attributes that don't belong for
-                    that are inserted by &quot;Certain Browsers&quot;.
-
-                ***/
-                return node.attributes;
-            };
-            attributeArray.compliant = true;
-            attributeArray.renames = {};
-        }
-        this.attributeArray = attributeArray;
-
-
-        // shorthand for createDOM syntax
-        var createDOMFunc = this.createDOMFunc;
-        this.UL = createDOMFunc(&quot;ul&quot;);
-        this.OL = createDOMFunc(&quot;ol&quot;);
-        this.LI = createDOMFunc(&quot;li&quot;);
-        this.TD = createDOMFunc(&quot;td&quot;);
-        this.TR = createDOMFunc(&quot;tr&quot;);
-        this.TBODY = createDOMFunc(&quot;tbody&quot;);
-        this.THEAD = createDOMFunc(&quot;thead&quot;);
-        this.TFOOT = createDOMFunc(&quot;tfoot&quot;);
-        this.TABLE = createDOMFunc(&quot;table&quot;);
-        this.TH = createDOMFunc(&quot;th&quot;);
-        this.INPUT = createDOMFunc(&quot;input&quot;);
-        this.SPAN = createDOMFunc(&quot;span&quot;);
-        this.A = createDOMFunc(&quot;a&quot;);
-        this.DIV = createDOMFunc(&quot;div&quot;);
-        this.IMG = createDOMFunc(&quot;img&quot;);
-        this.BUTTON = createDOMFunc(&quot;button&quot;);
-        this.TT = createDOMFunc(&quot;tt&quot;);
-        this.PRE = createDOMFunc(&quot;pre&quot;);
-        this.H1 = createDOMFunc(&quot;h1&quot;);
-        this.H2 = createDOMFunc(&quot;h2&quot;);
-        this.H3 = createDOMFunc(&quot;h3&quot;);
-        this.BR = createDOMFunc(&quot;br&quot;);
-        this.HR = createDOMFunc(&quot;hr&quot;);
-        this.LABEL = createDOMFunc(&quot;label&quot;);
-        this.TEXTAREA = createDOMFunc(&quot;textarea&quot;);
-        this.FORM = createDOMFunc(&quot;form&quot;);
-        this.P = createDOMFunc(&quot;p&quot;);
-        this.SELECT = createDOMFunc(&quot;select&quot;);
-        this.OPTION = createDOMFunc(&quot;option&quot;);
-        this.OPTGROUP = createDOMFunc(&quot;optgroup&quot;);
-        this.LEGEND = createDOMFunc(&quot;legend&quot;);
-        this.FIELDSET = createDOMFunc(&quot;fieldset&quot;);
-        this.STRONG = createDOMFunc(&quot;strong&quot;);
-        this.CANVAS = createDOMFunc(&quot;canvas&quot;);
-
-        this.hideElement = m.partial(this.setDisplayForElement, &quot;none&quot;);
-        this.showElement = m.partial(this.setDisplayForElement, &quot;block&quot;);
-        this.removeElement = this.swapDOM;
-
-        this.$ = this.getElement;
-
-        this.EXPORT_TAGS = {
-            &quot;:common&quot;: this.EXPORT,
-            &quot;:all&quot;: m.concat(this.EXPORT, this.EXPORT_OK)
-        };
-
-        m.nameFunctions(this);
-
-    }
+MochiKit.Base.update(MochiKit.DOM,{setOpacity:function(elem,o){
+elem=MochiKit.DOM.getElement(elem);
+MochiKit.DOM.updateNodeAttributes(elem,{&quot;style&quot;:{&quot;opacity&quot;:o,&quot;-moz-opacity&quot;:o,&quot;-khtml-opacity&quot;:o,&quot;filter&quot;:&quot; alpha(opacity=&quot;+(o*100)+&quot;)&quot;}});
+},getViewportDimensions:function(){
+var d=new MochiKit.DOM.Dimensions();
+var w=MochiKit.DOM._window;
+var b=MochiKit.DOM._document.body;
+if(w.innerWidth){
+d.w=w.innerWidth;
+d.h=w.innerHeight;
+}else{
+if(b.parentElement.clientWidth){
+d.w=b.parentElement.clientWidth;
+d.h=b.parentElement.clientHeight;
+}else{
+if(b&amp;&amp;b.clientWidth){
+d.w=b.clientWidth;
+d.h=b.clientHeight;
+}
+}
+}
+return d;
+},elementDimensions:function(elem){
+var self=MochiKit.DOM;
+if(typeof (elem.w)==&quot;number&quot;||typeof (elem.h)==&quot;number&quot;){
+return new self.Dimensions(elem.w||0,elem.h||0);
+}
+elem=self.getElement(elem);
+if(!elem){
+return undefined;
+}
+if(self.computedStyle(elem,&quot;display&quot;)!=&quot;none&quot;){
+return new self.Dimensions(elem.offsetWidth||0,elem.offsetHeight||0);
+}
+var s=elem.style;
+var _305=s.visibility;
+var _306=s.position;
+s.visibility=&quot;hidden&quot;;
+s.position=&quot;absolute&quot;;
+s.display=&quot;&quot;;
+var _307=elem.offsetWidth;
+var _308=elem.offsetHeight;
+s.display=&quot;none&quot;;
+s.position=_306;
+s.visibility=_305;
+return new self.Dimensions(_307,_308);
+},elementPosition:function(elem,_309){
+var self=MochiKit.DOM;
+elem=self.getElement(elem);
+if(!elem||elem.parentNode===null||self.computedStyle(elem,&quot;display&quot;)==&quot;none&quot;){
+return undefined;
+}
+var c=new self.Coordinates(0,0);
+var box=null;
+var _312=null;
+var d=MochiKit.DOM._document;
+if(typeof (_309)!=&quot;undefined&quot;){
+_309=arguments.callee(_309);
+if(_309){
+c.x-=(_309.x||0);
+c.y-=(_309.y||0);
+}
+}
+if(elem.getBoundingClientRect){
+box=elem.getBoundingClientRect();
+c.x+=box.left+(d.documentElement.scrollLeft||d.body.scrollLeft);
+c.y+=box.top+(d.documentElement.scrollTop||d.body.scrollTop);
+return c;
+}else{
+if(d.getBoxObjectFor){
+box=d.getBoxObjectFor(elem);
+c.x+=box.x;
+c.y+=box.y;
+}else{
+if(elem.offsetParent){
+c.x+=elem.offsetLeft;
+c.y+=elem.offsetTop;
+_312=elem.offsetParent;
+if(_312!=elem){
+while(_312){
+c.x+=_312.offsetLeft;
+c.y+=_312.offsetTop;
+_312=_312.offsetParent;
+}
+}
+var ua=navigator.userAgent.toLowerCase();
+if(ua.indexOf(&quot;opera&quot;)!=-1||(ua.indexOf(&quot;safari&quot;)!=-1&amp;&amp;self.computedStyle(elem,&quot;position&quot;)==&quot;absolute&quot;)){
+c.y-=d.body.offsetTop;
+}
+}else{
+c.x+=elem.x||0;
+c.y+=elem.y||0;
+return c;
+}
+}
+}
+if(elem.parentNode){
+_312=elem.parentNode;
+}else{
+_312=null;
+}
+while(_312&amp;&amp;_312.tagName!=&quot;BODY&quot;&amp;&amp;_312.tagName!=&quot;HTML&quot;){
+c.x-=_312.scrollLeft;
+c.y-=_312.scrollTop;
+if(_312.parentNode){
+_312=_312.parentNode;
+}else{
+_312=null;
+}
+}
+return c;
+},setElementDimensions:function(elem,_314,_315){
+elem=MochiKit.DOM.getElement(elem);
+if(typeof (_315)==&quot;undefined&quot;){
+_315=&quot;px&quot;;
+}
+MochiKit.DOM.updateNodeAttributes(elem,{&quot;style&quot;:{&quot;width&quot;:_314.w+_315,&quot;height&quot;:_314.h+_315}});
+},setElementPosition:function(elem,_316,_317){
+elem=MochiKit.DOM.getElement(elem);
+if(typeof (_317)==&quot;undefined&quot;){
+_317=&quot;px&quot;;
+}
+MochiKit.DOM.updateNodeAttributes(elem,{&quot;style&quot;:{&quot;left&quot;:_316.x+_317,&quot;top&quot;:_316.y+_317}});
+},currentWindow:function(){
+return MochiKit.DOM._window;
+},currentDocument:function(){
+return MochiKit.DOM._document;
+},withWindow:function(win,func){
+var self=MochiKit.DOM;
+var _319=self._document;
+var _320=self._win;
+var rval;
+try{
+self._window=win;
+self._document=win.document;
+rval=func();
+}
+catch(e){
+self._window=_320;
+self._document=_319;
+throw e;
+}
+self._window=_320;
+self._document=_319;
+return rval;
+},formContents:function(elem){
+var _321=[];
+var _322=[];
+var m=MochiKit.Base;
+var self=MochiKit.DOM;
+if(typeof (elem)==&quot;undefined&quot;||elem===null){
+elem=self._document;
+}else{
+elem=self.getElement(elem);
+}
+m.nodeWalk(elem,function(elem){
+var name=elem.name;
+if(m.isNotEmpty(name)){
+var _323=elem.nodeName;
+if(_323==&quot;INPUT&quot;&amp;&amp;(elem.type==&quot;radio&quot;||elem.type==&quot;checkbox&quot;)&amp;&amp;!elem.checked){
+return null;
+}
+if(_323==&quot;SELECT&quot;){
+if(elem.selectedIndex&gt;=0){
+var opt=elem.options[elem.selectedIndex];
+_321.push(name);
+_322.push((opt.value)?opt.value:opt.text);
+return null;
+}
+_321.push(name);
+_322.push(&quot;&quot;);
+return null;
+}
+if(_323==&quot;FORM&quot;||_323==&quot;P&quot;||_323==&quot;SPAN&quot;||_323==&quot;DIV&quot;){
+return elem.childNodes;
+}
+_321.push(name);
+_322.push(elem.value||&quot;&quot;);
+return null;
+}
+return elem.childNodes;
 });
-
+return [_321,_322];
+},withDocument:function(doc,func){
+var self=MochiKit.DOM;
+var _326=self._document;
+var rval;
+try{
+self._document=doc;
+rval=func();
+}
+catch(e){
+self._document=_326;
+throw e;
+}
+self._document=_326;
+return rval;
+},registerDOMConverter:function(name,_327,wrap,_328){
+MochiKit.DOM.domConverters.register(name,_327,wrap,_328);
+},coerceToDOM:function(node,ctx){
+var im=MochiKit.Iter;
+var self=MochiKit.DOM;
+var iter=im.iter;
+var _332=im.repeat;
+var imap=im.imap;
+var _334=self.domConverters;
+var _335=self.coerceToDOM;
+var _336=MochiKit.Base.NotFound;
+while(true){
+if(typeof (node)==&quot;undefined&quot;||node===null){
+return null;
+}
+if(typeof (node.nodeType)!=&quot;undefined&quot;&amp;&amp;node.nodeType&gt;0){
+return node;
+}
+if(typeof (node)==&quot;number&quot;||typeof (node)==&quot;bool&quot;){
+node=node.toString();
+}
+if(typeof (node)==&quot;string&quot;){
+return self._document.createTextNode(node);
+}
+if(typeof (node.toDOM)==&quot;function&quot;){
+node=node.toDOM(ctx);
+continue;
+}
+if(typeof (node)==&quot;function&quot;){
+node=node(ctx);
+continue;
+}
+var _337=null;
+try{
+_337=iter(node);
+}
+catch(e){
+}
+if(_337){
+return imap(_335,_337,_332(ctx));
+}
+try{
+node=_334.match(node,ctx);
+continue;
+}
+catch(e){
+if(e!=_336){
+throw e;
+}
+}
+return self._document.createTextNode(node.toString());
+}
+return undefined;
+},setNodeAttribute:function(node,attr,_339){
+var o={};
+o[attr]=_339;
+try{
+return MochiKit.DOM.updateNodeAttributes(node,o);
+}
+catch(e){
+}
+return null;
+},getNodeAttribute:function(node,attr){
+var self=MochiKit.DOM;
+var _340=self.attributeArray.renames[attr];
+node=self.getElement(node);
+try{
+if(_340){
+return node[_340];
+}
+return node.getAttribute(attr);
+}
+catch(e){
+}
+return null;
+},updateNodeAttributes:function(node,_341){
+var elem=node;
+var self=MochiKit.DOM;
+if(typeof (node)==&quot;string&quot;){
+elem=self.getElement(node);
+}
+if(_341){
+var _342=MochiKit.Base.updatetree;
+if(self.attributeArray.compliant){
+for(var k in _341){
+var v=_341[k];
+if(typeof (v)==&quot;object&quot;&amp;&amp;typeof (elem[k])==&quot;object&quot;){
+_342(elem[k],v);
+}else{
+if(k.substring(0,2)==&quot;on&quot;){
+if(typeof (v)==&quot;string&quot;){
+v=new Function(v);
+}
+elem[k]=v;
+}else{
+elem.setAttribute(k,v);
+}
+}
+}
+}else{
+var _343=self.attributeArray.renames;
+for(k in _341){
+v=_341[k];
+var _344=_343[k];
+if(k==&quot;style&quot;&amp;&amp;typeof (v)==&quot;string&quot;){
+elem.style.cssText=v;
+}else{
+if(typeof (_344)==&quot;string&quot;){
+elem[_344]=v;
+}else{
+if(typeof (elem[k])==&quot;object&quot;&amp;&amp;typeof (v)==&quot;object&quot;){
+_342(elem[k],v);
+}else{
+if(k.substring(0,2)==&quot;on&quot;){
+if(typeof (v)==&quot;string&quot;){
+v=new Function(v);
+}
+elem[k]=v;
+}else{
+elem.setAttribute(k,v);
+}
+}
+}
+}
+}
+}
+}
+return elem;
+},appendChildNodes:function(node){
+var elem=node;
+var self=MochiKit.DOM;
+if(typeof (node)==&quot;string&quot;){
+elem=self.getElement(node);
+}
+var _345=[self.coerceToDOM(MochiKit.Base.extend(null,arguments,1),elem)];
+var _346=MochiKit.Base.concat;
+while(_345.length){
+var n=_345.shift();
+if(typeof (n)==&quot;undefined&quot;||n===null){
+}else{
+if(typeof (n.nodeType)==&quot;number&quot;){
+elem.appendChild(n);
+}else{
+_345=_346(n,_345);
+}
+}
+}
+return elem;
+},replaceChildNodes:function(node){
+var elem=node;
+var self=MochiKit.DOM;
+if(typeof (node)==&quot;string&quot;){
+elem=self.getElement(node);
+arguments[0]=elem;
+}
+var _347;
+while((_347=elem.firstChild)){
+elem.removeChild(_347);
+}
+if(arguments.length&lt;2){
+return elem;
+}else{
+return self.appendChildNodes.apply(this,arguments);
+}
+},createDOM:function(name,_348){
+var elem;
+var self=MochiKit.DOM;
+if(typeof (name)==&quot;string&quot;){
+if(_348&amp;&amp;&quot;name&quot; in _348&amp;&amp;!self.attributeArray.compliant){
+name=(&quot;&lt;&quot;+name+&quot; name=\&quot;&quot;+self.escapeHTML(_348.name)+&quot;\&quot;&gt;&quot;);
+}
+elem=self._document.createElement(name);
+}else{
+elem=name;
+}
+if(_348){
+self.updateNodeAttributes(elem,_348);
+}
+if(arguments.length&lt;=2){
+return elem;
+}else{
+var args=MochiKit.Base.extend([elem],arguments,2);
+return self.appendChildNodes.apply(this,args);
+}
+},createDOMFunc:function(){
+var m=MochiKit.Base;
+return m.partial.apply(this,m.extend([MochiKit.DOM.createDOM],arguments));
+},swapDOM:function(dest,src){
+var self=MochiKit.DOM;
+dest=self.getElement(dest);
+var _351=dest.parentNode;
+if(src){
+src=self.getElement(src);
+_351.replaceChild(src,dest);
+}else{
+_351.removeChild(dest);
+}
+return src;
+},getElement:function(id){
+var self=MochiKit.DOM;
+if(arguments.length==1){
+return ((typeof (id)==&quot;string&quot;)?self._document.getElementById(id):id);
+}else{
+return MochiKit.Base.map(self.getElement,arguments);
+}
+},computedStyle:function(_353,_354,_355){
+if(arguments.length==2){
+_355=_354;
+}
+var self=MochiKit.DOM;
+var el=self.getElement(_353);
+var _357=self._document;
+if(!el||el==_357){
+return undefined;
+}
+if(el.currentStyle){
+return el.currentStyle[_354];
+}
+if(typeof (_357.defaultView)==&quot;undefined&quot;){
+return undefined;
+}
+if(_357.defaultView===null){
+return undefined;
+}
+var _358=_357.defaultView.getComputedStyle(el,null);
+if(typeof (_358)==&quot;undefined&quot;||_358===null){
+return undefined;
+}
+return _358.getPropertyValue(_355);
+},getElementsByTagAndClassName:function(_359,_360,_361){
+var self=MochiKit.DOM;
+if(typeof (_359)==&quot;undefined&quot;||_359===null){
+_359=&quot;*&quot;;
+}
+if(typeof (_361)==&quot;undefined&quot;||_361===null){
+_361=self._document;
+}
+_361=self.getElement(_361);
+var _362=(_361.getElementsByTagName(_359)||self._document.all);
+if(typeof (_360)==&quot;undefined&quot;||_360===null){
+return MochiKit.Base.extend(null,_362);
+}
+var _363=[];
+for(var i=0;i&lt;_362.length;i++){
+var _364=_362[i];
+var _365=_364.className.split(&quot; &quot;);
+for(var j=0;j&lt;_365.length;j++){
+if(_365[j]==_360){
+_363.push(_364);
+break;
+}
+}
+}
+return _363;
+},_newCallStack:function(path,once){
+var rval=function(){
+var _368=arguments.callee.callStack;
+for(var i=0;i&lt;_368.length;i++){
+if(_368[i].apply(this,arguments)===false){
+break;
+}
+}
+if(once){
+try{
+this[path]=null;
+}
+catch(e){
+}
+}
+};
+rval.callStack=[];
+return rval;
+},addToCallStack:function(_369,path,func,once){
+var self=MochiKit.DOM;
+var _370=_369[path];
+var _371=_370;
+if(!(typeof (_370)==&quot;function&quot;&amp;&amp;typeof (_370.callStack)==&quot;object&quot;&amp;&amp;_370.callStack!==null)){
+_371=self._newCallStack(path,once);
+if(typeof (_370)==&quot;function&quot;){
+_371.callStack.push(_370);
+}
+_369[path]=_371;
+}
+_371.callStack.push(func);
+},addLoadEvent:function(func){
+var self=MochiKit.DOM;
+self.addToCallStack(self._window,&quot;onload&quot;,func,true);
+},focusOnLoad:function(_372){
+var self=MochiKit.DOM;
+self.addLoadEvent(function(){
+_372=self.getElement(_372);
+if(_372){
+_372.focus();
+}
+});
+},setElementClass:function(_373,_374){
+var self=MochiKit.DOM;
+var obj=self.getElement(_373);
+if(self.attributeArray.compliant){
+obj.setAttribute(&quot;class&quot;,_374);
+}else{
+obj.setAttribute(&quot;className&quot;,_374);
+}
+},toggleElementClass:function(_375){
+var self=MochiKit.DOM;
+for(var i=1;i&lt;arguments.length;i++){
+var obj=self.getElement(arguments[i]);
+if(!self.addElementClass(obj,_375)){
+self.removeElementClass(obj,_375);
+}
+}
+},addElementClass:function(_376,_377){
+var self=MochiKit.DOM;
+var obj=self.getElement(_376);
+var cls=obj.className;
+if(cls.length===0){
+self.setElementClass(obj,_377);
+return true;
+}
+if(cls==_377){
+return false;
+}
+var _379=obj.className.split(&quot; &quot;);
+for(var i=0;i&lt;_379.length;i++){
+if(_379[i]==_377){
+return false;
+}
+}
+self.setElementClass(obj,cls+&quot; &quot;+_377);
+return true;
+},removeElementClass:function(_380,_381){
+var self=MochiKit.DOM;
+var obj=self.getElement(_380);
+var cls=obj.className;
+if(cls.length===0){
+return false;
+}
+if(cls==_381){
+self.setElementClass(obj,&quot;&quot;);
+return true;
+}
+var _382=obj.className.split(&quot; &quot;);
+for(var i=0;i&lt;_382.length;i++){
+if(_382[i]==_381){
+_382.splice(i,1);
+self.setElementClass(obj,_382.join(&quot; &quot;));
+return true;
+}
+}
+return false;
+},swapElementClass:function(_383,_384,_385){
+var obj=MochiKit.DOM.getElement(_383);
+var res=MochiKit.DOM.removeElementClass(obj,_384);
+if(res){
+MochiKit.DOM.addElementClass(obj,_385);
+}
+return res;
+},hasElementClass:function(_386,_387){
+var obj=MochiKit.DOM.getElement(_386);
+var _388=obj.className.split(&quot; &quot;);
+for(var i=1;i&lt;arguments.length;i++){
+var good=false;
+for(var j=0;j&lt;_388.length;j++){
+if(_388[j]==arguments[i]){
+good=true;
+break;
+}
+}
+if(!good){
+return false;
+}
+}
+return true;
+},escapeHTML:function(s){
+return s.replace(/&amp;/g,&quot;&amp;&quot;).replace(/&quot;/g,&quot;&quot;&quot;).replace(/&lt;/g,&quot;&lt;&quot;).replace(/&gt;/g,&quot;&gt;&quot;);
+},toHTML:function(dom){
+return MochiKit.DOM.emitHTML(dom).join(&quot;&quot;);
+},emitHTML:function(dom,lst){
+if(typeof (lst)==&quot;undefined&quot;||lst===null){
+lst=[];
+}
+var _391=[dom];
+var self=MochiKit.DOM;
+var _392=self.escapeHTML;
+var _393=self.attributeArray;
+while(_391.length){
+dom=_391.pop();
+if(typeof (dom)==&quot;string&quot;){
+lst.push(dom);
+}else{
+if(dom.nodeType==1){
+lst.push(&quot;&lt;&quot;+dom.nodeName.toLowerCase());
+var _394=[];
+var _395=_393(dom);
+for(var i=0;i&lt;_395.length;i++){
+var a=_395[i];
+_394.push([&quot; &quot;,a.name,&quot;=\&quot;&quot;,_392(a.value),&quot;\&quot;&quot;]);
+}
+_394.sort();
+for(i=0;i&lt;_394.length;i++){
+var _396=_394[i];
+for(var j=0;j&lt;_396.length;j++){
+lst.push(_396[j]);
+}
+}
+if(dom.hasChildNodes()){
+lst.push(&quot;&gt;&quot;);
+_391.push(&quot;&lt;/&quot;+dom.nodeName.toLowerCase()+&quot;&gt;&quot;);
+var _397=dom.childNodes;
+for(i=_397.length-1;i&gt;=0;i--){
+_391.push(_397[i]);
+}
+}else{
+lst.push(&quot;/&gt;&quot;);
+}
+}else{
+if(dom.nodeType==3){
+lst.push(_392(dom.nodeValue));
+}
+}
+}
+}
+return lst;
+},setDisplayForElement:function(_398,_399){
+var m=MochiKit.Base;
+var _400=m.extend(null,arguments,1);
+MochiKit.Iter.forEach(m.filter(null,m.map(MochiKit.DOM.getElement,_400)),function(_399){
+_399.style.display=_398;
+});
+},scrapeText:function(node,_401){
+var rval=[];
+(function(node){
+var cn=node.childNodes;
+if(cn){
+for(var i=0;i&lt;cn.length;i++){
+arguments.callee.call(this,cn[i]);
+}
+}
+var _403=node.nodeValue;
+if(typeof (_403)==&quot;string&quot;){
+rval.push(_403);
+}
+})(MochiKit.DOM.getElement(node));
+if(_401){
+return rval;
+}else{
+return rval.join(&quot;&quot;);
+}
+},__new__:function(win){
+var m=MochiKit.Base;
+this._document=document;
+this._window=win;
+this.domConverters=new m.AdapterRegistry();
+var _404=this._document.createElement(&quot;span&quot;);
+var _405;
+if(_404&amp;&amp;_404.attributes&amp;&amp;_404.attributes.length&gt;0){
+var _406=m.filter;
+_405=function(node){
+return _406(_405.ignoreAttrFilter,node.attributes);
+};
+_405.ignoreAttr={};
+MochiKit.Iter.forEach(_404.attributes,function(a){
+_405.ignoreAttr[a.name]=a.value;
+});
+_405.ignoreAttrFilter=function(a){
+return (_405.ignoreAttr[a.name]!=a.value);
+};
+_405.compliant=false;
+_405.renames={&quot;class&quot;:&quot;className&quot;,&quot;checked&quot;:&quot;defaultChecked&quot;,&quot;usemap&quot;:&quot;useMap&quot;,&quot;for&quot;:&quot;htmlFor&quot;};
+}else{
+_405=function(node){
+return node.attributes;
+};
+_405.compliant=true;
+_405.renames={};
+}
+this.attributeArray=_405;
+var _407=this.createDOMFunc;
+this.UL=_407(&quot;ul&quot;);
+this.OL=_407(&quot;ol&quot;);
+this.LI=_407(&quot;li&quot;);
+this.TD=_407(&quot;td&quot;);
+this.TR=_407(&quot;tr&quot;);
+this.TBODY=_407(&quot;tbody&quot;);
+this.THEAD=_407(&quot;thead&quot;);
+this.TFOOT=_407(&quot;tfoot&quot;);
+this.TABLE=_407(&quot;table&quot;);
+this.TH=_407(&quot;th&quot;);
+this.INPUT=_407(&quot;input&quot;);
+this.SPAN=_407(&quot;span&quot;);
+this.A=_407(&quot;a&quot;);
+this.DIV=_407(&quot;div&quot;);
+this.IMG=_407(&quot;img&quot;);
+this.BUTTON=_407(&quot;button&quot;);
+this.TT=_407(&quot;tt&quot;);
+this.PRE=_407(&quot;pre&quot;);
+this.H1=_407(&quot;h1&quot;);
+this.H2=_407(&quot;h2&quot;);
+this.H3=_407(&quot;h3&quot;);
+this.BR=_407(&quot;br&quot;);
+this.HR=_407(&quot;hr&quot;);
+this.LABEL=_407(&quot;label&quot;);
+this.TEXTAREA=_407(&quot;textarea&quot;);
+this.FORM=_407(&quot;form&quot;);
+this.P=_407(&quot;p&quot;);
+this.SELECT=_407(&quot;select&quot;);
+this.OPTION=_407(&quot;option&quot;);
+this.OPTGROUP=_407(&quot;optgroup&quot;);
+this.LEGEND=_407(&quot;legend&quot;);
+this.FIELDSET=_407(&quot;fieldset&quot;);
+this.STRONG=_407(&quot;strong&quot;);
+this.CANVAS=_407(&quot;canvas&quot;);
+this.hideElement=m.partial(this.setDisplayForElement,&quot;none&quot;);
+this.showElement=m.partial(this.setDisplayForElement,&quot;block&quot;);
+this.removeElement=this.swapDOM;
+this.$=this.getElement;
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+m.nameFunctions(this);
+}});
 MochiKit.DOM.__new__(this);
-
-//
-// XXX: Internet Explorer blows
-//
-withWindow = MochiKit.DOM.withWindow;
-withDocument = MochiKit.DOM.withDocument;
-
-MochiKit.Base._exportSymbols(this, MochiKit.DOM);
-
-/***
-
-MochiKit.LoggingPane 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito.  All rights Reserved.
-
-***/
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.LoggingPane');
-    dojo.require('MochiKit.Logging');
-    dojo.require('MochiKit.Base');
+withWindow=MochiKit.DOM.withWindow;
+withDocument=MochiKit.DOM.withDocument;
+MochiKit.Base._exportSymbols(this,MochiKit.DOM);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.LoggingPane&quot;);
+dojo.require(&quot;MochiKit.Logging&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
 }
-
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Logging&quot;, []);
-    JSAN.use(&quot;MochiKit.Base&quot;, []);
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Logging&quot;,[]);
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
 }
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined' || typeof(MochiKit.Logging) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.LoggingPane depends on MochiKit.Base and MochiKit.Logging!&quot;;
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;||typeof (MochiKit.Logging)==&quot;undefined&quot;){
+throw &quot;&quot;;
 }
-
-if (typeof(MochiKit.LoggingPane) == 'undefined') {
-    MochiKit.LoggingPane = {};
 }
-
-MochiKit.LoggingPane.NAME = &quot;MochiKit.LoggingPane&quot;;
-MochiKit.LoggingPane.VERSION = &quot;1.3&quot;;
-MochiKit.LoggingPane.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+catch(e){
+throw &quot;MochiKit.LoggingPane depends on MochiKit.Base and MochiKit.Logging!&quot;;
+}
+if(typeof (MochiKit.LoggingPane)==&quot;undefined&quot;){
+MochiKit.LoggingPane={};
+}
+MochiKit.LoggingPane.NAME=&quot;MochiKit.LoggingPane&quot;;
+MochiKit.LoggingPane.VERSION=&quot;1.3&quot;;
+MochiKit.LoggingPane.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-
-MochiKit.LoggingPane.toString = function () {
-    return this.__repr__();
+MochiKit.LoggingPane.toString=function(){
+return this.__repr__();
 };
-
-MochiKit.LoggingPane.createLoggingPane = function (inline/* = false */) {
-    var m = MochiKit.LoggingPane;
-    inline = !(!inline);
-    if (m._loggingPane &amp;&amp; m._loggingPane.inline != inline) {
-        m._loggingPane.closePane();
-        m._loggingPane = null;
-    }
-    if (!m._loggingPane || m._loggingPane.closed) {
-        m._loggingPane = new m.LoggingPane(inline, MochiKit.Logging.logger);
-    }
-    return m._loggingPane;
+MochiKit.LoggingPane.createLoggingPane=function(_408){
+var m=MochiKit.LoggingPane;
+_408=!(!_408);
+if(m._loggingPane&amp;&amp;m._loggingPane.inline!=_408){
+m._loggingPane.closePane();
+m._loggingPane=null;
+}
+if(!m._loggingPane||m._loggingPane.closed){
+m._loggingPane=new m.LoggingPane(_408,MochiKit.Logging.logger);
+}
+return m._loggingPane;
 };
-
-MochiKit.LoggingPane.LoggingPane = function (inline/* = false */, logger/* = MochiKit.Logging.logger */) {
-    /* Use a div if inline, pop up a window if not */
-    /* Create the elements */
-    if (typeof(logger) == &quot;undefined&quot; || logger == null) {
-        logger = MochiKit.Logging.logger;
-    }
-    this.logger = logger;
-    var update = MochiKit.Base.update;
-    var updatetree = MochiKit.Base.updatetree;
-    var bind = MochiKit.Base.bind;
-    var clone = MochiKit.Base.clone;
-    var win = window;
-    var uid = &quot;_MochiKit_LoggingPane&quot;;
-    if (typeof(MochiKit.DOM) != &quot;undefined&quot;) {
-        win = MochiKit.DOM.currentWindow();
-    }
-    if (!inline) {
-        // name the popup with the base URL for uniqueness
-        var url = win.location.href.split(&quot;?&quot;)[0].replace(/[:\/.&gt;&lt;&amp;]/g, &quot;_&quot;);
-        var name = uid + &quot;_&quot; + url;
-        var nwin = win.open(&quot;&quot;, name, &quot;dependent,resizable,height=200&quot;);
-        if (!nwin) {
-            alert(&quot;Not able to open debugging window due to pop-up blocking.&quot;);
-            return undefined;
-        }
-        nwin.document.write(
-            '&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; '
-            + '&quot;<A HREF="http://www.w3.org/TR/html4/loose.dtd">http://www.w3.org/TR/html4/loose.dtd</A>&quot;&gt;'
-            + '&lt;html&gt;&lt;head&gt;&lt;title&gt;[MochiKit.LoggingPane]&lt;/title&gt;&lt;/head&gt;'
-            + '&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'
-        );
-        nwin.document.close();
-        nwin.document.title += ' ' + win.document.title;
-        win = nwin;
-    }
-    var doc = win.document;
-    this.doc = doc;
-
-    // Connect to the debug pane if it already exists (i.e. in a window orphaned by the page being refreshed)
-    var debugPane = doc.getElementById(uid);
-    var existing_pane = !!debugPane;
-    if (debugPane &amp;&amp; typeof(debugPane.loggingPane) != &quot;undefined&quot;) {
-        debugPane.loggingPane.logger = this.logger;
-        debugPane.loggingPane.buildAndApplyFilter();
-        return debugPane.loggingPane;
-    }
-
-    if (existing_pane) {
-        // clear any existing contents
-        var child;
-        while ((child = debugPane.firstChild)) {
-            debugPane.removeChild(child);
-        }
-    } else {
-        debugPane = doc.createElement(&quot;div&quot;);
-        debugPane.id = uid;
-    }
-    debugPane.loggingPane = this;
-    var levelFilterField = doc.createElement(&quot;input&quot;);
-    var infoFilterField = doc.createElement(&quot;input&quot;);
-    var filterButton = doc.createElement(&quot;button&quot;);
-    var loadButton = doc.createElement(&quot;button&quot;);
-    var clearButton = doc.createElement(&quot;button&quot;);
-    var closeButton = doc.createElement(&quot;button&quot;);
-    var logPaneArea = doc.createElement(&quot;div&quot;);
-    var logPane = doc.createElement(&quot;div&quot;);
-
-    /* Set up the functions */
-    var listenerId = uid + &quot;_Listener&quot;;
-    this.colorTable = clone(this.colorTable);
-    var messages = [];
-    var messageFilter = null;
-
-    var messageLevel = function (msg) {
-        var level = msg.level;
-        if (typeof(level) == &quot;number&quot;) {
-            level = MochiKit.Logging.LogLevel[level];
-        }
-        return level;
-    };
-
-    var messageText = function (msg) {
-        return msg.info.join(&quot; &quot;);
-    };
-
-    var addMessageText = bind(function (msg) {
-        var level = messageLevel(msg);
-        var text = messageText(msg);
-        var c = this.colorTable[level];
-        var p = doc.createElement(&quot;span&quot;);
-        p.className = &quot;MochiKit-LogMessage MochiKit-LogLevel-&quot; + level;
-        p.style.cssText = &quot;margin: 0px; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; white-space: pre-wrap; white-space: pre-line; word-wrap: break-word; wrap-option: emergency; color: &quot; + c;
-        p.appendChild(doc.createTextNode(level + &quot;: &quot; + text));
-        logPane.appendChild(p);
-        logPane.appendChild(doc.createElement(&quot;br&quot;));
-        if (logPaneArea.offsetHeight &gt; logPaneArea.scrollHeight) {
-            logPaneArea.scrollTop = 0;
-        } else {
-            logPaneArea.scrollTop = logPaneArea.scrollHeight;
-        }
-    }, this);
-
-    var addMessage = function (msg) {
-        messages[messages.length] = msg;
-        addMessageText(msg);
-    };
-
-    var buildMessageFilter = function () {
-        var levelre, infore;
-        try {
-            /* Catch any exceptions that might arise due to invalid regexes */
-            levelre = new RegExp(levelFilterField.value);
-            infore = new RegExp(infoFilterField.value);
-        } catch(e) {
-            /* If there was an error with the regexes, do no filtering */
-            logDebug(&quot;Error in filter regex: &quot; + e.message);
-            return null;
-        }
-
-        return function (msg) {
-            return (
-                levelre.test(messageLevel(msg)) &amp;&amp;
-                infore.test(messageText(msg))
-            );
-        };
-    }
-
-    var clearMessagePane = function () {
-        while (logPane.firstChild) {
-            logPane.removeChild(logPane.firstChild);
-        }
-    };
-
-    var clearMessages = function () {
-        messages = [];
-        clearMessagePane();
-    }
-
-    var closePane = bind(function () {
-        if (this.closed) {
-            return;
-        }
-        this.closed = true;
-        if (MochiKit.LoggingPane._loggingPane == this) {
-            MochiKit.LoggingPane._loggingPane = null;
-        }
-        this.logger.removeListener(listenerId);
-
-        debugPane.loggingPane = null;
-
-        if (inline) {
-            debugPane.parentNode.removeChild(debugPane);
-        } else {
-            this.win.close();
-        }
-    }, this);
-
-    var filterMessages = function () {
-        clearMessagePane();
-
-        for (var i = 0; i &lt; messages.length; i++) {
-            var msg = messages[i];
-            if (messageFilter == null || messageFilter(msg)) {
-                addMessageText(msg);
-            }
-        }
-    };
-
-    this.buildAndApplyFilter = function () {
-        messageFilter = buildMessageFilter();
-
-        filterMessages();
-
-        this.logger.removeListener(listenerId);
-        this.logger.addListener(listenerId, messageFilter, addMessage);
-    };
-
-
-    var loadMessages = bind(function () {
-        messages = this.logger.getMessages();
-        filterMessages();
-    }, this);
-
-    var filterOnEnter = bind(function (event) {
-        event = event || window.event;
-        key = event.which || event.keyCode;
-        if (key == 13) {
-            this.buildAndApplyFilter();
-        }
-    }, this);
-
-    /* Create the debug pane */
-    var style = &quot;display: block; left: 0px; bottom: 0px; position: fixed; width: 100%; background-color: white; font: &quot; + this.logFont;
-    if (inline) {
-        style += &quot;; height: 10em; border-top: 2px solid black&quot;;
-    } else {
-        style += &quot;; height: 100%;&quot;;
-    }
-    debugPane.style.cssText = style;
-
-    if (!existing_pane) {
-        doc.body.appendChild(debugPane);
-    }
-
-    /* Create the filter fields */
-    style = {&quot;cssText&quot;: &quot;width: 33%; display: inline; font: &quot; + this.logFont};
-
-    updatetree(levelFilterField, {
-        &quot;value&quot;: &quot;FATAL|ERROR|WARNING|INFO|DEBUG&quot;,
-        &quot;onkeypress&quot;: filterOnEnter,
-        &quot;style&quot;: style
-    });
-    debugPane.appendChild(levelFilterField);
-
-    updatetree(infoFilterField, {
-        &quot;value&quot;: &quot;.*&quot;,
-        &quot;onkeypress&quot;: filterOnEnter,
-        &quot;style&quot;: style
-    });
-    debugPane.appendChild(infoFilterField);
-
-    /* Create the buttons */
-    style = &quot;width: 8%; display:inline; font: &quot; + this.logFont;
-
-    filterButton.appendChild(doc.createTextNode(&quot;Filter&quot;));
-    filterButton.onclick = bind(&quot;buildAndApplyFilter&quot;, this);
-    filterButton.style.cssText = style;
-    debugPane.appendChild(filterButton);
-
-    loadButton.appendChild(doc.createTextNode(&quot;Load&quot;));
-    loadButton.onclick = loadMessages;
-    loadButton.style.cssText = style;
-    debugPane.appendChild(loadButton);
-
-    clearButton.appendChild(doc.createTextNode(&quot;Clear&quot;));
-    clearButton.onclick = clearMessages;
-    clearButton.style.cssText = style;
-    debugPane.appendChild(clearButton);
-
-    closeButton.appendChild(doc.createTextNode(&quot;Close&quot;));
-    closeButton.onclick = closePane;
-    closeButton.style.cssText = style;
-    debugPane.appendChild(closeButton);
-
-    /* Create the logging pane */
-    logPaneArea.style.cssText = &quot;overflow: auto; width: 100%&quot;;
-    logPane.style.cssText = &quot;width: 100%; height: &quot; + (inline ? &quot;8em&quot; : &quot;100%&quot;);
-
-    logPaneArea.appendChild(logPane);
-    debugPane.appendChild(logPaneArea);
-
-    this.buildAndApplyFilter();
-    loadMessages();
-
-    if (inline) {
-        this.win = undefined;
-    } else {
-        this.win = win;
-    }
-    this.inline = inline;
-    this.closePane = closePane;
-    this.closed = false;
-
-    return this;
+MochiKit.LoggingPane.LoggingPane=function(_409,_410){
+if(typeof (_410)==&quot;undefined&quot;||_410==null){
+_410=MochiKit.Logging.logger;
+}
+this.logger=_410;
+var _411=MochiKit.Base.update;
+var _412=MochiKit.Base.updatetree;
+var bind=MochiKit.Base.bind;
+var _413=MochiKit.Base.clone;
+var win=window;
+var uid=&quot;_MochiKit_LoggingPane&quot;;
+if(typeof (MochiKit.DOM)!=&quot;undefined&quot;){
+win=MochiKit.DOM.currentWindow();
+}
+if(!_409){
+var url=win.location.href.split(&quot;?&quot;)[0].replace(/[:\/.&gt;&lt;&amp;]/g,&quot;_&quot;);
+var name=uid+&quot;_&quot;+url;
+var nwin=win.open(&quot;&quot;,name,&quot;dependent,resizable,height=200&quot;);
+if(!nwin){
+alert(&quot;Not able to open debugging window due to pop-up blocking.&quot;);
+return undefined;
+}
+nwin.document.write(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.0 Transitional//EN\&quot; &quot;+&quot;\&quot;<A HREF="http://www.w3.org/TR/html4/loose.dtd\">http://www.w3.org/TR/html4/loose.dtd\</A>&quot;&gt;&quot;+&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;[MochiKit.LoggingPane]&lt;/title&gt;&lt;/head&gt;&quot;+&quot;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
+nwin.document.close();
+nwin.document.title+=&quot; &quot;+win.document.title;
+win=nwin;
+}
+var doc=win.document;
+this.doc=doc;
+var _416=doc.getElementById(uid);
+var _417=!!_416;
+if(_416&amp;&amp;typeof (_416.loggingPane)!=&quot;undefined&quot;){
+_416.loggingPane.logger=this.logger;
+_416.loggingPane.buildAndApplyFilter();
+return _416.loggingPane;
+}
+if(_417){
+var _418;
+while((_418=_416.firstChild)){
+_416.removeChild(_418);
+}
+}else{
+_416=doc.createElement(&quot;div&quot;);
+_416.id=uid;
+}
+_416.loggingPane=this;
+var _419=doc.createElement(&quot;input&quot;);
+var _420=doc.createElement(&quot;input&quot;);
+var _421=doc.createElement(&quot;button&quot;);
+var _422=doc.createElement(&quot;button&quot;);
+var _423=doc.createElement(&quot;button&quot;);
+var _424=doc.createElement(&quot;button&quot;);
+var _425=doc.createElement(&quot;div&quot;);
+var _426=doc.createElement(&quot;div&quot;);
+var _427=uid+&quot;_Listener&quot;;
+this.colorTable=_413(this.colorTable);
+var _428=[];
+var _429=null;
+var _430=function(msg){
+var _431=msg.level;
+if(typeof (_431)==&quot;number&quot;){
+_431=MochiKit.Logging.LogLevel[_431];
+}
+return _431;
 };
-
-MochiKit.LoggingPane.LoggingPane.prototype = {
-    &quot;logFont&quot;: &quot;8pt Verdana,sans-serif&quot;,
-    &quot;colorTable&quot;: {
-        &quot;ERROR&quot;: &quot;red&quot;,
-        &quot;FATAL&quot;: &quot;darkred&quot;,
-        &quot;WARNING&quot;: &quot;blue&quot;,
-        &quot;INFO&quot;: &quot;black&quot;,
-        &quot;DEBUG&quot;: &quot;green&quot;
-    }
+var _432=function(msg){
+return msg.info.join(&quot; &quot;);
 };
-
-
-MochiKit.LoggingPane.EXPORT_OK = [
-    &quot;LoggingPane&quot;
-];
-
-MochiKit.LoggingPane.EXPORT = [
-    &quot;createLoggingPane&quot;
-];
-
-MochiKit.LoggingPane.__new__ = function () {
-    this.EXPORT_TAGS = {
-        &quot;:common&quot;: this.EXPORT,
-        &quot;:all&quot;: MochiKit.Base.concat(this.EXPORT, this.EXPORT_OK)
-    };
-
-    MochiKit.Base.nameFunctions(this);
-
-    MochiKit.LoggingPane._loggingPane = null;
-
+var _433=bind(function(msg){
+var _434=_430(msg);
+var text=_432(msg);
+var c=this.colorTable[_434];
+var p=doc.createElement(&quot;span&quot;);
+p.className=&quot;MochiKit-LogMessage MochiKit-LogLevel-&quot;+_434;
+p.style.cssText=&quot;margin: 0px; white-space: -moz-pre-wrap; white-space: -o-pre-wrap; white-space: pre-wrap; white-space: pre-line; word-wrap: break-word; wrap-option: emergency; color: &quot;+c;
+p.appendChild(doc.createTextNode(_434+&quot;: &quot;+text));
+_426.appendChild(p);
+_426.appendChild(doc.createElement(&quot;br&quot;));
+if(_425.offsetHeight&gt;_425.scrollHeight){
+_425.scrollTop=0;
+}else{
+_425.scrollTop=_425.scrollHeight;
+}
+},this);
+var _436=function(msg){
+_428[_428.length]=msg;
+_433(msg);
 };
-
+var _437=function(){
+var _438,infore;
+try{
+_438=new RegExp(_419.value);
+infore=new RegExp(_420.value);
+}
+catch(e){
+logDebug(&quot;Error in filter regex: &quot;+e.message);
+return null;
+}
+return function(msg){
+return (_438.test(_430(msg))&amp;&amp;infore.test(_432(msg)));
+};
+};
+var _439=function(){
+while(_426.firstChild){
+_426.removeChild(_426.firstChild);
+}
+};
+var _440=function(){
+_428=[];
+_439();
+};
+var _441=bind(function(){
+if(this.closed){
+return;
+}
+this.closed=true;
+if(MochiKit.LoggingPane._loggingPane==this){
+MochiKit.LoggingPane._loggingPane=null;
+}
+this.logger.removeListener(_427);
+_416.loggingPane=null;
+if(_409){
+_416.parentNode.removeChild(_416);
+}else{
+this.win.close();
+}
+},this);
+var _442=function(){
+_439();
+for(var i=0;i&lt;_428.length;i++){
+var msg=_428[i];
+if(_429==null||_429(msg)){
+_433(msg);
+}
+}
+};
+this.buildAndApplyFilter=function(){
+_429=_437();
+_442();
+this.logger.removeListener(_427);
+this.logger.addListener(_427,_429,_436);
+};
+var _443=bind(function(){
+_428=this.logger.getMessages();
+_442();
+},this);
+var _444=bind(function(_445){
+_445=_445||window.event;
+key=_445.which||_445.keyCode;
+if(key==13){
+this.buildAndApplyFilter();
+}
+},this);
+var _446=&quot;display: block; left: 0px; bottom: 0px; position: fixed; width: 100%; background-color: white; font: &quot;+this.logFont;
+if(_409){
+_446+=&quot;; height: 10em; border-top: 2px solid black&quot;;
+}else{
+_446+=&quot;; height: 100%;&quot;;
+}
+_416.style.cssText=_446;
+if(!_417){
+doc.body.appendChild(_416);
+}
+_446={&quot;cssText&quot;:&quot;width: 33%; display: inline; font: &quot;+this.logFont};
+_412(_419,{&quot;value&quot;:&quot;FATAL|ERROR|WARNING|INFO|DEBUG&quot;,&quot;onkeypress&quot;:_444,&quot;style&quot;:_446});
+_416.appendChild(_419);
+_412(_420,{&quot;value&quot;:&quot;.*&quot;,&quot;onkeypress&quot;:_444,&quot;style&quot;:_446});
+_416.appendChild(_420);
+_446=&quot;width: 8%; display:inline; font: &quot;+this.logFont;
+_421.appendChild(doc.createTextNode(&quot;Filter&quot;));
+_421.onclick=bind(&quot;buildAndApplyFilter&quot;,this);
+_421.style.cssText=_446;
+_416.appendChild(_421);
+_422.appendChild(doc.createTextNode(&quot;Load&quot;));
+_422.onclick=_443;
+_422.style.cssText=_446;
+_416.appendChild(_422);
+_423.appendChild(doc.createTextNode(&quot;Clear&quot;));
+_423.onclick=_440;
+_423.style.cssText=_446;
+_416.appendChild(_423);
+_424.appendChild(doc.createTextNode(&quot;Close&quot;));
+_424.onclick=_441;
+_424.style.cssText=_446;
+_416.appendChild(_424);
+_425.style.cssText=&quot;overflow: auto; width: 100%&quot;;
+_426.style.cssText=&quot;width: 100%; height: &quot;+(_409?&quot;8em&quot;:&quot;100%&quot;);
+_425.appendChild(_426);
+_416.appendChild(_425);
+this.buildAndApplyFilter();
+_443();
+if(_409){
+this.win=undefined;
+}else{
+this.win=win;
+}
+this.inline=_409;
+this.closePane=_441;
+this.closed=false;
+return this;
+};
+MochiKit.LoggingPane.LoggingPane.prototype={&quot;logFont&quot;:&quot;8pt Verdana,sans-serif&quot;,&quot;colorTable&quot;:{&quot;ERROR&quot;:&quot;red&quot;,&quot;FATAL&quot;:&quot;darkred&quot;,&quot;WARNING&quot;:&quot;blue&quot;,&quot;INFO&quot;:&quot;black&quot;,&quot;DEBUG&quot;:&quot;green&quot;}};
+MochiKit.LoggingPane.EXPORT_OK=[&quot;LoggingPane&quot;];
+MochiKit.LoggingPane.EXPORT=[&quot;createLoggingPane&quot;];
+MochiKit.LoggingPane.__new__=function(){
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:MochiKit.Base.concat(this.EXPORT,this.EXPORT_OK)};
+MochiKit.Base.nameFunctions(this);
+MochiKit.LoggingPane._loggingPane=null;
+};
 MochiKit.LoggingPane.__new__();
-
-MochiKit.Base._exportSymbols(this, MochiKit.LoggingPane);
-
-/***
-
-MochiKit.Color 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito and others.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.Color');
-    dojo.require('MochiKit.Base');
+MochiKit.Base._exportSymbols(this,MochiKit.LoggingPane);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Color&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
 }
-
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Base&quot;, []);
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
 }
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.Color depends on MochiKit.Base&quot;;
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;){
+throw &quot;&quot;;
 }
-
-if (typeof(MochiKit.Color) == &quot;undefined&quot;) {
-    MochiKit.Color = {};
 }
-
-MochiKit.Color.NAME = &quot;MochiKit.Color&quot;;
-MochiKit.Color.VERSION = &quot;1.3&quot;;
-
-MochiKit.Color.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+catch(e){
+throw &quot;MochiKit.Color depends on MochiKit.Base&quot;;
+}
+if(typeof (MochiKit.Color)==&quot;undefined&quot;){
+MochiKit.Color={};
+}
+MochiKit.Color.NAME=&quot;MochiKit.Color&quot;;
+MochiKit.Color.VERSION=&quot;1.3&quot;;
+MochiKit.Color.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
 };
-
-MochiKit.Color.toString = function () {
-    return this.__repr__();
+MochiKit.Color.toString=function(){
+return this.__repr__();
 };
-
-
-MochiKit.Color.Color = function (red, green, blue, alpha) {
-    if (typeof(alpha) == 'undefined' || alpha == null) {
-        alpha = 1.0;
-    }
-    this.rgb = {
-        r: red,
-        g: green,
-        b: blue,
-        a: alpha
-    };
+MochiKit.Color.Color=function(red,_448,blue,_450){
+if(typeof (_450)==&quot;undefined&quot;||_450==null){
+_450=1;
+}
+this.rgb={r:red,g:_448,b:blue,a:_450};
 };
-
-
-// Prototype methods
-MochiKit.Color.Color.prototype = {
-
-    __class__: MochiKit.Color.Color,
-
-    colorWithAlpha: function (alpha) {
-        var rgb = this.rgb;
-        var m = MochiKit.Color;
-        return m.Color.fromRGB(rgb.r, rgb.g, rgb.b, alpha);
-    },
-
-    colorWithHue: function (hue) {
-        // get an HSL model, and set the new hue...
-        var hsl = this.asHSL();
-        hsl.h = hue;
-        var m = MochiKit.Color;
-        // convert back to RGB...
-        return m.Color.fromHSL(hsl);
-    },
-
-    colorWithSaturation: function (saturation) {
-        // get an HSL model, and set the new hue...
-        var hsl = this.asHSL();
-        hsl.s = saturation;
-        var m = MochiKit.Color;
-        // convert back to RGB...
-        return m.Color.fromHSL(hsl);
-    },
-
-    colorWithLightness: function (lightness) {
-        // get an HSL model, and set the new hue...
-        var hsl = this.asHSL();
-        hsl.l = lightness;
-        var m = MochiKit.Color;
-        // convert back to RGB...
-        return m.Color.fromHSL(hsl);
-    },
-
-    darkerColorWithLevel: function (level) {
-        var hsl  = this.asHSL();
-        hsl.l = Math.max(hsl.l - level, 0);
-        var m = MochiKit.Color;
-        return m.Color.fromHSL(hsl);
-    },
-
-    lighterColorWithLevel: function (level) {
-        var hsl  = this.asHSL();
-        hsl.l = Math.min(hsl.l + level, 1);
-        var m = MochiKit.Color;
-        return m.Color.fromHSL(hsl);
-    },
-
-    blendedColor: function (other, /* optional */ fraction) {
-        if (typeof(fraction) == 'undefined' || fraction == null) {
-            fraction = 0.5;
-        }
-        var sf = 1.0 - fraction;
-        var s = this.rgb;
-        var d = other.rgb;
-        var df = fraction;
-        return MochiKit.Color.Color.fromRGB(
-            (s.r * sf) + (d.r * df),
-            (s.g * sf) + (d.g * df),
-            (s.b * sf) + (d.b * df),
-            (s.a * sf) + (d.a * df)
-        );
-    },
-
-    compareRGB: function (other) {
-        var a = this.asRGB();
-        var b = other.asRGB();
-        return MochiKit.Base.compare(
-            [a.r, a.g, a.b, a.a],
-            [b.r, b.g, b.b, b.a]
-        );
-    },
-
-    isLight: function () {
-        return this.asHSL().b &gt; 0.5;
-    },
-
-    isDark: function () {
-        return (!this.isLight());
-    },
-
-    toHSLString: function () {
-        var c = this.asHSL();
-        var ccc = MochiKit.Color.clampColorComponent;
-        var rval = this._hslString;
-        if (!rval) {
-            var mid = (
-                ccc(c.h, 360).toFixed(0)
-                + &quot;,&quot; + ccc(c.s, 100).toPrecision(4) + &quot;%&quot;
-                + &quot;,&quot; + ccc(c.l, 100).toPrecision(4) + &quot;%&quot;
-            );
-            var a = c.a;
-            if (a &gt;= 1) {
-                a = 1;
-                rval = &quot;hsl(&quot; + mid + &quot;)&quot;;
-            } else {
-                if (a &lt;= 0) {
-                    a = 0;
-                }
-                rval = &quot;hsla(&quot; + mid + &quot;,&quot; + a + &quot;)&quot;;
-            }
-            this._hslString = rval;
-        }
-        return rval;
-    },
-
-    toRGBString: function () {
-        var c = this.rgb;
-        var ccc = MochiKit.Color.clampColorComponent;
-        var rval = this._rgbString;
-        if (!rval) {
-            var mid = (
-                ccc(c.r, 255).toFixed(0)
-                + &quot;,&quot; + ccc(c.g, 255).toFixed(0)
-                + &quot;,&quot; + ccc(c.b, 255).toFixed(0)
-            );
-            if (c.a != 1) {
-                rval = &quot;rgba(&quot; + mid + &quot;,&quot; + c.a + &quot;)&quot;;
-            } else {
-                rval = &quot;rgb(&quot; + mid + &quot;)&quot;;
-            }
-            this._rgbString = rval;
-        }
-        return rval;
-    },
-
-    asRGB: function () {
-        return MochiKit.Base.clone(this.rgb);
-    },
-
-    toHexString: function () {
-        var m = MochiKit.Color;
-        var c = this.rgb;
-        var ccc = MochiKit.Color.clampColorComponent;
-        var rval = this._hexString;
-        if (!rval) {
-            rval = (&quot;#&quot; +
-                m.toColorPart(ccc(c.r, 255)) +
-                m.toColorPart(ccc(c.g, 255)) +
-                m.toColorPart(ccc(c.b, 255))
-            );
-            this._hexString = rval;
-        }
-        return rval;
-    },
-
-    asHSV: function () {
-        var hsv = this.hsv;
-        var c = this.rgb;
-        if (typeof(hsv) == 'undefined' || hsv == null) {
-            hsv = MochiKit.Color.rgbToHSV(this.rgb);
-            this.hsv = hsv;
-        }
-        return MochiKit.Base.clone(hsv);
-    },
-
-    asHSL: function () {
-        var hsl = this.hsl;
-        var c = this.rgb;
-        if (typeof(hsl) == 'undefined' || hsl == null) {
-            hsl = MochiKit.Color.rgbToHSL(this.rgb);
-            this.hsl = hsl;
-        }
-        return MochiKit.Base.clone(hsl);
-    },
-
-    toString: function () {
-        return this.toRGBString();
-    },
-
-    repr: function () {
-        var c = this.rgb;
-        var col = [c.r, c.g, c.b, c.a];
-        return this.__class__.NAME + &quot;(&quot; + col.join(&quot;, &quot;) + &quot;)&quot;;
-    }
-
+MochiKit.Color.Color.prototype={__class__:MochiKit.Color.Color,colorWithAlpha:function(_451){
+var rgb=this.rgb;
+var m=MochiKit.Color;
+return m.Color.fromRGB(rgb.r,rgb.g,rgb.b,_451);
+},colorWithHue:function(hue){
+var hsl=this.asHSL();
+hsl.h=hue;
+var m=MochiKit.Color;
+return m.Color.fromHSL(hsl);
+},colorWithSaturation:function(_455){
+var hsl=this.asHSL();
+hsl.s=_455;
+var m=MochiKit.Color;
+return m.Color.fromHSL(hsl);
+},colorWithLightness:function(_456){
+var hsl=this.asHSL();
+hsl.l=_456;
+var m=MochiKit.Color;
+return m.Color.fromHSL(hsl);
+},darkerColorWithLevel:function(_457){
+var hsl=this.asHSL();
+hsl.l=Math.max(hsl.l-_457,0);
+var m=MochiKit.Color;
+return m.Color.fromHSL(hsl);
+},lighterColorWithLevel:function(_458){
+var hsl=this.asHSL();
+hsl.l=Math.min(hsl.l+_458,1);
+var m=MochiKit.Color;
+return m.Color.fromHSL(hsl);
+},blendedColor:function(_459,_460){
+if(typeof (_460)==&quot;undefined&quot;||_460==null){
+_460=0.5;
+}
+var sf=1-_460;
+var s=this.rgb;
+var d=_459.rgb;
+var df=_460;
+return MochiKit.Color.Color.fromRGB((s.r*sf)+(d.r*df),(s.g*sf)+(d.g*df),(s.b*sf)+(d.b*df),(s.a*sf)+(d.a*df));
+},compareRGB:function(_463){
+var a=this.asRGB();
+var b=_463.asRGB();
+return MochiKit.Base.compare([a.r,a.g,a.b,a.a],[b.r,b.g,b.b,b.a]);
+},isLight:function(){
+return this.asHSL().b&gt;0.5;
+},isDark:function(){
+return (!this.isLight());
+},toHSLString:function(){
+var c=this.asHSL();
+var ccc=MochiKit.Color.clampColorComponent;
+var rval=this._hslString;
+if(!rval){
+var mid=(ccc(c.h,360).toFixed(0)+&quot;,&quot;+ccc(c.s,100).toPrecision(4)+&quot;%&quot;+&quot;,&quot;+ccc(c.l,100).toPrecision(4)+&quot;%&quot;);
+var a=c.a;
+if(a&gt;=1){
+a=1;
+rval=&quot;hsl(&quot;+mid+&quot;)&quot;;
+}else{
+if(a&lt;=0){
+a=0;
+}
+rval=&quot;hsla(&quot;+mid+&quot;,&quot;+a+&quot;)&quot;;
+}
+this._hslString=rval;
+}
+return rval;
+},toRGBString:function(){
+var c=this.rgb;
+var ccc=MochiKit.Color.clampColorComponent;
+var rval=this._rgbString;
+if(!rval){
+var mid=(ccc(c.r,255).toFixed(0)+&quot;,&quot;+ccc(c.g,255).toFixed(0)+&quot;,&quot;+ccc(c.b,255).toFixed(0));
+if(c.a!=1){
+rval=&quot;rgba(&quot;+mid+&quot;,&quot;+c.a+&quot;)&quot;;
+}else{
+rval=&quot;rgb(&quot;+mid+&quot;)&quot;;
+}
+this._rgbString=rval;
+}
+return rval;
+},asRGB:function(){
+return MochiKit.Base.clone(this.rgb);
+},toHexString:function(){
+var m=MochiKit.Color;
+var c=this.rgb;
+var ccc=MochiKit.Color.clampColorComponent;
+var rval=this._hexString;
+if(!rval){
+rval=(&quot;#&quot;+m.toColorPart(ccc(c.r,255))+m.toColorPart(ccc(c.g,255))+m.toColorPart(ccc(c.b,255)));
+this._hexString=rval;
+}
+return rval;
+},asHSV:function(){
+var hsv=this.hsv;
+var c=this.rgb;
+if(typeof (hsv)==&quot;undefined&quot;||hsv==null){
+hsv=MochiKit.Color.rgbToHSV(this.rgb);
+this.hsv=hsv;
+}
+return MochiKit.Base.clone(hsv);
+},asHSL:function(){
+var hsl=this.hsl;
+var c=this.rgb;
+if(typeof (hsl)==&quot;undefined&quot;||hsl==null){
+hsl=MochiKit.Color.rgbToHSL(this.rgb);
+this.hsl=hsl;
+}
+return MochiKit.Base.clone(hsl);
+},toString:function(){
+return this.toRGBString();
+},repr:function(){
+var c=this.rgb;
+var col=[c.r,c.g,c.b,c.a];
+return this.__class__.NAME+&quot;(&quot;+col.join(&quot;, &quot;)+&quot;)&quot;;
+}};
+MochiKit.Base.update(MochiKit.Color.Color,{fromRGB:function(red,_468,blue,_469){
+var _470=MochiKit.Color.Color;
+if(arguments.length==1){
+var rgb=red;
+red=rgb.r;
+_468=rgb.g;
+blue=rgb.b;
+if(typeof (rgb.a)==&quot;undefined&quot;){
+_469=undefined;
+}else{
+_469=rgb.a;
+}
+}
+return new _470(red,_468,blue,_469);
+},fromHSL:function(hue,_471,_472,_473){
+var m=MochiKit.Color;
+return m.Color.fromRGB(m.hslToRGB.apply(m,arguments));
+},fromHSV:function(hue,_474,_475,_476){
+var m=MochiKit.Color;
+return m.Color.fromRGB(m.hsvToRGB.apply(m,arguments));
+},fromName:function(name){
+var _477=MochiKit.Color.Color;
+var _478=_477._namedColors[name.toLowerCase()];
+if(typeof (_478)==&quot;string&quot;){
+return _477.fromHexString(_478);
+}else{
+if(name==&quot;transparent&quot;){
+return _477.transparentColor();
+}
+}
+return null;
+},fromString:function(_479){
+var self=MochiKit.Color.Color;
+var _480=_479.substr(0,3);
+if(_480==&quot;rgb&quot;){
+return self.fromRGBString(_479);
+}else{
+if(_480==&quot;hsl&quot;){
+return self.fromHSLString(_479);
+}else{
+if(_479.charAt(0)==&quot;#&quot;){
+return self.fromHexString(_479);
+}
+}
+}
+return self.fromName(_479);
+},fromHexString:function(_481){
+if(_481.charAt(0)==&quot;#&quot;){
+_481=_481.substring(1);
+}
+var _482=[];
+var i,hex;
+if(_481.length==3){
+for(i=0;i&lt;3;i++){
+hex=_481.substr(i,1);
+_482.push(parseInt(hex+hex,16)/255);
+}
+}else{
+for(i=0;i&lt;6;i+=2){
+hex=_481.substr(i,2);
+_482.push(parseInt(hex,16)/255);
+}
+}
+var _483=MochiKit.Color.Color;
+return _483.fromRGB.apply(_483,_482);
+},_fromColorString:function(pre,_485,_486,_487){
+if(_487.indexOf(pre)==0){
+_487=_487.substring(_487.indexOf(&quot;(&quot;,3)+1,_487.length-1);
+}
+var _488=_487.split(/\s*,\s*/);
+var _489=[];
+for(var i=0;i&lt;_488.length;i++){
+var c=_488[i];
+var val;
+var _490=c.substring(c.length-3);
+if(c.charAt(c.length-1)==&quot;%&quot;){
+val=0.01*parseFloat(c.substring(0,c.length-1));
+}else{
+if(_490==&quot;deg&quot;){
+val=parseFloat(c)/360;
+}else{
+if(_490==&quot;rad&quot;){
+val=parseFloat(c)/(Math.PI*2);
+}else{
+val=_486[i]*parseFloat(c);
+}
+}
+}
+_489.push(val);
+}
+return this[_485].apply(this,_489);
+},fromComputedStyle:function(elem,_491,_492){
+var d=MochiKit.DOM;
+var cls=MochiKit.Color.Color;
+for(elem=d.getElement(elem);elem;elem=elem.parentNode){
+var _493=d.computedStyle.apply(d,arguments);
+if(!_493){
+continue;
+}
+var _494=cls.fromString(_493);
+if(!_494){
+break;
+}
+if(_494.asRGB().a&gt;0){
+return _494;
+}
+}
+return null;
+},fromBackground:function(elem){
+var cls=MochiKit.Color.Color;
+return cls.fromComputedStyle(elem,&quot;backgroundColor&quot;,&quot;background-color&quot;)||cls.whiteColor();
+},fromText:function(elem){
+var cls=MochiKit.Color.Color;
+return cls.fromComputedStyle(elem,&quot;color&quot;,&quot;color&quot;)||cls.blackColor();
+},namedColors:function(){
+return MochiKit.Base.clone(MochiKit.Color.Color._namedColors);
+}});
+MochiKit.Base.update(MochiKit.Color,{clampColorComponent:function(v,_495){
+v*=_495;
+if(v&lt;0){
+return 0;
+}else{
+if(v&gt;_495){
+return _495;
+}else{
+return v;
+}
+}
+},_hslValue:function(n1,n2,hue){
+if(hue&gt;6){
+hue-=6;
+}else{
+if(hue&lt;0){
+hue+=6;
+}
+}
+var val;
+if(hue&lt;1){
+val=n1+(n2-n1)*hue;
+}else{
+if(hue&lt;3){
+val=n2;
+}else{
+if(hue&lt;4){
+val=n1+(n2-n1)*(4-hue);
+}else{
+val=n1;
+}
+}
+}
+return val;
+},hsvToRGB:function(hue,_498,_499,_500){
+if(arguments.length==1){
+var hsv=hue;
+hue=hsv.h;
+_498=hsv.s;
+_499=hsv.v;
+_500=hsv.a;
+}
+var red;
+var _501;
+var blue;
+if(_498==0){
+red=0;
+_501=0;
+blue=0;
+}else{
+var i=Math.floor(hue*6);
+var f=(hue*6)-i;
+var p=_499*(1-_498);
+var q=_499*(1-(_498*f));
+var t=_499*(1-(_498*(1-f)));
+switch(i){
+case 1:
+red=q;
+_501=_499;
+blue=p;
+break;
+case 2:
+red=p;
+_501=_499;
+blue=t;
+break;
+case 3:
+red=p;
+_501=q;
+blue=_499;
+break;
+case 4:
+red=t;
+_501=p;
+blue=_499;
+break;
+case 5:
+red=_499;
+_501=p;
+blue=q;
+break;
+case 6:
+case 0:
+red=_499;
+_501=t;
+blue=p;
+break;
+}
+}
+return {r:red,g:_501,b:blue,a:_500};
+},hslToRGB:function(hue,_503,_504,_505){
+if(arguments.length==1){
+var hsl=hue;
+hue=hsl.h;
+_503=hsl.s;
+_504=hsl.l;
+_505=hsl.a;
+}
+var red;
+var _506;
+var blue;
+if(_503==0){
+red=_504;
+_506=_504;
+blue=_504;
+}else{
+var m2;
+if(_504&lt;=0.5){
+m2=_504*(1+_503);
+}else{
+m2=_504+_503-(_504*_503);
+}
+var m1=(2*_504)-m2;
+var f=MochiKit.Color._hslValue;
+var h6=hue*6;
+red=f(m1,m2,h6+2);
+_506=f(m1,m2,h6);
+blue=f(m1,m2,h6-2);
+}
+return {r:red,g:_506,b:blue,a:_505};
+},rgbToHSV:function(red,_510,blue,_511){
+if(arguments.length==1){
+var rgb=red;
+red=rgb.r;
+_510=rgb.g;
+blue=rgb.b;
+_511=rgb.a;
+}
+var max=Math.max(Math.max(red,_510),blue);
+var min=Math.min(Math.min(red,_510),blue);
+var hue;
+var _514;
+var _515=max;
+if(min==max){
+hue=0;
+_514=0;
+}else{
+var _516=(max-min);
+_514=_516/max;
+if(red==max){
+hue=(_510-blue)/_516;
+}else{
+if(_510==max){
+hue=2+((blue-red)/_516);
+}else{
+hue=4+((red-_510)/_516);
+}
+}
+hue/=6;
+if(hue&lt;0){
+hue+=1;
+}
+if(hue&gt;1){
+hue-=1;
+}
+}
+return {h:hue,s:_514,v:_515,a:_511};
+},rgbToHSL:function(red,_517,blue,_518){
+if(arguments.length==1){
+var rgb=red;
+red=rgb.r;
+_517=rgb.g;
+blue=rgb.b;
+_518=rgb.a;
+}
+var max=Math.max(red,Math.max(_517,blue));
+var min=Math.min(red,Math.min(_517,blue));
+var hue;
+var _519;
+var _520=(max+min)/2;
+var _521=max-min;
+if(_521==0){
+hue=0;
+_519=0;
+}else{
+if(_520&lt;=0.5){
+_519=_521/(max+min);
+}else{
+_519=_521/(2-max-min);
+}
+if(red==max){
+hue=(_517-blue)/_521;
+}else{
+if(_517==max){
+hue=2+((blue-red)/_521);
+}else{
+hue=4+((red-_517)/_521);
+}
+}
+hue/=6;
+if(hue&lt;0){
+hue+=1;
+}
+if(hue&gt;1){
+hue-=1;
+}
+}
+return {h:hue,s:_519,l:_520,a:_518};
+},toColorPart:function(num){
+num=Math.round(num);
+var _522=num.toString(16);
+if(num&lt;16){
+return &quot;0&quot;+_522;
+}
+return _522;
+},__new__:function(){
+var m=MochiKit.Base;
+this.Color.fromRGBString=m.bind(this.Color._fromColorString,this.Color,&quot;rgb&quot;,&quot;fromRGB&quot;,[1/255,1/255,1/255,1]);
+this.Color.fromHSLString=m.bind(this.Color._fromColorString,this.Color,&quot;hsl&quot;,&quot;fromHSL&quot;,[1/360,0.01,0.01,1]);
+var _523=1/3;
+var _524={black:[0,0,0],blue:[0,0,1],brown:[0.6,0.4,0.2],cyan:[0,1,1],darkGray:[_523,_523,_523],gray:[0.5,0.5,0.5],green:[0,1,0],lightGray:[2*_523,2*_523,2*_523],magenta:[1,0,1],orange:[1,0.5,0],purple:[0.5,0,0.5],red:[1,0,0],transparent:[0,0,0,0],white:[1,1,1],yellow:[1,1,0]};
+var _525=function(name,r,g,b,a){
+var rval=this.fromRGB(r,g,b,a);
+this[name]=function(){
+return rval;
 };
-
-// Constructor methods
-MochiKit.Base.update(MochiKit.Color.Color, {
-    fromRGB: function (red, green, blue, alpha) {
-        // designated initializer
-        var Color = MochiKit.Color.Color;
-        if (arguments.length == 1) {
-            var rgb = red;
-            red = rgb.r;
-            green = rgb.g;
-            blue = rgb.b;
-            if (typeof(rgb.a) == 'undefined') {
-                alpha = undefined;
-            } else {
-                alpha = rgb.a;
-            }
-        }
-        return new Color(red, green, blue, alpha);
-    },
-
-    fromHSL: function (hue, saturation, lightness, alpha) {
-        var m = MochiKit.Color;
-        return m.Color.fromRGB(m.hslToRGB.apply(m, arguments));
-    },
-
-    fromHSV: function (hue, saturation, value, alpha) {
-        var m = MochiKit.Color;
-        return m.Color.fromRGB(m.hsvToRGB.apply(m, arguments));
-    },
-
-    fromName: function (name) {
-        var Color = MochiKit.Color.Color;
-        var htmlColor = Color._namedColors[name.toLowerCase()];
-        if (typeof(htmlColor) == 'string') {
-            return Color.fromHexString(htmlColor);
-        } else if (name == &quot;transparent&quot;) {
-            return Color.transparentColor();
-        }
-        return null;
-    },
-
-    fromString: function (colorString) {
-        var self = MochiKit.Color.Color;
-        var three = colorString.substr(0, 3);
-        if (three == &quot;rgb&quot;) {
-            return self.fromRGBString(colorString);
-        } else if (three == &quot;hsl&quot;) {
-            return self.fromHSLString(colorString);
-        } else if (colorString.charAt(0) == &quot;#&quot;) {
-            return self.fromHexString(colorString);
-        }
-        return self.fromName(colorString);
-    },
-
-
-    fromHexString: function (hexCode) {
-        if (hexCode.charAt(0) == '#') {
-            hexCode = hexCode.substring(1);
-        }
-        var components = [];
-        var i, hex;
-        if (hexCode.length == 3) {
-            for (i = 0; i &lt; 3; i++) {
-                hex = hexCode.substr(i, 1);
-                components.push(parseInt(hex + hex, 16) / 255.0);
-            }
-        } else {
-            for (i = 0; i &lt; 6; i += 2) {
-                hex = hexCode.substr(i, 2);
-                components.push(parseInt(hex, 16) / 255.0);
-            }
-        }
-        var Color = MochiKit.Color.Color;
-        return Color.fromRGB.apply(Color, components);
-    },
-
-
-    _fromColorString: function (pre, method, scales, colorCode) {
-        // parses either HSL or RGB
-        if (colorCode.indexOf(pre) == 0) {
-            colorCode = colorCode.substring(colorCode.indexOf(&quot;(&quot;, 3) + 1, colorCode.length - 1);
-        }
-        var colorChunks = colorCode.split(/\s*,\s*/);
-        var colorFloats = [];
-        for (var i = 0; i &lt; colorChunks.length; i++) {
-            var c = colorChunks[i];
-            var val;
-            var three = c.substring(c.length - 3);
-            if (c.charAt(c.length - 1) == '%') {
-                val = 0.01 * parseFloat(c.substring(0, c.length - 1));
-            } else if (three == &quot;deg&quot;) {
-                val = parseFloat(c) / 360.0;
-            } else if (three == &quot;rad&quot;) {
-                val = parseFloat(c) / (Math.PI * 2);
-            } else {
-                val = scales[i] * parseFloat(c);
-            }
-            colorFloats.push(val);
-        }
-        return this[method].apply(this, colorFloats);
-    },
-
-    fromComputedStyle: function (elem, style, mozillaEquivalentCSS) {
-        var d = MochiKit.DOM;
-        var cls = MochiKit.Color.Color;
-        for (elem = d.getElement(elem); elem; elem = elem.parentNode) {
-            var actualColor = d.computedStyle.apply(d, arguments);
-            if (!actualColor) {
-                continue;
-            }
-            var color = cls.fromString(actualColor);
-            if (!color) {
-                break;
-            }
-            if (color.asRGB().a &gt; 0) {
-                return color;
-            }
-        }
-        return null;
-    },
-
-    fromBackground: function (elem) {
-        var cls = MochiKit.Color.Color;
-        return cls.fromComputedStyle(
-            elem, &quot;backgroundColor&quot;, &quot;background-color&quot;) || cls.whiteColor();
-    },
-
-    fromText: function (elem) {
-        var cls = MochiKit.Color.Color;
-        return cls.fromComputedStyle(
-            elem, &quot;color&quot;, &quot;color&quot;) || cls.blackColor();
-    },
-
-    namedColors: function () {
-        return MochiKit.Base.clone(MochiKit.Color.Color._namedColors);
-    }
-});
-
-// Module level functions
-MochiKit.Base.update(MochiKit.Color, {
-    clampColorComponent: function (v, scale) {
-        v *= scale;
-        if (v &lt; 0) {
-            return 0;
-        } else if (v &gt; scale) {
-            return scale;
-        } else {
-            return v;
-        }
-    },
-
-    _hslValue: function (n1, n2, hue) {
-        if (hue &gt; 6.0) {
-            hue -= 6.0;
-        } else if (hue &lt; 0.0) {
-            hue += 6.0;
-        }
-        var val;
-        if (hue &lt; 1.0) {
-            val = n1 + (n2 - n1) * hue;
-        } else if (hue &lt; 3.0) {
-            val = n2;
-        } else if (hue &lt; 4.0) {
-            val = n1 + (n2 - n1) * (4.0 - hue);
-        } else {
-            val = n1;
-        }
-        return val;
-    },
-
-    hsvToRGB: function (hue, saturation, value, alpha) {
-        if (arguments.length == 1) {
-            var hsv = hue;
-            hue = hsv.h;
-            saturation = hsv.s;
-            value = hsv.v;
-            alpha = hsv.a;
-        }
-        var red;
-        var green;
-        var blue;
-        if (saturation == 0.0) {
-            red = 0;
-            green = 0;
-            blue = 0;
-        } else {
-            var i = Math.floor(hue * 6);
-            var f = (hue * 6) - i;
-            var p = value * (1 - saturation);
-            var q = value * (1 - (saturation * f));
-            var t = value * (1 - (saturation * (1 - f)));
-            switch (i) {
-                case 1: red = q; green = value; blue = p; break;
-                case 2: red = p; green = value; blue = t; break;
-                case 3: red = p; green = q; blue = value; break;
-                case 4: red = t; green = p; blue = value; break;
-                case 5: red = value; green = p; blue = q; break;
-                case 6: // fall through
-                case 0: red = value; green = t; blue = p; break;
-            }
-        }
-        return {
-            r: red,
-            g: green,
-            b: blue,
-            a: alpha
-        };
-    },
-
-    hslToRGB: function (hue, saturation, lightness, alpha) {
-        if (arguments.length == 1) {
-            var hsl = hue;
-            hue = hsl.h;
-            saturation = hsl.s;
-            lightness = hsl.l;
-            alpha = hsl.a;
-        }
-        var red;
-        var green;
-        var blue;
-        if (saturation == 0) {
-            red = lightness;
-            green = lightness;
-            blue = lightness;
-        } else {
-            var m2;
-            if (lightness &lt;= 0.5) {
-                m2 = lightness * (1.0 + saturation);
-            } else {
-                m2 = lightness + saturation - (lightness * saturation);
-            }
-            var m1 = (2.0 * lightness) - m2;
-            var f = MochiKit.Color._hslValue;
-            var h6 = hue * 6.0;
-            red = f(m1, m2, h6 + 2);
-            green = f(m1, m2, h6);
-            blue = f(m1, m2, h6 - 2);
-        }
-        return {
-            r: red,
-            g: green,
-            b: blue,
-            a: alpha
-        };
-    },
-
-    rgbToHSV: function (red, green, blue, alpha) {
-        if (arguments.length == 1) {
-            var rgb = red;
-            red = rgb.r;
-            green = rgb.g;
-            blue = rgb.b;
-            alpha = rgb.a;
-        }
-        var max = Math.max(Math.max(red, green), blue);
-        var min = Math.min(Math.min(red, green), blue);
-        var hue;
-        var saturation;
-        var value = max;
-        if (min == max) {
-            hue = 0;
-            saturation = 0;
-        } else {
-            var delta = (max - min);
-            saturation = delta / max;
-
-            if (red == max) {
-                hue = (green - blue) / delta;
-            } else if (green == max) {
-                hue = 2 + ((blue - red) / delta);
-            } else {
-                hue = 4 + ((red - green) / delta);
-            }
-            hue /= 6;
-            if (hue &lt; 0) {
-                hue += 1;
-            }
-            if (hue &gt; 1) {
-                hue -= 1;
-            }
-        }
-        return {
-            h: hue,
-            s: saturation,
-            v: value,
-            a: alpha
-        };
-    },
-
-    rgbToHSL: function (red, green, blue, alpha) {
-        if (arguments.length == 1) {
-            var rgb = red;
-            red = rgb.r;
-            green = rgb.g;
-            blue = rgb.b;
-            alpha = rgb.a;
-        }
-        var max = Math.max(red, Math.max(green, blue));
-        var min = Math.min(red, Math.min(green, blue));
-        var hue;
-        var saturation;
-        var lightness = (max + min) / 2.0;
-        var delta = max - min;
-        if (delta == 0) {
-            hue = 0;
-            saturation = 0;
-        } else {
-            if (lightness &lt;= 0.5) {
-                saturation = delta / (max + min);
-            } else {
-                saturation = delta / (2 - max - min);
-            }
-            if (red == max) {
-                hue = (green - blue) / delta;
-            } else if (green == max) {
-                hue = 2 + ((blue - red) / delta);
-            } else {
-                hue = 4 + ((red - green) / delta);
-            }
-            hue /= 6;
-            if (hue &lt; 0) {
-                hue += 1;
-            }
-            if (hue &gt; 1) {
-                hue -= 1;
-            }
-
-        }
-        return {
-            h: hue,
-            s: saturation,
-            l: lightness,
-            a: alpha
-        };
-    },
-
-    toColorPart: function (num) {
-        var digits = Math.round(num).toString(16);
-        if (num &lt; 16) {
-            return '0' + digits;
-        }
-        return digits;
-    },
-
-    __new__: function () {
-        var m = MochiKit.Base;
-        this.Color.fromRGBString = m.bind(
-            this.Color._fromColorString, this.Color, &quot;rgb&quot;, &quot;fromRGB&quot;,
-            [1.0/255.0, 1.0/255.0, 1.0/255.0, 1]
-        );
-        this.Color.fromHSLString = m.bind(
-            this.Color._fromColorString, this.Color, &quot;hsl&quot;, &quot;fromHSL&quot;,
-            [1.0/360.0, 0.01, 0.01, 1]
-        );
-
-        var third = 1.0 / 3.0;
-        var colors = {
-            // NSColor colors plus transparent
-            black: [0, 0, 0],
-            blue: [0, 0, 1],
-            brown: [0.6, 0.4, 0.2],
-            cyan: [0, 1, 1],
-            darkGray: [third, third, third],
-            gray: [0.5, 0.5, 0.5],
-            green: [0, 1, 0],
-            lightGray: [2 * third, 2 * third, 2 * third],
-            magenta: [1, 0, 1],
-            orange: [1, 0.5, 0],
-            purple: [0.5, 0, 0.5],
-            red: [1, 0, 0],
-            transparent: [0, 0, 0, 0],
-            white: [1, 1, 1],
-            yellow: [1, 1, 0]
-        };
-
-        var makeColor = function (name, r, g, b, a) {
-            var rval = this.fromRGB(r, g, b, a);
-            this[name] = function () { return rval; };
-            return rval;
-        }
-
-        for (var k in colors) {
-            var name = k + &quot;Color&quot;;
-            var bindArgs = m.concat(
-                [makeColor, this.Color, name],
-                colors[k]
-            );
-            this.Color[name] = m.bind.apply(null, bindArgs);
-        }
-
-        var isColor = function () {
-            for (var i = 0; i &lt; arguments.length; i++) {
-                if (!(arguments[i] instanceof Color)) {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        var compareColor = function (a, b) {
-            return a.compareRGB(b);
-        }
-
-        m.nameFunctions(this);
-
-        m.registerComparator(this.Color.NAME, isColor, compareColor);
-
-        this.EXPORT_TAGS = {
-            &quot;:common&quot;: this.EXPORT,
-            &quot;:all&quot;: m.concat(this.EXPORT, this.EXPORT_OK)
-        };
-
-    }
-});
-
-MochiKit.Color.EXPORT = [
-    &quot;Color&quot;
-];
-
-MochiKit.Color.EXPORT_OK = [
-    &quot;clampColorComponent&quot;,
-    &quot;rgbToHSL&quot;,
-    &quot;hslToRGB&quot;,
-    &quot;rgbToHSV&quot;,
-    &quot;hsvToRGB&quot;,
-    &quot;toColorPart&quot;
-];
-
+return rval;
+};
+for(var k in _524){
+var name=k+&quot;Color&quot;;
+var _528=m.concat([_525,this.Color,name],_524[k]);
+this.Color[name]=m.bind.apply(null,_528);
+}
+var _529=function(){
+for(var i=0;i&lt;arguments.length;i++){
+if(!(arguments[i] instanceof Color)){
+return false;
+}
+}
+return true;
+};
+var _530=function(a,b){
+return a.compareRGB(b);
+};
+m.nameFunctions(this);
+m.registerComparator(this.Color.NAME,_529,_530);
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+}});
+MochiKit.Color.EXPORT=[&quot;Color&quot;];
+MochiKit.Color.EXPORT_OK=[&quot;clampColorComponent&quot;,&quot;rgbToHSL&quot;,&quot;hslToRGB&quot;,&quot;rgbToHSV&quot;,&quot;hsvToRGB&quot;,&quot;toColorPart&quot;];
 MochiKit.Color.__new__();
-
-MochiKit.Base._exportSymbols(this, MochiKit.Color);
-
-// Full table of css3 X11 colors &lt;<A HREF="http://www.w3.org/TR/css3-color/#X11COLORS">http://www.w3.org/TR/css3-color/#X11COLORS</A>&gt;
-
-MochiKit.Color.Color._namedColors = {
-    aliceblue: &quot;#f0f8ff&quot;,
-    antiquewhite: &quot;#faebd7&quot;,
-    aqua: &quot;#00ffff&quot;,
-    aquamarine: &quot;#7fffd4&quot;,
-    azure: &quot;#f0ffff&quot;,
-    beige: &quot;#f5f5dc&quot;,
-    bisque: &quot;#ffe4c4&quot;,
-    black: &quot;#000000&quot;,
-    blanchedalmond: &quot;#ffebcd&quot;,
-    blue: &quot;#0000ff&quot;,
-    blueviolet: &quot;#8a2be2&quot;,
-    brown: &quot;#a52a2a&quot;,
-    burlywood: &quot;#deb887&quot;,
-    cadetblue: &quot;#5f9ea0&quot;,
-    chartreuse: &quot;#7fff00&quot;,
-    chocolate: &quot;#d2691e&quot;,
-    coral: &quot;#ff7f50&quot;,
-    cornflowerblue: &quot;#6495ed&quot;,
-    cornsilk: &quot;#fff8dc&quot;,
-    crimson: &quot;#dc143c&quot;,
-    cyan: &quot;#00ffff&quot;,
-    darkblue: &quot;#00008b&quot;,
-    darkcyan: &quot;#008b8b&quot;,
-    darkgoldenrod: &quot;#b8860b&quot;,
-    darkgray: &quot;#a9a9a9&quot;,
-    darkgreen: &quot;#006400&quot;,
-    darkgrey: &quot;#a9a9a9&quot;,
-    darkkhaki: &quot;#bdb76b&quot;,
-    darkmagenta: &quot;#8b008b&quot;,
-    darkolivegreen: &quot;#556b2f&quot;,
-    darkorange: &quot;#ff8c00&quot;,
-    darkorchid: &quot;#9932cc&quot;,
-    darkred: &quot;#8b0000&quot;,
-    darksalmon: &quot;#e9967a&quot;,
-    darkseagreen: &quot;#8fbc8f&quot;,
-    darkslateblue: &quot;#483d8b&quot;,
-    darkslategray: &quot;#2f4f4f&quot;,
-    darkslategrey: &quot;#2f4f4f&quot;,
-    darkturquoise: &quot;#00ced1&quot;,
-    darkviolet: &quot;#9400d3&quot;,
-    deeppink: &quot;#ff1493&quot;,
-    deepskyblue: &quot;#00bfff&quot;,
-    dimgray: &quot;#696969&quot;,
-    dimgrey: &quot;#696969&quot;,
-    dodgerblue: &quot;#1e90ff&quot;,
-    firebrick: &quot;#b22222&quot;,
-    floralwhite: &quot;#fffaf0&quot;,
-    forestgreen: &quot;#228b22&quot;,
-    fuchsia: &quot;#ff00ff&quot;,
-    gainsboro: &quot;#dcdcdc&quot;,
-    ghostwhite: &quot;#f8f8ff&quot;,
-    gold: &quot;#ffd700&quot;,
-    goldenrod: &quot;#daa520&quot;,
-    gray: &quot;#808080&quot;,
-    green: &quot;#008000&quot;,
-    greenyellow: &quot;#adff2f&quot;,
-    grey: &quot;#808080&quot;,
-    honeydew: &quot;#f0fff0&quot;,
-    hotpink: &quot;#ff69b4&quot;,
-    indianred: &quot;#cd5c5c&quot;,
-    indigo: &quot;#4b0082&quot;,
-    ivory: &quot;#fffff0&quot;,
-    khaki: &quot;#f0e68c&quot;,
-    lavender: &quot;#e6e6fa&quot;,
-    lavenderblush: &quot;#fff0f5&quot;,
-    lawngreen: &quot;#7cfc00&quot;,
-    lemonchiffon: &quot;#fffacd&quot;,
-    lightblue: &quot;#add8e6&quot;,
-    lightcoral: &quot;#f08080&quot;,
-    lightcyan: &quot;#e0ffff&quot;,
-    lightgoldenrodyellow: &quot;#fafad2&quot;,
-    lightgray: &quot;#d3d3d3&quot;,
-    lightgreen: &quot;#90ee90&quot;,
-    lightgrey: &quot;#d3d3d3&quot;,
-    lightpink: &quot;#ffb6c1&quot;,
-    lightsalmon: &quot;#ffa07a&quot;,
-    lightseagreen: &quot;#20b2aa&quot;,
-    lightskyblue: &quot;#87cefa&quot;,
-    lightslategray: &quot;#778899&quot;,
-    lightslategrey: &quot;#778899&quot;,
-    lightsteelblue: &quot;#b0c4de&quot;,
-    lightyellow: &quot;#ffffe0&quot;,
-    lime: &quot;#00ff00&quot;,
-    limegreen: &quot;#32cd32&quot;,
-    linen: &quot;#faf0e6&quot;,
-    magenta: &quot;#ff00ff&quot;,
-    maroon: &quot;#800000&quot;,
-    mediumaquamarine: &quot;#66cdaa&quot;,
-    mediumblue: &quot;#0000cd&quot;,
-    mediumorchid: &quot;#ba55d3&quot;,
-    mediumpurple: &quot;#9370db&quot;,
-    mediumseagreen: &quot;#3cb371&quot;,
-    mediumslateblue: &quot;#7b68ee&quot;,
-    mediumspringgreen: &quot;#00fa9a&quot;,
-    mediumturquoise: &quot;#48d1cc&quot;,
-    mediumvioletred: &quot;#c71585&quot;,
-    midnightblue: &quot;#191970&quot;,
-    mintcream: &quot;#f5fffa&quot;,
-    mistyrose: &quot;#ffe4e1&quot;,
-    moccasin: &quot;#ffe4b5&quot;,
-    navajowhite: &quot;#ffdead&quot;,
-    navy: &quot;#000080&quot;,
-    oldlace: &quot;#fdf5e6&quot;,
-    olive: &quot;#808000&quot;,
-    olivedrab: &quot;#6b8e23&quot;,
-    orange: &quot;#ffa500&quot;,
-    orangered: &quot;#ff4500&quot;,
-    orchid: &quot;#da70d6&quot;,
-    palegoldenrod: &quot;#eee8aa&quot;,
-    palegreen: &quot;#98fb98&quot;,
-    paleturquoise: &quot;#afeeee&quot;,
-    palevioletred: &quot;#db7093&quot;,
-    papayawhip: &quot;#ffefd5&quot;,
-    peachpuff: &quot;#ffdab9&quot;,
-    peru: &quot;#cd853f&quot;,
-    pink: &quot;#ffc0cb&quot;,
-    plum: &quot;#dda0dd&quot;,
-    powderblue: &quot;#b0e0e6&quot;,
-    purple: &quot;#800080&quot;,
-    red: &quot;#ff0000&quot;,
-    rosybrown: &quot;#bc8f8f&quot;,
-    royalblue: &quot;#4169e1&quot;,
-    saddlebrown: &quot;#8b4513&quot;,
-    salmon: &quot;#fa8072&quot;,
-    sandybrown: &quot;#f4a460&quot;,
-    seagreen: &quot;#2e8b57&quot;,
-    seashell: &quot;#fff5ee&quot;,
-    sienna: &quot;#a0522d&quot;,
-    silver: &quot;#c0c0c0&quot;,
-    skyblue: &quot;#87ceeb&quot;,
-    slateblue: &quot;#6a5acd&quot;,
-    slategray: &quot;#708090&quot;,
-    slategrey: &quot;#708090&quot;,
-    snow: &quot;#fffafa&quot;,
-    springgreen: &quot;#00ff7f&quot;,
-    steelblue: &quot;#4682b4&quot;,
-    tan: &quot;#d2b48c&quot;,
-    teal: &quot;#008080&quot;,
-    thistle: &quot;#d8bfd8&quot;,
-    tomato: &quot;#ff6347&quot;,
-    turquoise: &quot;#40e0d0&quot;,
-    violet: &quot;#ee82ee&quot;,
-    wheat: &quot;#f5deb3&quot;,
-    white: &quot;#ffffff&quot;,
-    whitesmoke: &quot;#f5f5f5&quot;,
-    yellow: &quot;#ffff00&quot;,
-    yellowgreen: &quot;#9acd32&quot;
+MochiKit.Base._exportSymbols(this,MochiKit.Color);
+MochiKit.Color.Color._namedColors={aliceblue:&quot;#f0f8ff&quot;,antiquewhite:&quot;#faebd7&quot;,aqua:&quot;#00ffff&quot;,aquamarine:&quot;#7fffd4&quot;,azure:&quot;#f0ffff&quot;,beige:&quot;#f5f5dc&quot;,bisque:&quot;#ffe4c4&quot;,black:&quot;#000000&quot;,blanchedalmond:&quot;#ffebcd&quot;,blue:&quot;#0000ff&quot;,blueviolet:&quot;#8a2be2&quot;,brown:&quot;#a52a2a&quot;,burlywood:&quot;#deb887&quot;,cadetblue:&quot;#5f9ea0&quot;,chartreuse:&quot;#7fff00&quot;,chocolate:&quot;#d2691e&quot;,coral:&quot;#ff7f50&quot;,cornflowerblue:&quot;#6495ed&quot;,cornsilk:&quot;#fff8dc&quot;,crimson:&quot;#dc143c&quot;,cyan:&quot;#00ffff&quot;,darkblue:&quot;#00008b&quot;,darkcyan:&quot;#008b8b&quot;,darkgoldenrod:&quot;#b8860b&quot;,darkgray:&quot;#a9a9a9&quot;,darkgreen:&quot;#006400&quot;,darkgrey:&quot;#a9a9a9&quot;,darkkhaki:&quot;#bdb76b&quot;,darkmagenta:&quot;#8b008b&quot;,darkolivegreen:&quot;#556b2f&quot;,darkorange:&quot;#ff8c00&quot;,darkorchid:&quot;#9932cc&quot;,darkred:&quot;#8b0000&quot;,darksalmon:&quot;#e9967a&quot;,darkseagreen:&quot;#8fbc8f&quot;,darkslateblue:&quot;#483d8b&quot;,darkslategray:&quot;#2f4f4f&quot;,darkslategrey:&quot;#2f4f4f&quot;,darkturquoise:&quot;#00ced1&quot;,darkviolet:&quot;#9400d3&quot;,deeppink:&quot;#ff1493&quot;,deepskyblue:&quot;#00bfff&quot;,dimgray:&quot;#696969&quot;,dimgrey:&quot;#696969&quot;,dodgerblue:&quot;#1e90ff&quot;,firebrick:&quot;#b22222&quot;,floralwhite:&quot;#fffaf0&quot;,forestgree!
 n:&quot;#228b22&quot;,fuchsia:&quot;#ff00ff&quot;,gainsboro:&quot;#dcdcdc&quot;,ghostwhite:&quot;#f8f8ff&quot;,gold:&quot;#ffd700&quot;,goldenrod:&quot;#daa520&quot;,gray:&quot;#808080&quot;,green:&quot;#008000&quot;,greenyellow:&quot;#adff2f&quot;,grey:&quot;#808080&quot;,honeydew:&quot;#f0fff0&quot;,hotpink:&quot;#ff69b4&quot;,indianred:&quot;#cd5c5c&quot;,indigo:&quot;#4b0082&quot;,ivory:&quot;#fffff0&quot;,khaki:&quot;#f0e68c&quot;,lavender:&quot;#e6e6fa&quot;,lavenderblush:&quot;#fff0f5&quot;,lawngreen:&quot;#7cfc00&quot;,lemonchiffon:&quot;#fffacd&quot;,lightblue:&quot;#add8e6&quot;,lightcoral:&quot;#f08080&quot;,lightcyan:&quot;#e0ffff&quot;,lightgoldenrodyellow:&quot;#fafad2&quot;,lightgray:&quot;#d3d3d3&quot;,lightgreen:&quot;#90ee90&quot;,lightgrey:&quot;#d3d3d3&quot;,lightpink:&quot;#ffb6c1&quot;,lightsalmon:&quot;#ffa07a&quot;,lightseagreen:&quot;#20b2aa&quot;,lightskyblue:&quot;#87cefa&quot;,lightslategray:&quot;#778899&quot;,lightslategrey:&quot;#778899&quot;,lightsteelblue:&quot;#b0c4de&quot;,lightyellow:&quot;#ffffe0&quot;,lime:&quot;#00ff00&quot;,limegreen:&quot;#32cd32&quot;,linen:&quot;#faf0e6&quot;,magenta:&quot;#ff00ff&quot;,maroon:&quot;#800000&quot;,mediumaquamarine:&quot;#66cdaa&quot;,mediumblue:&quot;#0000cd&quot;,mediumorchid:&quot;#ba55d3&quot;,mediumpurple:&quot;#9370db&quot;,mediumseagreen:&quot;#3cb371&quot;,mediumslateblue:&quot;#7b68ee&quot;,mediumspringgreen:&quot;#00fa9a&quot;,mediumturquoise:&quot;#48d1cc!
 &quot;,mediumvioletred:&quot;#c71585&quot;,midnightblue:&quot;#191970&quot;,mintcream:&quot;!
 #f5fffa&quot;
,mistyrose:&quot;#ffe4e1&quot;,moccasin:&quot;#ffe4b5&quot;,navajowhite:&quot;#ffdead&quot;,navy:&quot;#000080&quot;,oldlace:&quot;#fdf5e6&quot;,olive:&quot;#808000&quot;,olivedrab:&quot;#6b8e23&quot;,orange:&quot;#ffa500&quot;,orangered:&quot;#ff4500&quot;,orchid:&quot;#da70d6&quot;,palegoldenrod:&quot;#eee8aa&quot;,palegreen:&quot;#98fb98&quot;,paleturquoise:&quot;#afeeee&quot;,palevioletred:&quot;#db7093&quot;,papayawhip:&quot;#ffefd5&quot;,peachpuff:&quot;#ffdab9&quot;,peru:&quot;#cd853f&quot;,pink:&quot;#ffc0cb&quot;,plum:&quot;#dda0dd&quot;,powderblue:&quot;#b0e0e6&quot;,purple:&quot;#800080&quot;,red:&quot;#ff0000&quot;,rosybrown:&quot;#bc8f8f&quot;,royalblue:&quot;#4169e1&quot;,saddlebrown:&quot;#8b4513&quot;,salmon:&quot;#fa8072&quot;,sandybrown:&quot;#f4a460&quot;,seagreen:&quot;#2e8b57&quot;,seashell:&quot;#fff5ee&quot;,sienna:&quot;#a0522d&quot;,silver:&quot;#c0c0c0&quot;,skyblue:&quot;#87ceeb&quot;,slateblue:&quot;#6a5acd&quot;,slategray:&quot;#708090&quot;,slategrey:&quot;#708090&quot;,snow:&quot;#fffafa&quot;,springgreen:&quot;#00ff7f&quot;,steelblue:&quot;#4682b4&quot;,tan:&quot;#d2b48c&quot;,teal:&quot;#008080&quot;,thistle:&quot;#d8bfd8&quot;,tomato:&quot;#ff6347&quot;,turquoise:&quot;#40e0d0&quot;,violet:&quot;#ee82ee&quot;,wheat:&quot;#f5deb3&quot;,white:&quot;#ffffff&quot;,whitesmoke:&quot;#f5f5f5&quot;,yellow:&quot;#ffff00&quot;,yellowgreen:&quot;#9acd32&quot;};
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Signal&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
+dojo.require(&quot;MochiKit.DOM&quot;);
+}
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
+JSAN.use(&quot;MochiKit.DOM&quot;,[]);
+}
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;){
+throw &quot;&quot;;
+}
+}
+catch(e){
+throw &quot;MochiKit.Signal depends on MochiKit.Base!&quot;;
+}
+try{
+if(typeof (MochiKit.DOM)==&quot;undefined&quot;){
+throw &quot;&quot;;
+}
+}
+catch(e){
+throw &quot;MochiKit.Signal depends on MochiKit.DOM!&quot;;
+}
+if(typeof (MochiKit.Signal)==&quot;undefined&quot;){
+MochiKit.Signal={};
+}
+MochiKit.Signal.NAME=&quot;MochiKit.Signal&quot;;
+MochiKit.Signal.VERSION=&quot;1.3&quot;;
+MochiKit.Signal._observers=[];
+MochiKit.Signal.Event=function(e){
+this._event=e||window.event;
 };
-
-/***
-
-MochiKit.Signal 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2006 Jonathan Gardner, Beau Hartshorne.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.Signal');
-    dojo.require('MochiKit.Base');
-    dojo.require('MochiKit.DOM');
-}
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use('MochiKit.Base', []);
-    JSAN.use('MochiKit.DOM', []);
-}
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined') {
-        throw '';
-    }
-} catch (e) {
-    throw 'MochiKit.Signal depends on MochiKit.Base!';
-}
-
-try {
-    if (typeof(MochiKit.DOM) == 'undefined') {
-        throw '';
-    }
-} catch (e) {
-    throw 'MochiKit.Signal depends on MochiKit.DOM!';
-}
-
-if (typeof(MochiKit.Signal) == 'undefined') {
-    MochiKit.Signal = {};
-}
-
-MochiKit.Signal.NAME = 'MochiKit.Signal';
-MochiKit.Signal.VERSION = '1.3';
-
-MochiKit.Signal._observers = [];
-
-MochiKit.Signal.Event = function (e) {
-    this._event = e || window.event;
-};
-
-MochiKit.Signal.Event.prototype.event = function () {
-    // just to keep the top-level api consistent, i forget to look for
-    // event or event() -- maybe we should just keep this private so
-    // people know they should be filing bugs instead of playing with the
-    // raw event?
-    return this._event;
-};
-
-MochiKit.Signal.Event.prototype.type = function () {
-    return this._event.type || undefined;
-};
-
-MochiKit.Signal.Event.prototype.target = function () {
-    return this._event.target || this._event.srcElement;
-};
-
-MochiKit.Signal.Event.prototype.relatedTarget = function () {
-    if (this.type() == 'mouseover') {
-        return (this._event.relatedTarget ||
-            this._event.fromElement);
-    } else if (this.type() == 'mouseout') {
-        return (this._event.relatedTarget ||
-            this._event.toElement);
-    }
-    // FIXME: throw an exception instead?
-    return undefined;
-};
-
-MochiKit.Signal.Event.prototype.modifier = function () {
-    var m = {};
-    m.alt = this._event.altKey;
-    m.ctrl = this._event.ctrlKey;
-    m.meta = this._event.metaKey || false; // ie and opera punt here
-    m.shift = this._event.shiftKey;
-    return m;
-};
-
-MochiKit.Signal.Event.prototype.key = function () {
-    var k = {};
-    if (this.type() &amp;&amp; this.type().indexOf('key') === 0) {
-
-        /*
-
-        // If you're looking for a special key, look for it in keydown or
-        // keyup, but never keypress. If you're looking for a Unicode
-        // chracter, look for it with keypress, but never kd or ku.
-
-        // keyCode will contain the raw key code in a kd/ku event
-        // keyString will contain a human-redable keyCode
-
-        // charCode will contain the raw character code in a kp event
-        // charString will contain the actual character
-
-        Here are some of my notes:
-
-            FF key event behavior:
-            key event   charCode    keyCode
-            DOWN    ku,kd   0           40
-            DOWN    kp      0           40
-            ESC     ku,kd   0           27
-            ESC     kp      0           27
-            a       ku,kd   0           65
-            a       kp      97          0
-            shift+a ku,kd   0           65
-            shift+a kp      65          0
-            1       ku,kd   0           49
-            1       kp      49          0
-            shift+1 ku,kd   0           0
-            shift+1 kp      33          0
-
-            IE key event behavior:
-            key     event   keyCode
-            DOWN    ku,kd   40
-            DOWN    kp      undefined
-            ESC     ku,kd   27
-            ESC     kp      27
-            a       ku,kd   65
-            a       kp      97
-            shift+a ku,kd   65
-            shift+a kp      65
-            1       ku,kd   49
-            1       kp      49
-            shift+1 ku,kd   49
-            shift+1 kp      33
-
-            Safari key event behavior:
-            key     event   charCode    keyCode
-            DOWN    ku,kd   63233       40
-            DOWN    kp      63233       63233
-            ESC     ku,kd   27          27
-            ESC     kp      27          27
-            a       ku,kd   97          65
-            a       kp      97          97
-            shift+a ku,kd   65          65
-            shift+a kp      65          65
-            1       ku,kd   49          49
-            1       kp      49          49
-            shift+1 ku,kd   33          49
-            shift+1 kp      33          33
-
-        */
-
-        // look for special keys here
-        if (this.type() == 'keydown' || this.type() == 'keyup') {
-            k.code = this._event.keyCode;
-            k.string = (MochiKit.Signal._specialKeys[k.code] ||
-                'KEY_UNKNOWN');
-            return k;
-        // look for unicode characters here
-        } else if (this.type() == 'keypress') {
-            k.code = (this._event.charCode || this._event.keyCode);
-            // special keys don't have a character
-            if (MochiKit.Signal._specialKeys[k.code]) {
-                // remind users not to look for special chars in keypress
-                // FIXME: throw an exception instead?
-                return undefined;
-            } else {
-                k.string = String.fromCharCode(k.code);
-            }
-            return k;
-        }
-    }
-    // FIXME: throw an exception instead?
-    return undefined;
-};
-
-MochiKit.Signal.Event.prototype._fixPoint = function (point) {
-    // maybe this should be an inline function?
-    if (typeof(point) == 'undefined' || point &lt; 0) {
-        return 0;
-    }
-    return point;
-};
-
-MochiKit.Signal.Event.prototype.mouse = function () {
-    // mouse events
-    var m = {};
-    if (this.type() &amp;&amp; (
-        this.type().indexOf('mouse') === 0 ||
-        this.type().indexOf('click') != -1 ||
-        this.type() == 'contextmenu')) {
-
-        m.client = new MochiKit.DOM.Coordinates(0, 0);
-        if (this._event.clientX || this._event.clientY) {
-            m.client.x = this._fixPoint(this._event.clientX);
-            m.client.y = this._fixPoint(this._event.clientY);
-        }
-
-        m.page = new MochiKit.DOM.Coordinates(0, 0);
-        if (this._event.pageX || this._event.pageY) {
-            m.page.x = this._fixPoint(this._event.pageX);
-            m.page.y = this._fixPoint(this._event.pageY);
-        } else {
-            // IE keeps its document offset in
-            // document.documentElement.clientTop
-
-            // see <A HREF="http://msdn.microsoft.com/workshop/author/dhtml/reference/">http://msdn.microsoft.com/workshop/author/dhtml/reference/</A>
-            //     methods/getboundingclientrect.asp
-
-            // the offset is (2,2) in standards mode and (0,0) in quirks mode
-            m.page.x = (this._event.clientX +
-                (document.documentElement.scrollLeft ||
-                document.body.scrollLeft) -
-                document.documentElement.clientLeft);
-            m.page.y = (this._event.clientY +
-                (document.documentElement.scrollTop ||
-                document.body.scrollTop) -
-                document.documentElement.clientTop);
-        }
-        if (this.type() != 'mousemove') {
-            m.button = {};
-            m.button.left = false;
-            m.button.right = false;
-            m.button.middle = false;
-
-            // we could check this._event.button, but which is more consistent
-            if (this._event.which) {
-                m.button.left = (this._event.which == 1);
-                m.button.middle = (this._event.which == 2);
-                m.button.right = (this._event.which == 3);
-
-                // mac browsers and right click:
-                // safari doesn't fire any click events on a right click
-                // firefox fires the event, and sets ctrlKey = true
-                // opera fires the event, and sets metaKey = true
-                // oncontextmenu can detect right clicks between browsers and
-                // across platforms
-
-            } else {
-                m.button.left = !!(this._event.button &amp; 1);
-                m.button.right = !!(this._event.button &amp; 2);
-                m.button.middle = !!(this._event.button &amp; 4);
-            }
-        }
-        return m;
-    }
-    // FIXME: throw an exception instead?
-    return undefined;
-};
-
-MochiKit.Signal.Event.prototype.stop = function () {
-    this.stopPropagation();
-    this.preventDefault();
-};
-
-MochiKit.Signal.Event.prototype.stopPropagation = function () {
-    if (this._event.stopPropagation) {
-        this._event.stopPropagation();
-    } else {
-        this._event.cancelBubble = true;
-    }
-};
-
-MochiKit.Signal.Event.prototype.preventDefault = function () {
-    if (this._event.preventDefault) {
-        this._event.preventDefault();
-    } else {
-        this._event.returnValue = false;
-    }
-};
-
-MochiKit.Signal.Event.prototype.repr = function () {
-    var repr = MochiKit.Base.repr;
-    var str = '{event(): ' + repr(this.event()) +
-        ', type(): ' + repr(this.type()) +
-        ', target(): ' + repr(this.target()) +
-        ', modifier(): ' + '{alt: ' + repr(this.modifier().alt) +
-        ', ctrl: ' + repr(this.modifier().ctrl) +
-        ', meta: ' + repr(this.modifier().meta) +
-        ', shift: ' + repr(this.modifier().shift) + '}';
-
-    if (this.type() &amp;&amp; this.type().indexOf('key') === 0) {
-        str += ', key(): {code: ' + repr(this.key().code) +
-            ', string: ' + repr(this.key().string) + '}';
-    }
-
-    if (this.type() &amp;&amp; (
-        this.type().indexOf('mouse') === 0 ||
-        this.type().indexOf('click') != -1 ||
-        this.type() == 'contextmenu')) {
-
-        str += ', mouse(): {page: ' + repr(this.mouse().page) +
-            ', client: ' + repr(this.mouse().client);
-
-        if (this.type() != 'mousemove') {
-            str += ', button: {left: ' + repr(this.mouse().button.left) +
-                ', middle: ' + repr(this.mouse().button.middle) +
-                ', right: ' + repr(this.mouse().button.right) + '}}';
-        } else {
-            str += '}';
-        }
-    }
-    if (this.type() == 'mouseover' || this.type() == 'mouseout') {
-        str += ', relatedTarget(): ' + repr(this.relatedTarget());
-    }
-    str += '}';
-    return str;
-};
-
-MochiKit.Base.update(MochiKit.Signal, {
-
-    __repr__: function () {
-        return '[' + this.NAME + ' ' + this.VERSION + ']';
-    },
-
-    toString: function () {
-        return this.__repr__();
-    },
-
-    // this is straight out of Dojo
-    _specialKeys: {
-        8: 'KEY_BACKSPACE',
-        9: 'KEY_TAB',
-        13: 'KEY_ENTER',
-        16: 'KEY_SHIFT',
-        17: 'KEY_CTRL',
-        18: 'KEY_ALT',
-        19: 'KEY_PAUSE',
-        20: 'KEY_CAPS_LOCK',
-        27: 'KEY_ESCAPE',
-        32: 'KEY_SPACE',
-        33: 'KEY_PAGE_UP',
-        34: 'KEY_PAGE_DOWN',
-        35: 'KEY_END',
-        36: 'KEY_HOME',
-        37: 'KEY_LEFT_ARROW',
-        38: 'KEY_UP_ARROW',
-        39: 'KEY_RIGHT_ARROW',
-        40: 'KEY_DOWN_ARROW',
-        45: 'KEY_INSERT',
-        46: 'KEY_DELETE',
-        91: 'KEY_LEFT_WINDOW',
-        92: 'KEY_RIGHT_WINDOW',
-        93: 'KEY_SELECT',
-        112: 'KEY_F1',
-        113: 'KEY_F2',
-        114: 'KEY_F3',
-        115: 'KEY_F4',
-        116: 'KEY_F5',
-        117: 'KEY_F6',
-        118: 'KEY_F7',
-        119: 'KEY_F8',
-        120: 'KEY_F9',
-        121: 'KEY_F10',
-        122: 'KEY_F11',
-        123: 'KEY_F12',
-        144: 'KEY_NUM_LOCK',
-        145: 'KEY_SCROLL_LOCK'
-        // undefined: 'KEY_UNKNOWN'
-    },
-
-    _getSlot: function (slot, func) {
-        if (typeof(func) == 'string' || typeof(func) == 'function') {
-            slot = [slot, func];
-        } else if (!func &amp;&amp; typeof(slot) == 'function') {
-            slot = [slot];
-        } else {
-            throw new Error('Invalid slot parameters');
-        }
-
-        return slot;
-    },
-
-    _unloadCache: function () {
-        for (var i = 0; i &lt; MochiKit.Signal._observers.length; i++) {
-            var src = MochiKit.Signal._observers[i][0];
-            var sig = MochiKit.Signal._observers[i][1];
-            var listener = MochiKit.Signal._observers[i][2];
-
-            try {
-                if (src.addEventListener) {
-                    src.removeEventListener(sig.substr(2), listener, false);
-                } else if (src.attachEvent) {
-                    src.detachEvent(sig, listener);
-                } else {
-                    src.__signals[sig] = undefined;
-                }
-
-                src.__listeners[sig] = undefined;
-
-                // delete removes object properties, not variables
-                delete(src.__listeners);
-                delete(src.__signals);
-
-            } catch(e) {
-                // clean IE garbage
-            }
-        }
-
-        MochiKit.Signal._observers = undefined;
-
-        try {
-            window.onload = undefined;
-        } catch(e) {
-            // clean IE garbage
-        }
-
-        try {
-            window.onunload = undefined;
-        } catch(e) {
-            // clean IE garbage
-        }
-    },
-
-    connect: function (src, sig, slot, /* optional */func) {
-        /***
-
-        Connects a signal to a slot.
-
-        'src' is the object that has the signal. You may pass in a string, in
-        which case, it is interpreted as an id for an HTML Element.
-
-        'signal' is a string that represents a signal name. If 'src' is an
-        HTML Element, Window, or the Document, then it can be one of the
-        'on-XYZ' events. Note that you must include the 'on' prefix, and it
-        must be all lower-case. If 'src' is another kind of object, the signal
-        must be previously registered with 'registerSignals()'.
-
-        'dest' and 'func' describe the slot, or the action to take when the
-        signal is triggered.
-
-            -   If 'dest' is an object and 'func' is a string, then
-                'dest[func](...)' will be called when the signal is signalled.
-
-            -   If 'dest' is an object and 'func' is a function, then
-                'func.apply(dest, ...)' will be called when the signal is
-                signalled.
-
-            -   If 'func' is undefined and 'dest' is a function, then
-                'func.apply(src, ...)' will be called when the signal is
-                signalled.
-
-        No other combinations are allowed and should raise and exception.
-
-        You may call 'connect()' multiple times with the same connection
-        paramters. However, only a single connection will be made.
-
-        ***/
-        if (typeof(src) == 'string') {
-            src = MochiKit.DOM.getElement(src);
-        }
-
-        if (typeof(sig) != 'string') {
-            throw new Error(&quot;'sig' must be a string&quot;);
-        }
-
-        slot = MochiKit.Signal._getSlot(slot, func);
-
-        // Find the signal, attach the slot.
-
-        // DOM object
-        if (src.addEventListener || src.attachEvent || src[sig]) {
-            // Create the __listeners object. This will help us remember which
-            // events we are watching.
-            if (!src.__listeners) {
-                src.__listeners = {};
-            }
-
-            // Add the signal connector if it hasn't been done already.
-            if (!src.__listeners[sig]) {
-                var listener = function (nativeEvent) {
-                    var eventObject = new MochiKit.Signal.Event(nativeEvent);
-                    MochiKit.Signal.signal(src, sig, eventObject);
-                    return true;
-                };
-                MochiKit.Signal._observers.push([src, sig, listener]);
-
-                if (src.addEventListener) {
-                    src.addEventListener(sig.substr(2), listener, false);
-                } else if (src.attachEvent) {
-                    src.attachEvent(sig, listener);
-                } else {
-                    src[sig] = listener;
-                }
-
-                src.__listeners[sig] = listener;
-            }
-
-            if (!src.__signals) {
-                src.__signals = {};
-            }
-            if (!src.__signals[sig]) {
-                src.__signals[sig] = [];
-            }
-        } else {
-            if (!src.__signals || !src.__signals[sig]) {
-                throw new Error(&quot;No such signal '&quot; + sig + &quot;' registered.&quot;);
-            }
-        }
-
-        // Actually add the slot... if it isn't there already.
-        var signals = src.__signals[sig];
-        for (var i = 0; i &lt; signals.length; i++) {
-            var s = signals[i];
-            if (slot[0] === s[0] &amp;&amp; slot[1] === s[1] &amp;&amp; slot[2] === s[2]) {
-                return;
-            }
-        }
-        signals.push(slot);
-    },
-
-    disconnect: function (src, sig, slot, /* optional */func) {
-        /***
-
-        When 'disconnect()' is called, it will disconnect whatever connection
-        was made given the same parameters to 'connect()'. Note that if you
-        want to pass a closure to 'connect()', you'll have to remember it if
-        you want to later 'disconnect()' it.
-
-        ***/
-        if (typeof(src) == 'string') {
-            src = MochiKit.DOM.getElement(src);
-        }
-
-        if (typeof(sig) != 'string') {
-            throw new Error(&quot;'signal' must be a string&quot;);
-        }
-
-        slot = MochiKit.Signal._getSlot(slot, func);
-
-        if (src.__signals &amp;&amp; src.__signals[sig]) {
-            var signals = src.__signals[sig];
-            var origlen = signals.length;
-            for (var i = 0; i &lt; signals.length; i++) {
-                var s = signals[i];
-                if (s[0] === slot[0] &amp;&amp; s[1] === slot[1] &amp;&amp; s[2] === slot[2]) {
-                    signals.splice(i, 1);
-                    break;
-                }
-            }
-        }
-
-        if (src.addEventListener || src.attachEvent || src.__signals[sig]) {
-            // DOM object
-
-            // Stop listening if there are no connected slots.
-            if (src.__listeners &amp;&amp; src.__listeners[sig] &amp;&amp;
-                src.__signals[sig].length === 0) {
-
-                var listener = src.__listeners[sig];
-
-                if (src.addEventListener) {
-                    src.removeEventListener(sig.substr(2), listener, false);
-                } else if (src.attachEvent) {
-                    src.detachEvent(sig, listener);
-                } else {
-                    src.__signals[sig] = undefined;
-                }
-
-                var observers = MochiKit.Signal._observers;
-                for (var i = 0; i &lt; observers.length; i++) {
-                    var o = observers[i];
-                    if (o[0] === src &amp;&amp; o[1] === sig &amp;&amp; o[2] === listener) {
-                        observers.splice(i, 1);
-                        break;
-                    }
-                }
-                src.__listeners[sig] = undefined;
-            }
-        }
-    },
-
-    signal: function (src, sig) {
-        /***
-
-        This will signal a signal, passing whatever additional parameters
-        on to the connected slots. 'src' and 'signal' are the same as for
-        'connect()'.
-
-        ***/
-        if (typeof(src) == 'string') {
-            src = MochiKit.DOM.getElement(src);
-        }
-
-        if (typeof(sig) != 'string') {
-            throw new Error(&quot;'signal' must be a string&quot;);
-        }
-
-        if (!src.__signals || !src.__signals[sig]) {
-            if (src.addEventListener || src.attachEvent || src[sig]) {
-                // Ignored.
-                return;
-            } else {
-                throw new Error(&quot;No such signal '&quot; + sig + &quot;'&quot;);
-            }
-        }
-        var slots = src.__signals[sig];
-
-        var args = MochiKit.Base.extend(null, arguments, 2);
-
-        var slot;
-        var errors = [];
-        for (var i = 0; i &lt; slots.length; i++) {
-            slot = slots[i];
-            try {
-                if (slot.length == 1) {
-                    slot[0].apply(src, args);
-                } else {
-                    if (typeof(slot[1]) == 'string') {
-                        slot[0][slot[1]].apply(slot[0], args);
-                    } else {
-                        slot[1].apply(slot[0], args);
-                    }
-                }
-            } catch (e) {
-                errors.push(e);
-            }
-        }
-        if (errors.length) {
-            var e = new Error(&quot;There were errors in handling signal 'sig'.&quot;);
-            e.errors = errors;
-            throw e;
-        }
-    },
-
-    registerSignals: function (src, signals) {
-        /***
-
-        This will register signals for the object 'src'. (Note that a string
-        here is not allowed--you don't need to register signals for DOM
-        objects.) 'signals' is an array of strings.
-
-        You may register the same signals multiple times; subsequent register
-        calls with the same signal names will have no effect, and the existing
-        connections, if any, will not be lost.
-
-        ***/
-        if (!src.__signals) {
-            src.__signals = {
-                /*
-                __repr__: function () {
-                    var m = MochiKit.Base;
-                    var signals = m.items(this);
-                    signals = m.filter(
-                        function (a) { return a[0] != &quot;__repr__&quot;; },
-                        signals
-                    );
-                    signals.sort(m.compare);
-                    return (
-                        '{\n    ' + m.map(
-                            function (a) {
-                                return m.map(m.repr, a).join(&quot;: &quot;)
-                            },
-                            signals
-                        ).join(&quot;,\n    &quot;) + &quot;\n}&quot;
-                    );
-                }
-                */
-            };
-        }
-
-        for (var i = 0; i &lt; signals.length; i++) {
-            var sig = signals[i];
-            if (!src.__signals[sig]) {
-                src.__signals[sig] = [];
-            }
-        }
-    }
-});
-
-MochiKit.Signal.EXPORT_OK = [];
-
-MochiKit.Signal.EXPORT = [
-    'connect',
-    'disconnect',
-    'signal',
-    'registerSignals'
-];
-
-MochiKit.Signal.__new__ = function (win) {
-    var m = MochiKit.Base;
-    this._document = document;
-    this._window = win;
-
-    try {
-        this.connect(window, 'onunload', this._unloadCache);
-    } catch (e) {
-        // pass: might not be a browser
-    }
-
-    this.EXPORT_TAGS = {
-        ':common': this.EXPORT,
-        ':all': m.concat(this.EXPORT, this.EXPORT_OK)
-    };
-
-    m.nameFunctions(this);
-
-};
-
-MochiKit.Signal.__new__(this);
-
-MochiKit.Base._exportSymbols(this, MochiKit.Signal);
-
-/***
-
-MochiKit.Visual 1.3
-
-See &lt;<A HREF="http://mochikit.com/">http://mochikit.com/</A>&gt; for documentation, downloads, license, etc.
-
-(c) 2005 Bob Ippolito and others.  All rights Reserved.
-
-***/
-
-if (typeof(dojo) != 'undefined') {
-    dojo.provide('MochiKit.Visual');
-    dojo.require('MochiKit.Base');
-    dojo.require('MochiKit.DOM');
-    dojo.require('MochiKit.Color');
+MochiKit.Signal.Event.prototype.event=function(){
+return this._event;
+};
+MochiKit.Signal.Event.prototype.type=function(){
+return this._event.type||undefined;
+};
+MochiKit.Signal.Event.prototype.target=function(){
+return this._event.target||this._event.srcElement;
+};
+MochiKit.Signal.Event.prototype.relatedTarget=function(){
+if(this.type()==&quot;mouseover&quot;){
+return (this._event.relatedTarget||this._event.fromElement);
+}else{
+if(this.type()==&quot;mouseout&quot;){
+return (this._event.relatedTarget||this._event.toElement);
 }
-
-if (typeof(JSAN) != 'undefined') {
-    JSAN.use(&quot;MochiKit.Base&quot;, []);
-    JSAN.use(&quot;MochiKit.DOM&quot;, []);
-    JSAN.use(&quot;MochiKit.Color&quot;, []);
 }
-
-try {
-    if (typeof(MochiKit.Base) == 'undefined' ||
-        typeof(MochiKit.DOM) == 'undefined' ||
-        typeof(MochiKit.Color) == 'undefined') {
-        throw &quot;&quot;;
-    }
-} catch (e) {
-    throw &quot;MochiKit.Visual depends on MochiKit.Base, MochiKit.DOM and MochiKit.Color!&quot;;
+throw new Error(&quot;No related target&quot;);
+};
+MochiKit.Signal.Event.prototype.modifier=function(){
+var m={};
+m.alt=this._event.altKey;
+m.ctrl=this._event.ctrlKey;
+m.meta=this._event.metaKey||false;
+m.shift=this._event.shiftKey;
+return m;
+};
+MochiKit.Signal.Event.prototype.key=function(){
+var k={};
+if(this.type()&amp;&amp;this.type().indexOf(&quot;key&quot;)===0){
+if(this.type()==&quot;keydown&quot;||this.type()==&quot;keyup&quot;){
+k.code=this._event.keyCode;
+k.string=(MochiKit.Signal._specialKeys[k.code]||&quot;KEY_UNKNOWN&quot;);
+return k;
+}else{
+if(this.type()==&quot;keypress&quot;){
+k.code=(this._event.charCode||this._event.keyCode);
+k.string=String.fromCharCode(k.code);
+return k;
 }
-
-if (typeof(MochiKit.Visual) == &quot;undefined&quot;) {
-    MochiKit.Visual = {};
 }
-
-MochiKit.Visual.NAME = &quot;MochiKit.Visual&quot;;
-MochiKit.Visual.VERSION = &quot;1.3&quot;;
-
-MochiKit.Visual.__repr__ = function () {
-    return &quot;[&quot; + this.NAME + &quot; &quot; + this.VERSION + &quot;]&quot;;
+}
+throw new Error(&quot;This is not a key event&quot;);
 };
-
-MochiKit.Visual.toString = function () {
-    return this.__repr__();
+MochiKit.Signal.Event.prototype._fixPoint=function(_531){
+if(typeof (_531)==&quot;undefined&quot;||_531&lt;0){
+return 0;
+}
+return _531;
 };
-
-
-MochiKit.Visual._RoundCorners = function (e, options) {
-    e = MochiKit.DOM.getElement(e);
-    this._setOptions(options);
-    if (this.options.__unstable__wrapElement) {
-        e = this._doWrap(e);
-    }
-
-    var color = this.options.color;
-    var C = MochiKit.Color.Color;
-    if (this.options.color == &quot;fromElement&quot;) {
-        color = C.fromBackground(e);
-    } else if (!(color instanceof C)) {
-        color = C.fromString(color);
-    }
-    this.isTransparent = (color.asRGB().a &lt;= 0);
-
-    var bgColor = this.options.bgColor;
-    if (this.options.bgColor == &quot;fromParent&quot;) {
-        bgColor = C.fromBackground(e.offsetParent);
-    } else if (!(bgColor instanceof C)) {
-        bgColor = C.fromString(bgColor);
-    }
-
-    this._roundCornersImpl(e, color, bgColor);
+MochiKit.Signal.Event.prototype.mouse=function(){
+var m={};
+if(this.type()&amp;&amp;(this.type().indexOf(&quot;mouse&quot;)===0||this.type().indexOf(&quot;click&quot;)!=-1||this.type()==&quot;contextmenu&quot;)){
+m.client=new MochiKit.DOM.Coordinates(0,0);
+if(this._event.clientX||this._event.clientY){
+m.client.x=this._fixPoint(this._event.clientX);
+m.client.y=this._fixPoint(this._event.clientY);
+}
+m.page=new MochiKit.DOM.Coordinates(0,0);
+if(this._event.pageX||this._event.pageY){
+m.page.x=this._fixPoint(this._event.pageX);
+m.page.y=this._fixPoint(this._event.pageY);
+}else{
+m.page.x=(this._event.clientX+(document.documentElement.scrollLeft||document.body.scrollLeft)-document.documentElement.clientLeft);
+m.page.y=(this._event.clientY+(document.documentElement.scrollTop||document.body.scrollTop)-document.documentElement.clientTop);
+}
+if(this.type()!=&quot;mousemove&quot;){
+m.button={};
+m.button.left=false;
+m.button.right=false;
+m.button.middle=false;
+if(this._event.which){
+m.button.left=(this._event.which==1);
+m.button.middle=(this._event.which==2);
+m.button.right=(this._event.which==3);
+}else{
+m.button.left=!!(this._event.button&amp;1);
+m.button.right=!!(this._event.button&amp;2);
+m.button.middle=!!(this._event.button&amp;4);
+}
+}
+return m;
+}
+throw new Error(&quot;This is not a mouse event&quot;);
 };
-
-MochiKit.Visual._RoundCorners.prototype = {
-    _doWrap: function (e) {
-        var parent = e.parentNode;
-        var doc = MochiKit.DOM.currentDocument();
-        if (typeof(doc.defaultView) == &quot;undefined&quot;
-            || doc.defaultView == null) {
-            return e;
-        }
-        var style = doc.defaultView.getComputedStyle(e, null);
-        if (typeof(style) == &quot;undefined&quot; || style == null) {
-            return e;
-        }
-        var wrapper = MochiKit.DOM.DIV({&quot;style&quot;: {
-            display: &quot;block&quot;,
-            // convert padding to margin
-            marginTop: style.getPropertyValue(&quot;padding-top&quot;),
-            marginRight: style.getPropertyValue(&quot;padding-right&quot;),
-            marginBottom: style.getPropertyValue(&quot;padding-bottom&quot;),
-            marginLeft: style.getPropertyValue(&quot;padding-left&quot;),
-            // remove padding so the rounding looks right
-            padding: &quot;0px&quot;
-            /*
-            paddingRight: &quot;0px&quot;,
-            paddingLeft: &quot;0px&quot;
-            */
-        }});
-        wrapper.innerHTML = e.innerHTML;
-        e.innerHTML = &quot;&quot;;
-        e.appendChild(wrapper);
-        return e;
-    },
-
-    _roundCornersImpl: function (e, color, bgColor) {
-        if (this.options.border) {
-            this._renderBorder(e, bgColor);
-        }
-        if (this._isTopRounded()) {
-            this._roundTopCorners(e, color, bgColor);
-        }
-        if (this._isBottomRounded()) {
-            this._roundBottomCorners(e, color, bgColor);
-        }
-    },
-
-    _renderBorder: function (el, bgColor) {
-        var borderValue = &quot;1px solid &quot; + this._borderColor(bgColor);
-        var borderL = &quot;border-left: &quot;  + borderValue;
-        var borderR = &quot;border-right: &quot; + borderValue;
-        var style   = &quot;style='&quot; + borderL + &quot;;&quot; + borderR +  &quot;'&quot;;
-        el.innerHTML = &quot;&lt;div &quot; + style + &quot;&gt;&quot; + el.innerHTML + &quot;&lt;/div&gt;&quot;;
-    },
-
-    _roundTopCorners: function (el, color, bgColor) {
-        var corner = this._createCorner(bgColor);
-        for (var i = 0; i &lt; this.options.numSlices; i++) {
-            corner.appendChild(
-                this._createCornerSlice(color, bgColor, i, &quot;top&quot;)
-            );
-        }
-        el.style.paddingTop = 0;
-        el.insertBefore(corner, el.firstChild);
-    },
-
-    _roundBottomCorners: function (el, color, bgColor) {
-        var corner = this._createCorner(bgColor);
-        for (var i = (this.options.numSlices - 1); i &gt;= 0; i--) {
-            corner.appendChild(
-                this._createCornerSlice(color, bgColor, i, &quot;bottom&quot;)
-            );
-        }
-        el.style.paddingBottom = 0;
-        el.appendChild(corner);
-    },
-
-    _createCorner: function (bgColor) {
-        var dom = MochiKit.DOM;
-        return dom.DIV({style: {backgroundColor: bgColor.toString()}});
-    },
-
-    _createCornerSlice: function (color, bgColor, n, position) {
-        var slice = MochiKit.DOM.SPAN();
-
-        var inStyle = slice.style;
-        inStyle.backgroundColor = color.toString();
-        inStyle.display = &quot;block&quot;;
-        inStyle.height = &quot;1px&quot;;
-        inStyle.overflow = &quot;hidden&quot;;
-        inStyle.fontSize = &quot;1px&quot;;
-
-        var borderColor = this._borderColor(color, bgColor);
-        if (this.options.border &amp;&amp; n == 0) {
-            inStyle.borderTopStyle = &quot;solid&quot;;
-            inStyle.borderTopWidth = &quot;1px&quot;;
-            inStyle.borderLeftWidth = &quot;0px&quot;;
-            inStyle.borderRightWidth = &quot;0px&quot;;
-            inStyle.borderBottomWidth = &quot;0px&quot;;
-            // assumes css compliant box model
-            inStyle.height = &quot;0px&quot;;
-            inStyle.borderColor = borderColor.toString();
-        } else if (borderColor) {
-            inStyle.borderColor = borderColor.toString();
-            inStyle.borderStyle = &quot;solid&quot;;
-            inStyle.borderWidth = &quot;0px 1px&quot;;
-        }
-
-        if (!this.options.compact &amp;&amp; (n == (this.options.numSlices - 1))) {
-            inStyle.height = &quot;2px&quot;;
-        }
-
-        this._setMargin(slice, n, position);
-        this._setBorder(slice, n, position);
-
-        return slice;
-    },
-
-    _setOptions: function (options) {
-        this.options = {
-            corners: &quot;all&quot;,
-            color: &quot;fromElement&quot;,
-            bgColor: &quot;fromParent&quot;,
-            blend: true,
-            border: false,
-            compact: false,
-            __unstable__wrapElement: false
-        };
-        MochiKit.Base.update(this.options, options);
-
-        this.options.numSlices = (this.options.compact ? 2 : 4);
-    },
-
-    _whichSideTop: function () {
-        var corners = this.options.corners;
-        if (this._hasString(corners, &quot;all&quot;, &quot;top&quot;)) {
-            return &quot;&quot;;
-        }
-
-        var has_tl = (corners.indexOf(&quot;tl&quot;) != -1);
-        var has_tr = (corners.indexOf(&quot;tr&quot;) != -1);
-        if (has_tl &amp;&amp; has_tr) {
-            return &quot;&quot;;
-        }
-        if (has_tl) {
-            return &quot;left&quot;;
-        }
-        if (has_tr) {
-            return &quot;right&quot;;
-        }
-        return &quot;&quot;;
-    },
-
-    _whichSideBottom: function () {
-        var corners = this.options.corners;
-        if (this._hasString(corners, &quot;all&quot;, &quot;bottom&quot;)) {
-            return &quot;&quot;;
-        }
-
-        var has_bl = (corners.indexOf('bl') != -1);
-        var has_br = (corners.indexOf('br') != -1);
-        if (has_bl &amp;&amp; has_br) {
-            return &quot;&quot;;
-        }
-        if (has_bl) {
-            return &quot;left&quot;;
-        }
-        if (has_br) {
-            return &quot;right&quot;;
-        }
-        return &quot;&quot;;
-    },
-
-    _borderColor: function (color, bgColor) {
-        if (color == &quot;transparent&quot;) {
-            return bgColor;
-        } else if (this.options.border) {
-            return this.options.border;
-        } else if (this.options.blend) {
-            return bgColor.blendedColor(color);
-        }
-        return &quot;&quot;;
-    },
-
-
-    _setMargin: function (el, n, corners) {
-        var marginSize = this._marginSize(n) + &quot;px&quot;;
-        var whichSide = (
-            corners == &quot;top&quot; ? this._whichSideTop() : this._whichSideBottom()
-        );
-        var style = el.style;
-
-        if (whichSide == &quot;left&quot;) {
-            style.marginLeft = marginSize;
-            style.marginRight = &quot;0px&quot;;
-        } else if (whichSide == &quot;right&quot;) {
-            style.marginRight = marginSize;
-            style.marginLeft  = &quot;0px&quot;;
-        } else {
-            style.marginLeft = marginSize;
-            style.marginRight = marginSize;
-        }
-    },
-
-    _setBorder: function (el, n, corners) {
-        var borderSize = this._borderSize(n) + &quot;px&quot;;
-        var whichSide = (
-            corners == &quot;top&quot; ? this._whichSideTop() : this._whichSideBottom()
-        );
-
-        var style = el.style;
-        if (whichSide == &quot;left&quot;) {
-            style.borderLeftWidth = borderSize;
-            style.borderRightWidth = &quot;0px&quot;;
-        } else if (whichSide == &quot;right&quot;) {
-            style.borderRightWidth = borderSize;
-            style.borderLeftWidth  = &quot;0px&quot;;
-        } else {
-            style.borderLeftWidth = borderSize;
-            style.borderRightWidth = borderSize;
-        }
-    },
-
-    _marginSize: function (n) {
-        if (this.isTransparent) {
-            return 0;
-        }
-
-        var o = this.options;
-        if (o.compact &amp;&amp; o.blend) {
-            var smBlendedMarginSizes = [1, 0];
-            return smBlendedMarginSizes[n];
-        } else if (o.compact) {
-            var compactMarginSizes = [2, 1];
-            return compactMarginSizes[n];
-        } else if (o.blend) {
-            var blendedMarginSizes = [3, 2, 1, 0];
-            return blendedMarginSizes[n];
-        } else {
-            var marginSizes = [5, 3, 2, 1];
-            return marginSizes[n];
-        }
-    },
-
-    _borderSize: function (n) {
-        var o = this.options;
-        var borderSizes;
-        if (o.compact &amp;&amp; (o.blend || this.isTransparent)) {
-            return 1;
-        } else if (o.compact) {
-            borderSizes = [1, 0];
-        } else if (o.blend) {
-            borderSizes = [2, 1, 1, 1];
-        } else if (o.border) {
-            borderSizes = [0, 2, 0, 0];
-        } else if (this.isTransparent) {
-            borderSizes = [5, 3, 2, 1];
-        } else {
-            return 0;
-        }
-        return borderSizes[n];
-    },
-
-    _hasString: function (str) {
-        for (var i = 1; i&lt; arguments.length; i++) {
-            if (str.indexOf(arguments[i]) != -1) {
-                return true;
-            }
-        }
-        return false;
-    },
-
-    _isTopRounded: function () {
-        return this._hasString(this.options.corners,
-            &quot;all&quot;, &quot;top&quot;, &quot;tl&quot;, &quot;tr&quot;
-        );
-    },
-
-    _isBottomRounded: function () {
-        return this._hasString(this.options.corners,
-            &quot;all&quot;, &quot;bottom&quot;, &quot;bl&quot;, &quot;br&quot;
-        );
-    },
-
-    _hasSingleTextChild: function (el) {
-        return (el.childNodes.length == 1 &amp;&amp; el.childNodes[0].nodeType == 3);
-    }
+MochiKit.Signal.Event.prototype.stop=function(){
+this.stopPropagation();
+this.preventDefault();
 };
-
-MochiKit.Visual.roundElement = function (e, options) {
-    new MochiKit.Visual._RoundCorners(e, options);
+MochiKit.Signal.Event.prototype.stopPropagation=function(){
+if(this._event.stopPropagation){
+this._event.stopPropagation();
+}else{
+this._event.cancelBubble=true;
+}
 };
-
-MochiKit.Visual.roundClass = function (tagName, className, options) {
-    var elements = MochiKit.DOM.getElementsByTagAndClassName(
-        tagName, className
-    );
-    for (var i = 0; i &lt; elements.length; i++) {
-        MochiKit.Visual.roundElement(elements[i], options);
-    }
+MochiKit.Signal.Event.prototype.preventDefault=function(){
+if(this._event.preventDefault){
+this._event.preventDefault();
+}else{
+this._event.returnValue=false;
+}
 };
-
-// Compatibility with MochiKit 1.0
-MochiKit.Visual.Color = MochiKit.Color.Color;
-MochiKit.Visual.getElementsComputedStyle = MochiKit.DOM.computedStyle;
-
-/* end of Rico adaptation */
-
-MochiKit.Visual.__new__  = function () {
-    var m = MochiKit.Base;
-
-    m.nameFunctions(this);
-
-    this.EXPORT_TAGS = {
-        &quot;:common&quot;: this.EXPORT,
-        &quot;:all&quot;: m.concat(this.EXPORT, this.EXPORT_OK)
-    };
-
+MochiKit.Signal.Event.prototype.__repr__=function(){
+var repr=MochiKit.Base.repr;
+var str=&quot;{event(): &quot;+repr(this.event())+&quot;, type(): &quot;+repr(this.type())+&quot;, target(): &quot;+repr(this.target())+&quot;, modifier(): &quot;+&quot;{alt: &quot;+repr(this.modifier().alt)+&quot;, ctrl: &quot;+repr(this.modifier().ctrl)+&quot;, meta: &quot;+repr(this.modifier().meta)+&quot;, shift: &quot;+repr(this.modifier().shift)+&quot;}&quot;;
+if(this.type()&amp;&amp;this.type().indexOf(&quot;key&quot;)===0){
+str+=&quot;, key(): {code: &quot;+repr(this.key().code)+&quot;, string: &quot;+repr(this.key().string)+&quot;}&quot;;
+}
+if(this.type()&amp;&amp;(this.type().indexOf(&quot;mouse&quot;)===0||this.type().indexOf(&quot;click&quot;)!=-1||this.type()==&quot;contextmenu&quot;)){
+str+=&quot;, mouse(): {page: &quot;+repr(this.mouse().page)+&quot;, client: &quot;+repr(this.mouse().client);
+if(this.type()!=&quot;mousemove&quot;){
+str+=&quot;, button: {left: &quot;+repr(this.mouse().button.left)+&quot;, middle: &quot;+repr(this.mouse().button.middle)+&quot;, right: &quot;+repr(this.mouse().button.right)+&quot;}}&quot;;
+}else{
+str+=&quot;}&quot;;
+}
+}
+if(this.type()==&quot;mouseover&quot;||this.type()==&quot;mouseout&quot;){
+str+=&quot;, relatedTarget(): &quot;+repr(this.relatedTarget());
+}
+str+=&quot;}&quot;;
+return str;
 };
-
-MochiKit.Visual.EXPORT = [
-    &quot;roundElement&quot;,
-    &quot;roundClass&quot;
-];
-
-MochiKit.Visual.EXPORT_OK = [];
-
+MochiKit.Signal.Event.prototype.toString=function(){
+return this.__repr__();
+};
+MochiKit.Base.update(MochiKit.Signal,{__repr__:function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
+},toString:function(){
+return this.__repr__();
+},_specialKeys:{8:&quot;KEY_BACKSPACE&quot;,9:&quot;KEY_TAB&quot;,13:&quot;KEY_ENTER&quot;,16:&quot;KEY_SHIFT&quot;,17:&quot;KEY_CTRL&quot;,18:&quot;KEY_ALT&quot;,19:&quot;KEY_PAUSE&quot;,20:&quot;KEY_CAPS_LOCK&quot;,27:&quot;KEY_ESCAPE&quot;,32:&quot;KEY_SPACE&quot;,33:&quot;KEY_PAGE_UP&quot;,34:&quot;KEY_PAGE_DOWN&quot;,35:&quot;KEY_END&quot;,36:&quot;KEY_HOME&quot;,37:&quot;KEY_LEFT_ARROW&quot;,38:&quot;KEY_UP_ARROW&quot;,39:&quot;KEY_RIGHT_ARROW&quot;,40:&quot;KEY_DOWN_ARROW&quot;,45:&quot;KEY_INSERT&quot;,46:&quot;KEY_DELETE&quot;,91:&quot;KEY_LEFT_WINDOW&quot;,92:&quot;KEY_RIGHT_WINDOW&quot;,93:&quot;KEY_SELECT&quot;,112:&quot;KEY_F1&quot;,113:&quot;KEY_F2&quot;,114:&quot;KEY_F3&quot;,115:&quot;KEY_F4&quot;,116:&quot;KEY_F5&quot;,117:&quot;KEY_F6&quot;,118:&quot;KEY_F7&quot;,119:&quot;KEY_F8&quot;,120:&quot;KEY_F9&quot;,121:&quot;KEY_F10&quot;,122:&quot;KEY_F11&quot;,123:&quot;KEY_F12&quot;,144:&quot;KEY_NUM_LOCK&quot;,145:&quot;KEY_SCROLL_LOCK&quot;},_getSlot:function(slot,func){
+if(typeof (func)==&quot;string&quot;||typeof (func)==&quot;function&quot;){
+if(typeof (func)==&quot;string&quot;&amp;&amp;typeof (slot[func])==&quot;undefined&quot;){
+throw new Error(&quot;Invalid function slot&quot;);
+}
+slot=[slot,func];
+}else{
+if(!func&amp;&amp;typeof (slot)==&quot;function&quot;){
+slot=[slot];
+}else{
+throw new Error(&quot;Invalid slot parameters&quot;);
+}
+}
+return slot;
+},_unloadCache:function(){
+for(var i=0;i&lt;MochiKit.Signal._observers.length;i++){
+var src=MochiKit.Signal._observers[i][0];
+var sig=MochiKit.Signal._observers[i][1];
+var _534=MochiKit.Signal._observers[i][2];
+try{
+if(src.addEventListener){
+src.removeEventListener(sig.substr(2),_534,false);
+}else{
+if(src.attachEvent){
+src.detachEvent(sig,_534);
+}else{
+src._signals[sig]=undefined;
+}
+}
+src._listeners[sig]=undefined;
+delete (src._listeners);
+delete (src._signals);
+}
+catch(e){
+}
+}
+MochiKit.Signal._observers=undefined;
+try{
+window.onload=undefined;
+}
+catch(e){
+}
+try{
+window.onunload=undefined;
+}
+catch(e){
+}
+},connect:function(src,sig,slot,func){
+if(typeof (src)==&quot;string&quot;){
+src=MochiKit.DOM.getElement(src);
+}
+if(typeof (sig)!=&quot;string&quot;){
+throw new Error(&quot;'sig' must be a string&quot;);
+}
+slot=MochiKit.Signal._getSlot(slot,func);
+if(src.addEventListener||src.attachEvent||src[sig]){
+if(!src._listeners){
+src._listeners={};
+}
+if(!src._listeners[sig]){
+var _535=function(_536){
+var _537=new MochiKit.Signal.Event(_536);
+MochiKit.Signal.signal(src,sig,_537);
+return true;
+};
+MochiKit.Signal._observers.push([src,sig,_535]);
+if(src.addEventListener){
+src.addEventListener(sig.substr(2),_535,false);
+}else{
+if(src.attachEvent){
+src.attachEvent(sig,_535);
+}else{
+src[sig]=_535;
+}
+}
+src._listeners[sig]=_535;
+}
+if(!src._signals){
+src._signals={};
+}
+if(!src._signals[sig]){
+src._signals[sig]=[];
+}
+}else{
+if(!src._signals||!src._signals[sig]){
+throw new Error(&quot;No such signal '&quot;+sig+&quot;' registered.&quot;);
+}
+}
+var _538=src._signals[sig];
+for(var i=0;i&lt;_538.length;i++){
+var s=_538[i];
+if(slot[0]===s[0]&amp;&amp;slot[1]===s[1]&amp;&amp;slot[2]===s[2]){
+return;
+}
+}
+_538.push(slot);
+},disconnect:function(src,sig,slot,func){
+if(typeof (src)==&quot;string&quot;){
+src=MochiKit.DOM.getElement(src);
+}
+if(typeof (sig)!=&quot;string&quot;){
+throw new Error(&quot;'signal' must be a string&quot;);
+}
+slot=MochiKit.Signal._getSlot(slot,func);
+if(src._signals&amp;&amp;src._signals[sig]){
+var _539=src._signals[sig];
+var _540=_539.length;
+for(var i=0;i&lt;_539.length;i++){
+var s=_539[i];
+if(s[0]===slot[0]&amp;&amp;s[1]===slot[1]&amp;&amp;s[2]===slot[2]){
+_539.splice(i,1);
+break;
+}
+}
+}else{
+throw new Error(&quot;Invalid signal to disconnect&quot;);
+}
+if(src.addEventListener||src.attachEvent||src._signals[sig]){
+if(src._listeners&amp;&amp;src._listeners[sig]&amp;&amp;src._signals[sig].length===0){
+var _541=src._listeners[sig];
+if(src.addEventListener){
+src.removeEventListener(sig.substr(2),_541,false);
+}else{
+if(src.attachEvent){
+src.detachEvent(sig,_541);
+}else{
+src._signals[sig]=undefined;
+}
+}
+var _542=MochiKit.Signal._observers;
+for(var i=0;i&lt;_542.length;i++){
+var o=_542[i];
+if(o[0]===src&amp;&amp;o[1]===sig&amp;&amp;o[2]===_541){
+_542.splice(i,1);
+break;
+}
+}
+src._listeners[sig]=undefined;
+}
+}
+},signal:function(src,sig){
+if(typeof (src)==&quot;string&quot;){
+src=MochiKit.DOM.getElement(src);
+}
+if(typeof (sig)!=&quot;string&quot;){
+throw new Error(&quot;'signal' must be a string&quot;);
+}
+if(!src._signals||!src._signals[sig]){
+if(src.addEventListener||src.attachEvent||src[sig]){
+return;
+}else{
+throw new Error(&quot;No such signal '&quot;+sig+&quot;'&quot;);
+}
+}
+var _543=src._signals[sig];
+var args=MochiKit.Base.extend(null,arguments,2);
+var slot;
+var _544=[];
+for(var i=0;i&lt;_543.length;i++){
+slot=_543[i];
+try{
+if(slot.length==1){
+slot[0].apply(src,args);
+}else{
+if(typeof (slot[1])==&quot;string&quot;){
+slot[0][slot[1]].apply(slot[0],args);
+}else{
+slot[1].apply(slot[0],args);
+}
+}
+}
+catch(e){
+_544.push(e);
+}
+}
+if(_544.length==1){
+throw _544[0];
+}else{
+if(_544.length){
+var e=new Error(&quot;There were errors in handling signal 'sig'.&quot;);
+e.errors=_544;
+throw e;
+}
+}
+},registerSignals:function(src,_545){
+if(!src._signals){
+src._signals={};
+}
+for(var i=0;i&lt;_545.length;i++){
+var sig=_545[i];
+if(!src._signals[sig]){
+src._signals[sig]=[];
+}
+}
+}});
+MochiKit.Signal.EXPORT_OK=[];
+MochiKit.Signal.EXPORT=[&quot;connect&quot;,&quot;disconnect&quot;,&quot;signal&quot;,&quot;registerSignals&quot;];
+MochiKit.Signal.__new__=function(win){
+var m=MochiKit.Base;
+this._document=document;
+this._window=win;
+try{
+this.connect(window,&quot;onunload&quot;,this._unloadCache);
+}
+catch(e){
+}
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+m.nameFunctions(this);
+};
+MochiKit.Signal.__new__(this);
+MochiKit.Base._exportSymbols(this,MochiKit.Signal);
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.Visual&quot;);
+dojo.require(&quot;MochiKit.Base&quot;);
+dojo.require(&quot;MochiKit.DOM&quot;);
+dojo.require(&quot;MochiKit.Color&quot;);
+}
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
+JSAN.use(&quot;MochiKit.DOM&quot;,[]);
+JSAN.use(&quot;MochiKit.Color&quot;,[]);
+}
+try{
+if(typeof (MochiKit.Base)==&quot;undefined&quot;||typeof (MochiKit.DOM)==&quot;undefined&quot;||typeof (MochiKit.Color)==&quot;undefined&quot;){
+throw &quot;&quot;;
+}
+}
+catch(e){
+throw &quot;MochiKit.Visual depends on MochiKit.Base, MochiKit.DOM and MochiKit.Color!&quot;;
+}
+if(typeof (MochiKit.Visual)==&quot;undefined&quot;){
+MochiKit.Visual={};
+}
+MochiKit.Visual.NAME=&quot;MochiKit.Visual&quot;;
+MochiKit.Visual.VERSION=&quot;1.3&quot;;
+MochiKit.Visual.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
+};
+MochiKit.Visual.toString=function(){
+return this.__repr__();
+};
+MochiKit.Visual._RoundCorners=function(e,_546){
+e=MochiKit.DOM.getElement(e);
+this._setOptions(_546);
+if(this.options.__unstable__wrapElement){
+e=this._doWrap(e);
+}
+var _547=this.options.color;
+var C=MochiKit.Color.Color;
+if(this.options.color==&quot;fromElement&quot;){
+_547=C.fromBackground(e);
+}else{
+if(!(_547 instanceof C)){
+_547=C.fromString(_547);
+}
+}
+this.isTransparent=(_547.asRGB().a&lt;=0);
+var _549=this.options.bgColor;
+if(this.options.bgColor==&quot;fromParent&quot;){
+_549=C.fromBackground(e.offsetParent);
+}else{
+if(!(_549 instanceof C)){
+_549=C.fromString(_549);
+}
+}
+this._roundCornersImpl(e,_547,_549);
+};
+MochiKit.Visual._RoundCorners.prototype={_doWrap:function(e){
+var _550=e.parentNode;
+var doc=MochiKit.DOM.currentDocument();
+if(typeof (doc.defaultView)==&quot;undefined&quot;||doc.defaultView==null){
+return e;
+}
+var _551=doc.defaultView.getComputedStyle(e,null);
+if(typeof (_551)==&quot;undefined&quot;||_551==null){
+return e;
+}
+var _552=MochiKit.DOM.DIV({&quot;style&quot;:{display:&quot;block&quot;,marginTop:_551.getPropertyValue(&quot;padding-top&quot;),marginRight:_551.getPropertyValue(&quot;padding-right&quot;),marginBottom:_551.getPropertyValue(&quot;padding-bottom&quot;),marginLeft:_551.getPropertyValue(&quot;padding-left&quot;),padding:&quot;0px&quot;}});
+_552.innerHTML=e.innerHTML;
+e.innerHTML=&quot;&quot;;
+e.appendChild(_552);
+return e;
+},_roundCornersImpl:function(e,_553,_554){
+if(this.options.border){
+this._renderBorder(e,_554);
+}
+if(this._isTopRounded()){
+this._roundTopCorners(e,_553,_554);
+}
+if(this._isBottomRounded()){
+this._roundBottomCorners(e,_553,_554);
+}
+},_renderBorder:function(el,_555){
+var _556=&quot;1px solid &quot;+this._borderColor(_555);
+var _557=&quot;border-left: &quot;+_556;
+var _558=&quot;border-right: &quot;+_556;
+var _559=&quot;style='&quot;+_557+&quot;;&quot;+_558+&quot;'&quot;;
+el.innerHTML=&quot;&lt;div &quot;+_559+&quot;&gt;&quot;+el.innerHTML+&quot;&lt;/div&gt;&quot;;
+},_roundTopCorners:function(el,_560,_561){
+var _562=this._createCorner(_561);
+for(var i=0;i&lt;this.options.numSlices;i++){
+_562.appendChild(this._createCornerSlice(_560,_561,i,&quot;top&quot;));
+}
+el.style.paddingTop=0;
+el.insertBefore(_562,el.firstChild);
+},_roundBottomCorners:function(el,_563,_564){
+var _565=this._createCorner(_564);
+for(var i=(this.options.numSlices-1);i&gt;=0;i--){
+_565.appendChild(this._createCornerSlice(_563,_564,i,&quot;bottom&quot;));
+}
+el.style.paddingBottom=0;
+el.appendChild(_565);
+},_createCorner:function(_566){
+var dom=MochiKit.DOM;
+return dom.DIV({style:{backgroundColor:_566.toString()}});
+},_createCornerSlice:function(_567,_568,n,_569){
+var _570=MochiKit.DOM.SPAN();
+var _571=_570.style;
+_571.backgroundColor=_567.toString();
+_571.display=&quot;block&quot;;
+_571.height=&quot;1px&quot;;
+_571.overflow=&quot;hidden&quot;;
+_571.fontSize=&quot;1px&quot;;
+var _572=this._borderColor(_567,_568);
+if(this.options.border&amp;&amp;n==0){
+_571.borderTopStyle=&quot;solid&quot;;
+_571.borderTopWidth=&quot;1px&quot;;
+_571.borderLeftWidth=&quot;0px&quot;;
+_571.borderRightWidth=&quot;0px&quot;;
+_571.borderBottomWidth=&quot;0px&quot;;
+_571.height=&quot;0px&quot;;
+_571.borderColor=_572.toString();
+}else{
+if(_572){
+_571.borderColor=_572.toString();
+_571.borderStyle=&quot;solid&quot;;
+_571.borderWidth=&quot;0px 1px&quot;;
+}
+}
+if(!this.options.compact&amp;&amp;(n==(this.options.numSlices-1))){
+_571.height=&quot;2px&quot;;
+}
+this._setMargin(_570,n,_569);
+this._setBorder(_570,n,_569);
+return _570;
+},_setOptions:function(_573){
+this.options={corners:&quot;all&quot;,color:&quot;fromElement&quot;,bgColor:&quot;fromParent&quot;,blend:true,border:false,compact:false,__unstable__wrapElement:false};
+MochiKit.Base.update(this.options,_573);
+this.options.numSlices=(this.options.compact?2:4);
+},_whichSideTop:function(){
+var _574=this.options.corners;
+if(this._hasString(_574,&quot;all&quot;,&quot;top&quot;)){
+return &quot;&quot;;
+}
+var _575=(_574.indexOf(&quot;tl&quot;)!=-1);
+var _576=(_574.indexOf(&quot;tr&quot;)!=-1);
+if(_575&amp;&amp;_576){
+return &quot;&quot;;
+}
+if(_575){
+return &quot;left&quot;;
+}
+if(_576){
+return &quot;right&quot;;
+}
+return &quot;&quot;;
+},_whichSideBottom:function(){
+var _577=this.options.corners;
+if(this._hasString(_577,&quot;all&quot;,&quot;bottom&quot;)){
+return &quot;&quot;;
+}
+var _578=(_577.indexOf(&quot;bl&quot;)!=-1);
+var _579=(_577.indexOf(&quot;br&quot;)!=-1);
+if(_578&amp;&amp;_579){
+return &quot;&quot;;
+}
+if(_578){
+return &quot;left&quot;;
+}
+if(_579){
+return &quot;right&quot;;
+}
+return &quot;&quot;;
+},_borderColor:function(_580,_581){
+if(_580==&quot;transparent&quot;){
+return _581;
+}else{
+if(this.options.border){
+return this.options.border;
+}else{
+if(this.options.blend){
+return _581.blendedColor(_580);
+}
+}
+}
+return &quot;&quot;;
+},_setMargin:function(el,n,_582){
+var _583=this._marginSize(n)+&quot;px&quot;;
+var _584=(_582==&quot;top&quot;?this._whichSideTop():this._whichSideBottom());
+var _585=el.style;
+if(_584==&quot;left&quot;){
+_585.marginLeft=_583;
+_585.marginRight=&quot;0px&quot;;
+}else{
+if(_584==&quot;right&quot;){
+_585.marginRight=_583;
+_585.marginLeft=&quot;0px&quot;;
+}else{
+_585.marginLeft=_583;
+_585.marginRight=_583;
+}
+}
+},_setBorder:function(el,n,_586){
+var _587=this._borderSize(n)+&quot;px&quot;;
+var _588=(_586==&quot;top&quot;?this._whichSideTop():this._whichSideBottom());
+var _589=el.style;
+if(_588==&quot;left&quot;){
+_589.borderLeftWidth=_587;
+_589.borderRightWidth=&quot;0px&quot;;
+}else{
+if(_588==&quot;right&quot;){
+_589.borderRightWidth=_587;
+_589.borderLeftWidth=&quot;0px&quot;;
+}else{
+_589.borderLeftWidth=_587;
+_589.borderRightWidth=_587;
+}
+}
+},_marginSize:function(n){
+if(this.isTransparent){
+return 0;
+}
+var o=this.options;
+if(o.compact&amp;&amp;o.blend){
+var _590=[1,0];
+return _590[n];
+}else{
+if(o.compact){
+var _591=[2,1];
+return _591[n];
+}else{
+if(o.blend){
+var _592=[3,2,1,0];
+return _592[n];
+}else{
+var _593=[5,3,2,1];
+return _593[n];
+}
+}
+}
+},_borderSize:function(n){
+var o=this.options;
+var _594;
+if(o.compact&amp;&amp;(o.blend||this.isTransparent)){
+return 1;
+}else{
+if(o.compact){
+_594=[1,0];
+}else{
+if(o.blend){
+_594=[2,1,1,1];
+}else{
+if(o.border){
+_594=[0,2,0,0];
+}else{
+if(this.isTransparent){
+_594=[5,3,2,1];
+}else{
+return 0;
+}
+}
+}
+}
+}
+return _594[n];
+},_hasString:function(str){
+for(var i=1;i&lt;arguments.length;i++){
+if(str.indexOf(arguments[i])!=-1){
+return true;
+}
+}
+return false;
+},_isTopRounded:function(){
+return this._hasString(this.options.corners,&quot;all&quot;,&quot;top&quot;,&quot;tl&quot;,&quot;tr&quot;);
+},_isBottomRounded:function(){
+return this._hasString(this.options.corners,&quot;all&quot;,&quot;bottom&quot;,&quot;bl&quot;,&quot;br&quot;);
+},_hasSingleTextChild:function(el){
+return (el.childNodes.length==1&amp;&amp;el.childNodes[0].nodeType==3);
+}};
+MochiKit.Visual.roundElement=function(e,_595){
+new MochiKit.Visual._RoundCorners(e,_595);
+};
+MochiKit.Visual.roundClass=function(_596,_597,_598){
+var _599=MochiKit.DOM.getElementsByTagAndClassName(_596,_597);
+for(var i=0;i&lt;_599.length;i++){
+MochiKit.Visual.roundElement(_599[i],_598);
+}
+};
+MochiKit.Visual.Color=MochiKit.Color.Color;
+MochiKit.Visual.getElementsComputedStyle=MochiKit.DOM.computedStyle;
+MochiKit.Visual.__new__=function(){
+var m=MochiKit.Base;
+m.nameFunctions(this);
+this.EXPORT_TAGS={&quot;:common&quot;:this.EXPORT,&quot;:all&quot;:m.concat(this.EXPORT,this.EXPORT_OK)};
+};
+MochiKit.Visual.EXPORT=[&quot;roundElement&quot;,&quot;roundClass&quot;];
+MochiKit.Visual.EXPORT_OK=[];
 MochiKit.Visual.__new__();
+MochiKit.Base._exportSymbols(this,MochiKit.Visual);
+if(typeof (MochiKit)==&quot;undefined&quot;){
+MochiKit={};
+}
+if(typeof (MochiKit.MochiKit)==&quot;undefined&quot;){
+MochiKit.MochiKit={};
+}
+MochiKit.MochiKit.NAME=&quot;MochiKit.MochiKit&quot;;
+MochiKit.MochiKit.VERSION=&quot;1.3&quot;;
+MochiKit.MochiKit.__repr__=function(){
+return &quot;[&quot;+this.NAME+&quot; &quot;+this.VERSION+&quot;]&quot;;
+};
+MochiKit.MochiKit.toString=function(){
+return this.__repr__();
+};
+MochiKit.MochiKit.SUBMODULES=[&quot;Base&quot;,&quot;Iter&quot;,&quot;Logging&quot;,&quot;DateTime&quot;,&quot;Format&quot;,&quot;Async&quot;,&quot;DOM&quot;,&quot;LoggingPane&quot;,&quot;Color&quot;,&quot;Signal&quot;,&quot;Visual&quot;];
+if(typeof (JSAN)!=&quot;undefined&quot;||typeof (dojo)!=&quot;undefined&quot;){
+if(typeof (dojo)!=&quot;undefined&quot;){
+dojo.provide(&quot;MochiKit.MochiKit&quot;);
+dojo.require(&quot;MochiKit.*&quot;);
+}
+if(typeof (JSAN)!=&quot;undefined&quot;){
+JSAN.use(&quot;MochiKit.Base&quot;,[]);
+JSAN.use(&quot;MochiKit.Iter&quot;,[]);
+JSAN.use(&quot;MochiKit.Logging&quot;,[]);
+JSAN.use(&quot;MochiKit.DateTime&quot;,[]);
+JSAN.use(&quot;MochiKit.Format&quot;,[]);
+JSAN.use(&quot;MochiKit.Async&quot;,[]);
+JSAN.use(&quot;MochiKit.DOM&quot;,[]);
+JSAN.use(&quot;MochiKit.LoggingPane&quot;,[]);
+JSAN.use(&quot;MochiKit.Color&quot;,[]);
+JSAN.use(&quot;MochiKit.Signal&quot;,[]);
+JSAN.use(&quot;MochiKit.Visual&quot;,[]);
+}
+(function(){
+var _600=MochiKit.Base.extend;
+var self=MochiKit.MochiKit;
+var _601=self.SUBMODULES;
+var _602=[];
+var _603=[];
+var _604={};
+var i,k,m,all;
+for(i=0;i&lt;_601.length;i++){
+m=MochiKit[_601[i]];
+_600(_602,m.EXPORT);
+_600(_603,m.EXPORT_OK);
+for(k in m.EXPORT_TAGS){
+_604[k]=_600(_604[k],m.EXPORT_TAGS[k]);
+}
+all=m.EXPORT_TAGS[&quot;:all&quot;];
+if(!all){
+all=_600(null,m.EXPORT,m.EXPORT_OK);
+}
+var j;
+for(j=0;j&lt;all.length;j++){
+k=all[j];
+self[k]=m[k];
+}
+}
+self.EXPORT=_602;
+self.EXPORT_OK=_603;
+self.EXPORT_TAGS=_604;
+}());
+}else{
+if(typeof (MochiKit.__compat__)==&quot;undefined&quot;){
+MochiKit.__compat__=true;
+}
+(function(){
+var _605=document.getElementsByTagName(&quot;script&quot;);
+var _606=&quot;<A HREF="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul</A>&quot;;
+var base=null;
+var _607=null;
+var _608={};
+var i;
+for(i=0;i&lt;_605.length;i++){
+var src=_605[i].getAttribute(&quot;src&quot;);
+if(!src){
+continue;
+}
+_608[src]=true;
+if(src.match(/MochiKit.js$/)){
+base=src.substring(0,src.lastIndexOf(&quot;MochiKit.js&quot;));
+_607=_605[i];
+}
+}
+if(base==null){
+return;
+}
+var _609=MochiKit.MochiKit.SUBMODULES;
+for(var i=0;i&lt;_609.length;i++){
+if(MochiKit[_609[i]]){
+continue;
+}
+var uri=base+_609[i]+&quot;.js&quot;;
+if(uri in _608){
+continue;
+}
+if(document.documentElement&amp;&amp;document.documentElement.namespaceURI==_606){
+var s=document.createElementNS(_606,&quot;script&quot;);
+s.setAttribute(&quot;id&quot;,&quot;MochiKit_&quot;+base+_609[i]);
+s.setAttribute(&quot;src&quot;,uri);
+s.setAttribute(&quot;type&quot;,&quot;application/x-javascript&quot;);
+_607.parentNode.appendChild(s);
+}else{
+document.write(&quot;&lt;script src=\&quot;&quot;+uri+&quot;\&quot; type=\&quot;text/javascript\&quot;&gt;&lt;/script&gt;&quot;);
+}
+}
+})();
+}
 
-MochiKit.Base._exportSymbols(this, MochiKit.Visual);
+

Modified: trunk/tests/test_View.js
===================================================================
--- trunk/tests/test_View.js	2006-03-12 15:56:31 UTC (rev 9)
+++ trunk/tests/test_View.js	2006-03-19 01:41:45 UTC (rev 10)
@@ -4,6 +4,8 @@
 
 tests.test_View = function (t) {
 	Freja.AssetManager.HTTP_REQUEST_TYPE = &quot;sync&quot;;
+	Freja.AssetManager.XSLT_SERVICE_URL = &quot;../external/srvc-xslt.php&quot;;
+	Freja.AssetManager.XSLT_SERVICE_URL = &quot;../external/srvc-xslt.php?path=tests/&quot;;
 	var view = Freja.AssetManager.getView(&quot;data/view.xsl&quot;);
 	t.ok(view instanceof Freja.View);
 	t.is(view.ready, true, &quot;state should be ready (loaded)&quot;);
@@ -13,10 +15,10 @@
 	var out = document.createElement(&quot;DIV&quot;);
 	view.placeholder = out;
 	view.render(model);
-	t.ok(out.firstChild.nodeName.toLowerCase() == &quot;div&quot;);
-	t.ok(out.firstChild.firstChild.nodeName.toLowerCase() == &quot;h3&quot;);
-	t.is(out.firstChild.firstChild.firstChild.nodeValue, model.get(&quot;item/name&quot;), &quot;Rendered view should contain the models value&quot;);
 
+	t.is(out.getElementsByTagName(&quot;H3&quot;).length, 1);
+	t.is(out.getElementsByTagName(&quot;H3&quot;).item(0).firstChild.nodeValue, model.get(&quot;item/name&quot;), &quot;Rendered view should contain the models value&quot;);
+
 	// test of form
 	var formView = Freja.AssetManager.getView(&quot;data/form-view.xsl&quot;);
 	var testofsubmit = false;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000005.html">[Freja-svn] r9 - trunk/lib
</A></li>
	<LI>Next message: <A HREF="000006.html">[Freja-svn] r11 - in trunk: examples/contacts examples/contacts/models/php_inc examples/contacts/views lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8">[ date ]</a>
              <a href="thread.html#8">[ thread ]</a>
              <a href="subject.html#8">[ subject ]</a>
              <a href="author.html#8">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/freja-svn">More information about the Freja-svn
mailing list</a><br>
</body></html>
